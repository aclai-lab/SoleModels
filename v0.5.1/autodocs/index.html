<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Full reference · SoleModels.jl</title><meta name="title" content="Full reference · SoleModels.jl"/><meta property="og:title" content="Full reference · SoleModels.jl"/><meta property="twitter:title" content="Full reference · SoleModels.jl"/><meta name="description" content="Documentation for SoleModels.jl."/><meta property="og:description" content="Documentation for SoleModels.jl."/><meta property="twitter:description" content="Documentation for SoleModels.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SoleModels.jl/autodocs/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SoleModels.jl/autodocs/"/><link rel="canonical" href="https://aclai-lab.github.io/SoleModels.jl/autodocs/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SoleModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../logic/">Logical foundations</a></li><li><a class="tocitem" href="../logisets/">Logisets</a></li><li><a class="tocitem" href="../models/">Symbolic models</a></li><li class="is-active"><a class="tocitem" href>Full reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Full reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Full reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleModels.jl/blob/main/docs/src/autodocs.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-Reference"><a class="docs-heading-anchor" href="#Full-Reference">Full Reference</a><a id="Full-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Reference" title="Permalink"></a></h1><ul><li><a href="../logic/#SoleLogics.CONJUNCTION"><code>SoleLogics.CONJUNCTION</code></a></li><li><a href="../logic/#SoleLogics.DISJUNCTION"><code>SoleLogics.DISJUNCTION</code></a></li><li><a href="../logic/#SoleLogics.IA_L"><code>SoleLogics.IA_L</code></a></li><li><a href="../logic/#SoleLogics.globalrel"><code>SoleLogics.globalrel</code></a></li><li><a href="#SoleModels.BASE_FEATURE_ALIASES"><code>SoleModels.BASE_FEATURE_ALIASES</code></a></li><li><a href="../logic/#SoleLogics.AbstractAlphabet"><code>SoleLogics.AbstractAlphabet</code></a></li><li><a href="../logic/#SoleLogics.AbstractFrame"><code>SoleLogics.AbstractFrame</code></a></li><li><a href="../logic/#SoleLogics.AbstractInterpretation"><code>SoleLogics.AbstractInterpretation</code></a></li><li><a href="../logic/#SoleLogics.AbstractInterpretationSet"><code>SoleLogics.AbstractInterpretationSet</code></a></li><li><a href="../logic/#SoleLogics.AbstractKripkeStructure"><code>SoleLogics.AbstractKripkeStructure</code></a></li><li><a href="../logic/#SoleLogics.AbstractRelation"><code>SoleLogics.AbstractRelation</code></a></li><li><a href="../logic/#SoleLogics.AbstractWorld"><code>SoleLogics.AbstractWorld</code></a></li><li><a href="../logic/#SoleLogics.Atom"><code>SoleLogics.Atom</code></a></li><li><a href="../logic/#SoleLogics.Formula"><code>SoleLogics.Formula</code></a></li><li><a href="../logic/#SoleLogics.GeometricalWorld"><code>SoleLogics.GeometricalWorld</code></a></li><li><a href="../logic/#SoleLogics.Interval"><code>SoleLogics.Interval</code></a></li><li><a href="../logic/#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a></li><li><a href="#SoleModels.AbstractCondition"><code>SoleModels.AbstractCondition</code></a></li><li><a href="#SoleModels.AbstractConditionalAlphabet"><code>SoleModels.AbstractConditionalAlphabet</code></a></li><li><a href="#SoleModels.AbstractFeature"><code>SoleModels.AbstractFeature</code></a></li><li><a href="#SoleModels.AbstractFullMemoset"><code>SoleModels.AbstractFullMemoset</code></a></li><li><a href="#SoleModels.AbstractLogiset"><code>SoleModels.AbstractLogiset</code></a></li><li><a href="#SoleModels.AbstractMemoset"><code>SoleModels.AbstractMemoset</code></a></li><li><a href="#SoleModels.AbstractModel"><code>SoleModels.AbstractModel</code></a></li><li><a href="#SoleModels.AbstractOneStepMemoset"><code>SoleModels.AbstractOneStepMemoset</code></a></li><li><a href="#SoleModels.AbstractScalarOneStepGlobalMemoset"><code>SoleModels.AbstractScalarOneStepGlobalMemoset</code></a></li><li><a href="#SoleModels.AbstractScalarOneStepRelationalMemoset"><code>SoleModels.AbstractScalarOneStepRelationalMemoset</code></a></li><li><a href="#SoleModels.AbstractUnivariateFeature"><code>SoleModels.AbstractUnivariateFeature</code></a></li><li><a href="#SoleModels.Aggregator"><code>SoleModels.Aggregator</code></a></li><li><a href="#SoleModels.BoundedScalarConditions"><code>SoleModels.BoundedScalarConditions</code></a></li><li><a href="#SoleModels.Branch"><code>SoleModels.Branch</code></a></li><li><a href="#SoleModels.CLabel"><code>SoleModels.CLabel</code></a></li><li><a href="#SoleModels.ConstantModel"><code>SoleModels.ConstantModel</code></a></li><li><a href="#SoleModels.ConstrainedModel"><code>SoleModels.ConstrainedModel</code></a></li><li><a href="#SoleModels.DecisionForest"><code>SoleModels.DecisionForest</code></a></li><li><a href="#SoleModels.DecisionList"><code>SoleModels.DecisionList</code></a></li><li><a href="#SoleModels.DecisionTree"><code>SoleModels.DecisionTree</code></a></li><li><a href="#SoleModels.DimensionalDatasets.AbstractUniformFullDimensionalLogiset"><code>SoleModels.DimensionalDatasets.AbstractUniformFullDimensionalLogiset</code></a></li><li><a href="#SoleModels.DimensionalDatasets.AbstractUniformFullDimensionalOneStepRelationalMemoset"><code>SoleModels.DimensionalDatasets.AbstractUniformFullDimensionalOneStepRelationalMemoset</code></a></li><li><a href="#SoleModels.DimensionalDatasets.UniformFullDimensionalLogiset"><code>SoleModels.DimensionalDatasets.UniformFullDimensionalLogiset</code></a></li><li><a href="#SoleModels.DimensionalDatasets.UniformFullDimensionalOneStepRelationalMemoset"><code>SoleModels.DimensionalDatasets.UniformFullDimensionalOneStepRelationalMemoset</code></a></li><li><a href="#SoleModels.ExistentialTopFormula"><code>SoleModels.ExistentialTopFormula</code></a></li><li><a href="#SoleModels.ExplicitBooleanLogiset"><code>SoleModels.ExplicitBooleanLogiset</code></a></li><li><a href="#SoleModels.ExplicitFeature"><code>SoleModels.ExplicitFeature</code></a></li><li><a href="#SoleModels.ExplicitLogiset"><code>SoleModels.ExplicitLogiset</code></a></li><li><a href="#SoleModels.Feature"><code>SoleModels.Feature</code></a></li><li><a href="#SoleModels.FullMemoset"><code>SoleModels.FullMemoset</code></a></li><li><a href="#SoleModels.FunctionModel"><code>SoleModels.FunctionModel</code></a></li><li><a href="#SoleModels.FunctionalCondition"><code>SoleModels.FunctionalCondition</code></a></li><li><a href="#SoleModels.Label"><code>SoleModels.Label</code></a></li><li><a href="#SoleModels.LeafModel"><code>SoleModels.LeafModel</code></a></li><li><a href="#SoleModels.MixedSymbolicModel"><code>SoleModels.MixedSymbolicModel</code></a></li><li><a href="#SoleModels.MultiFormula"><code>SoleModels.MultiFormula</code></a></li><li><a href="#SoleModels.MultiLogiset"><code>SoleModels.MultiLogiset</code></a></li><li><a href="#SoleModels.MultivariateFeature"><code>SoleModels.MultivariateFeature</code></a></li><li><a href="#SoleModels.RLabel"><code>SoleModels.RLabel</code></a></li><li><a href="#SoleModels.Rule"><code>SoleModels.Rule</code></a></li><li><a href="#SoleModels.ScalarChainedMemoset"><code>SoleModels.ScalarChainedMemoset</code></a></li><li><a href="#SoleModels.ScalarCondition"><code>SoleModels.ScalarCondition</code></a></li><li><a href="#SoleModels.ScalarExistentialFormula"><code>SoleModels.ScalarExistentialFormula</code></a></li><li><a href="#SoleModels.ScalarFormula"><code>SoleModels.ScalarFormula</code></a></li><li><a href="#SoleModels.ScalarMetaCondition"><code>SoleModels.ScalarMetaCondition</code></a></li><li><a href="#SoleModels.ScalarOneStepMemoset"><code>SoleModels.ScalarOneStepMemoset</code></a></li><li><a href="#SoleModels.ScalarOneStepRelationalMemoset"><code>SoleModels.ScalarOneStepRelationalMemoset</code></a></li><li><a href="#SoleModels.ScalarPropositionFormula"><code>SoleModels.ScalarPropositionFormula</code></a></li><li><a href="#SoleModels.ScalarUniversalFormula"><code>SoleModels.ScalarUniversalFormula</code></a></li><li><a href="#SoleModels.SupportedLogiset"><code>SoleModels.SupportedLogiset</code></a></li><li><a href="#SoleModels.TestOperator"><code>SoleModels.TestOperator</code></a></li><li><a href="#SoleModels.UnboundedScalarConditions"><code>SoleModels.UnboundedScalarConditions</code></a></li><li><a href="#SoleModels.UnivariateFeature"><code>SoleModels.UnivariateFeature</code></a></li><li><a href="#SoleModels.UnivariateMax"><code>SoleModels.UnivariateMax</code></a></li><li><a href="#SoleModels.UnivariateMin"><code>SoleModels.UnivariateMin</code></a></li><li><a href="#SoleModels.UnivariateNamedFeature"><code>SoleModels.UnivariateNamedFeature</code></a></li><li><a href="#SoleModels.UnivariateSoftMax"><code>SoleModels.UnivariateSoftMax</code></a></li><li><a href="#SoleModels.UnivariateSoftMin"><code>SoleModels.UnivariateSoftMin</code></a></li><li><a href="#SoleModels.UnivariateValue"><code>SoleModels.UnivariateValue</code></a></li><li><a href="#SoleModels.UniversalBotFormula"><code>SoleModels.UniversalBotFormula</code></a></li><li><a href="#SoleModels.ValueCondition"><code>SoleModels.ValueCondition</code></a></li><li><a href="#SoleModels.VarFeature"><code>SoleModels.VarFeature</code></a></li><li><a href="#Base.isopen-Tuple{SoleModels.AbstractModel}"><code>Base.isopen</code></a></li><li><a href="#Base.rand-Tuple{Random.AbstractRNG, SoleModels.BoundedScalarConditions}"><code>Base.rand</code></a></li><li><a href="../logic/#SoleLogics.accessibles"><code>SoleLogics.accessibles</code></a></li><li><a href="../logic/#SoleLogics.check"><code>SoleLogics.check</code></a></li><li><a href="../logic/#SoleLogics.syntaxstring"><code>SoleLogics.syntaxstring</code></a></li><li><a href="#SoleModels.antecedent-Tuple{Rule}"><code>SoleModels.antecedent</code></a></li><li><a href="#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>SoleModels.apply</code></a></li><li><a href="#SoleModels.apply_test_operator-Union{Tuple{T2}, Tuple{T1}, Tuple{Function, T1, T2}} where {T1, T2}"><code>SoleModels.apply_test_operator</code></a></li><li><a href="#SoleModels.balanced_weights-Union{Tuple{AbstractVector{L}}, Tuple{L}} where L&lt;:Union{Integer, String, CategoricalArrays.CategoricalValue}"><code>SoleModels.balanced_weights</code></a></li><li><a href="#SoleModels.bestguess"><code>SoleModels.bestguess</code></a></li><li><a href="#SoleModels.check_model_constraints"><code>SoleModels.check_model_constraints</code></a></li><li><a href="#SoleModels.checkantecedent"><code>SoleModels.checkantecedent</code></a></li><li><a href="#SoleModels.computefeature-Tuple{VarFeature, Any}"><code>SoleModels.computefeature</code></a></li><li><a href="#SoleModels.computeunivariatefeature-Tuple{SoleModels.AbstractUnivariateFeature, Any}"><code>SoleModels.computeunivariatefeature</code></a></li><li><a href="#SoleModels.consequent-Tuple{Rule}"><code>SoleModels.consequent</code></a></li><li><a href="#SoleModels.default_weights-Tuple{Integer}"><code>SoleModels.default_weights</code></a></li><li><a href="#SoleModels.displaymodel-Tuple{SoleModels.AbstractModel}"><code>SoleModels.displaymodel</code></a></li><li><a href="#SoleModels.evaluaterule-Union{Tuple{FM}, Tuple{A}, Tuple{O}, Tuple{Rule{O, A, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}}}} where {O, A, FM&lt;:SoleModels.AbstractModel}"><code>SoleModels.evaluaterule</code></a></li><li><a href="#SoleModels.feasiblemodelstype-Union{Tuple{Type{M}}, Tuple{M}, Tuple{O}} where {O, M&lt;:SoleModels.AbstractModel{O}}"><code>SoleModels.feasiblemodelstype</code></a></li><li><a href="#SoleModels.featvaltype-Tuple{Any, VarFeature}"><code>SoleModels.featvaltype</code></a></li><li><a href="#SoleModels.immediatesubmodels-Union{Tuple{SoleModels.AbstractModel{O}}, Tuple{O}} where O"><code>SoleModels.immediatesubmodels</code></a></li><li><a href="#SoleModels.info-Tuple{SoleModels.AbstractModel}"><code>SoleModels.info</code></a></li><li><a href="#SoleModels.isminifiable-Tuple{Any}"><code>SoleModels.isminifiable</code></a></li><li><a href="#SoleModels.issymbolic-Tuple{SoleModels.AbstractModel}"><code>SoleModels.issymbolic</code></a></li><li><a href="#SoleModels.joinrules"><code>SoleModels.joinrules</code></a></li><li><a href="#SoleModels.listimmediaterules-Tuple{SoleModels.AbstractModel}"><code>SoleModels.listimmediaterules</code></a></li><li><a href="#SoleModels.listrules-Tuple{SoleModels.AbstractModel}"><code>SoleModels.listrules</code></a></li><li><a href="#SoleModels.minify-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Union{Missing, Nothing, Real}"><code>SoleModels.minify</code></a></li><li><a href="#SoleModels.naturalgrouping-Tuple{DataFrames.AbstractDataFrame}"><code>SoleModels.naturalgrouping</code></a></li><li><a href="#SoleModels.negconsequent-Tuple{Branch}"><code>SoleModels.negconsequent</code></a></li><li><a href="#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>SoleModels.outcometype</code></a></li><li><a href="#SoleModels.outputtype-Tuple{SoleModels.AbstractModel}"><code>SoleModels.outputtype</code></a></li><li><a href="#SoleModels.parsecondition-Tuple{Type{&lt;:SoleModels.AbstractCondition}, String}"><code>SoleModels.parsecondition</code></a></li><li><a href="#SoleModels.parsefeature-Tuple{Type{&lt;:AbstractFeature}, String}"><code>SoleModels.parsefeature</code></a></li><li><a href="#SoleModels.posconsequent-Tuple{Branch}"><code>SoleModels.posconsequent</code></a></li><li><a href="../models/#SoleModels.printmodel"><code>SoleModels.printmodel</code></a></li><li><a href="#SoleModels.printmodel-Tuple{IO, SoleModels.AbstractModel}"><code>SoleModels.printmodel</code></a></li><li><a href="#SoleModels.propagate_feasiblemodels-Tuple{Type{&lt;:SoleModels.AbstractModel}}"><code>SoleModels.propagate_feasiblemodels</code></a></li><li><a href="#SoleModels.readmetrics-Union{Tuple{SoleModels.LeafModel{L}}, Tuple{L}} where L&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}"><code>SoleModels.readmetrics</code></a></li><li><a href="#SoleModels.representatives-Union{Tuple{W}, Tuple{SoleLogics.AbstractFrame{W}, W, AbstractRelation, SoleModels.AbstractCondition}} where W&lt;:AbstractWorld"><code>SoleModels.representatives</code></a></li><li><a href="#SoleModels.rulemetrics-Union{Tuple{FM}, Tuple{A}, Tuple{O}, Tuple{Rule{O, A, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}}}} where {O, A, FM&lt;:SoleModels.AbstractModel}"><code>SoleModels.rulemetrics</code></a></li><li><a href="#SoleModels.scalarlogiset"><code>SoleModels.scalarlogiset</code></a></li><li><a href="#SoleModels.submodels-Tuple{SoleModels.AbstractModel}"><code>SoleModels.submodels</code></a></li><li><a href="#SoleModels.variable_name-Tuple{SoleModels.AbstractUnivariateFeature}"><code>SoleModels.variable_name</code></a></li><li><a href="#SoleModels.wrap-Tuple{Any, Type{&lt;:SoleModels.AbstractModel}}"><code>SoleModels.wrap</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.BASE_FEATURE_ALIASES" href="#SoleModels.BASE_FEATURE_ALIASES"><code>SoleModels.BASE_FEATURE_ALIASES</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Syntaxstring aliases for standard features, such as &quot;min&quot;, &quot;max&quot;, &quot;avg&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/var-features.jl#L438-L440">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.CLabel" href="#SoleModels.CLabel"><code>SoleModels.CLabel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const CLabel  = Union{String,Integer,CategoricalValue}
const RLabel  = AbstractFloat
const Label   = Union{CLabel,RLabel}</code></pre><p>Types for supervised machine learning labels (classification and regression).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/machine-learning.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.Label" href="#SoleModels.Label"><code>SoleModels.Label</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const CLabel  = Union{String,Integer,CategoricalValue}
const RLabel  = AbstractFloat
const Label   = Union{CLabel,RLabel}</code></pre><p>Types for supervised machine learning labels (classification and regression).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/machine-learning.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.AbstractCondition" href="#SoleModels.AbstractCondition"><code>SoleModels.AbstractCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractCondition{FT&lt;:AbstractFeature} end</code></pre><p>Abstract type for representing conditions that can be interpreted and evaluated on worlds of instances of a logical dataset. In logical contexts, these are wrapped into <code>Atom</code>s.</p><p>See also <a href="../logic/#SoleLogics.Atom"><code>Atom</code></a>, <a href="../logic/#SoleLogics.syntaxstring"><code>syntaxstring</code></a>, <a href="#SoleModels.ScalarMetaCondition"><code>ScalarMetaCondition</code></a>, <a href="#SoleModels.ScalarCondition"><code>ScalarCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/conditions.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.AbstractConditionalAlphabet" href="#SoleModels.AbstractConditionalAlphabet"><code>SoleModels.AbstractConditionalAlphabet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractConditionalAlphabet{C&lt;:ScalarCondition} &lt;: SoleLogics.AbstractAlphabet{C} end</code></pre><p>Abstract type for alphabets of conditions.</p><p>See also <a href="#SoleModels.ScalarCondition"><code>ScalarCondition</code></a>, <a href="#SoleModels.ScalarMetaCondition"><code>ScalarMetaCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/conditions.jl#L261-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.AbstractFeature" href="#SoleModels.AbstractFeature"><code>SoleModels.AbstractFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractFeature end</code></pre><p>Abstract type for features of worlds of [Kripke structures](https://en.wikipedia.org/wiki/Kripke<em>structure</em>(model_checking).</p><p>See also <a href="#SoleModels.VarFeature"><code>VarFeature</code></a>, <a href="#SoleModels.featvaltype-Tuple{Any, VarFeature}"><code>featvaltype</code></a>, <a href="../logic/#SoleLogics.AbstractWorld"><code>SoleLogics.AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/features.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.AbstractFullMemoset" href="#SoleModels.AbstractFullMemoset"><code>SoleModels.AbstractFullMemoset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for full memoization structures for checking generic formulas.</p><p>These structures can be stacked and coupled with <em>one-step</em> memoization structures (see <a href="#SoleModels.SupportedLogiset"><code>SupportedLogiset</code></a>).</p><p>See <a href="#SoleModels.AbstractOneStepMemoset"><code>AbstractOneStepMemoset</code></a>, <a href="#SoleModels.FullMemoset"><code>FullMemoset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/memosets.jl#L90-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.AbstractLogiset" href="#SoleModels.AbstractLogiset"><code>SoleModels.AbstractLogiset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractLogiset{
    W&lt;:AbstractWorld,
    U,
    FT&lt;:AbstractFeature,
    FR&lt;:AbstractFrame{W},
} &lt;: AbstractInterpretationSet{AbstractKripkeStructure} end</code></pre><p>Abstract type for logisets, that is, logical datasets for symbolic learning where each instance is a <a href="https://en.wikipedia.org/wiki/Kripke_structure_(model_checking)">Kripke structure</a> associating feature values to each world. Conditions (see <a href="#SoleModels.AbstractCondition"><code>AbstractCondition</code></a>), and logical formulas with conditional letters can be checked on worlds of instances of the dataset.</p><p>See also <a href="#SoleModels.AbstractCondition"><code>AbstractCondition</code></a>, <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>, <a href="../logic/#SoleLogics.AbstractKripkeStructure"><code>SoleLogics.AbstractKripkeStructure</code></a>, <a href="../logic/#SoleLogics.AbstractInterpretationSet"><code>SoleLogics.AbstractInterpretationSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/logiset.jl#L7-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.AbstractMemoset" href="#SoleModels.AbstractMemoset"><code>SoleModels.AbstractMemoset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractMemoset{
    W&lt;:AbstractWorld,
    U,
    FT&lt;:AbstractFeature,
    FR&lt;:AbstractFrame,
} &lt;: AbstractLogiset{W,U,FT,FR} end</code></pre><p>Abstract type for memoization structures to be used when checking formulas on logisets.</p><p>See also <a href="#SoleModels.FullMemoset"><code>FullMemoset</code></a>, <a href="#SoleModels.SupportedLogiset"><code>SupportedLogiset</code></a>, <a href="#SoleModels.AbstractLogiset"><code>AbstractLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/memosets.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.AbstractModel" href="#SoleModels.AbstractModel"><code>SoleModels.AbstractModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractModel{O} end</code></pre><p>Abstract type for mathematical models that, given an instance object (i.e., a piece of data), output an outcome of type <code>O</code>.</p><p>See also <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="#SoleModels.Branch"><code>Branch</code></a>, <a href="#Base.isopen-Tuple{SoleModels.AbstractModel}"><code>isopen</code></a>, <a href="#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>apply</code></a>, <a href="#SoleModels.issymbolic-Tuple{SoleModels.AbstractModel}"><code>issymbolic</code></a>, <a href="#SoleModels.info-Tuple{SoleModels.AbstractModel}"><code>info</code></a>, <a href="#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>outcometype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L15-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.AbstractOneStepMemoset" href="#SoleModels.AbstractOneStepMemoset"><code>SoleModels.AbstractOneStepMemoset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for one-step memoization structures for checking formulas of type <code>⟨R⟩p</code>; with these formulas, so-called &quot;one-step&quot; optimizations can be performed.</p><p>These structures can be stacked and coupled with <em>full</em> memoization structures (see <a href="#SoleModels.SupportedLogiset"><code>SupportedLogiset</code></a>).</p><p>See <a href="#SoleModels.ScalarOneStepMemoset"><code>ScalarOneStepMemoset</code></a>, <a href="#SoleModels.AbstractFullMemoset"><code>AbstractFullMemoset</code></a>, <a href="#SoleModels.representatives-Union{Tuple{W}, Tuple{SoleLogics.AbstractFrame{W}, W, AbstractRelation, SoleModels.AbstractCondition}} where W&lt;:AbstractWorld"><code>representatives</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/memosets.jl#L79-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.AbstractScalarOneStepGlobalMemoset" href="#SoleModels.AbstractScalarOneStepGlobalMemoset"><code>SoleModels.AbstractScalarOneStepGlobalMemoset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for one-step memoization structure for checking &quot;global&quot; formulas of type <code>⟨G⟩ (f ⋈ t)</code>.     We refer to these structures as <em>global memosets</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/onestep-memoset.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.AbstractScalarOneStepRelationalMemoset" href="#SoleModels.AbstractScalarOneStepRelationalMemoset"><code>SoleModels.AbstractScalarOneStepRelationalMemoset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for one-step memoization structures for checking formulas of type <code>⟨R⟩ (f ⋈ t)</code>, for a generic relation <code>R</code> that is not the global relation (<a href="../logic/#SoleLogics.globalrel"><code>SoleLogics.globalrel</code></a>). We refer to these structures as <em>relational memosets</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/onestep-memoset.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.AbstractUnivariateFeature" href="#SoleModels.AbstractUnivariateFeature"><code>SoleModels.AbstractUnivariateFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractUnivariateFeature &lt;: VarFeature end</code></pre><p>A dimensional feature represented by the application of a function to a single variable of a dimensional channel. For example, it can wrap a scalar function computing how much red a <code>Interval2D</code> world, when interpreted on an image, contains.</p><p>See also <a href="../logic/#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="../logic/#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleModels.UnivariateFeature"><code>UnivariateFeature</code></a>, <a href="#SoleModels.VarFeature"><code>VarFeature</code></a>, <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/var-features.jl#L93-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.Aggregator" href="#SoleModels.Aggregator"><code>SoleModels.Aggregator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const Aggregator = Function</code></pre><p>A test operator is a binary Julia <code>Function</code> used for comparing a feature value and a threshold. In a crisp (i.e., boolean, non-fuzzy) setting, the test operator returns a Boolean value, and <code>&lt;</code>, <code>&gt;</code>, <code>≥</code>, <code>≤</code>, <code>!=</code>, and <code>==</code> are typically used.</p><p>See also <a href="#SoleModels.ScalarCondition"><code>ScalarCondition</code></a>, <a href="#SoleModels.ScalarOneStepMemoset"><code>ScalarOneStepMemoset</code></a>, <a href="#SoleModels.TestOperator"><code>TestOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/test-operators.jl#L27-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.BoundedScalarConditions" href="#SoleModels.BoundedScalarConditions"><code>SoleModels.BoundedScalarConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BoundedScalarConditions{C&lt;:ScalarCondition} &lt;: AbstractConditionalAlphabet{C}
    grouped_featconditions::Vector{Tuple{&lt;:ScalarMetaCondition,Vector}}
end</code></pre><p>A finite alphabet of conditions, grouped by (a finite set of) metaconditions.</p><p>See also <a href="#SoleModels.UnboundedScalarConditions"><code>UnboundedScalarConditions</code></a>, <a href="#SoleModels.ScalarCondition"><code>ScalarCondition</code></a>, <a href="#SoleModels.ScalarMetaCondition"><code>ScalarMetaCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/conditions.jl#L314-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.Branch" href="#SoleModels.Branch"><code>SoleModels.Branch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Branch{
    O,
    A&lt;:Formula,
    FM&lt;:AbstractModel
} &lt;: ConstrainedModel{O,FM}
    antecedent::A
    posconsequent::FM
    negconsequent::FM
    info::NamedTuple
end</code></pre><p>A <code>Branch</code> is one of the fundamental building blocks of symbolic modeling, and has the semantics:</p><pre><code class="nohighlight hljs">IF (antecedent) THEN (positive consequent) ELSE (negative consequent) END</code></pre><p>where the antecedent is a formula to be checked and the consequents are the feasible local outcomes of the block. If checking the antecedent evaluates to the top of the algebra, then the positive consequent is applied; otherwise, the negative consequenti is applied.</p><p>Note that <code>FM</code> refers to the Feasible Models (<code>FM</code>) allowed in the model&#39;s sub-tree.</p><p>See also <a href="#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="#SoleModels.posconsequent-Tuple{Branch}"><code>posconsequent</code></a>, <a href="#SoleModels.negconsequent-Tuple{Branch}"><code>negconsequent</code></a>, <a href="../logic/#SoleLogics.check"><code>SoleLogics.check</code></a>, <a href="../logic/#SoleLogics.Formula"><code>SoleLogics.Formula</code></a>, <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L665-L697">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ConstantModel" href="#SoleModels.ConstantModel"><code>SoleModels.ConstantModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConstantModel{O} &lt;: LeafModel{O}
    outcome::O
    info::NamedTuple
end</code></pre><p>The simplest type of model is the <code>ConstantModel</code>; it is a <code>LeafModel</code> that always outputs the same outcome.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleModels.LeafModel(2) isa SoleModels.ConstantModel

julia&gt; SoleModels.LeafModel(sum) isa SoleModels.FunctionModel
┌ Warning: Over efficiency concerns, please consider wrappingJulia Function&#39;s into FunctionWrapper{O,Tuple{SoleModels.AbstractInterpretation}} structures,where O is their return type.
└ @ SoleModels ~/.julia/dev/SoleModels/src/models/base.jl:337
true
</code></pre><p>See also <a href="#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>apply</code></a>, <a href="#SoleModels.FunctionModel"><code>FunctionModel</code></a>, <a href="#SoleModels.LeafModel"><code>LeafModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L212-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ConstrainedModel" href="#SoleModels.ConstrainedModel"><code>SoleModels.ConstrainedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <code>AbstractModel</code> can wrap another <code>AbstractModel</code>, and use it to compute the outcome. As such, an <code>AbstractModel</code> can actually be the result of a composition of many models, and enclose a <em>tree</em> of <code>AbstractModel</code>s (with <code>LeafModel</code>s at the leaves). In order to typebound the Feasible Models (<code>FM</code>) allowed in the sub-tree, the <code>ConstrainedModel</code> type is introduced:</p><pre><code class="nohighlight hljs">abstract type ConstrainedModel{O,FM&lt;:AbstractModel} &lt;: AbstractModel{O} end</code></pre><p>For example, <code>ConstrainedModel{String,Union{Branch{String},ConstantModel{String}}}</code> supertypes models that with <code>String</code> outcomes that make use of <code>Branch{String}</code> and <code>ConstantModel{String}</code> (essentially, a decision trees with <code>String</code>s at the leaves).</p><p>See also <a href="#SoleModels.LeafModel"><code>LeafModel</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L393-L407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.DecisionForest" href="#SoleModels.DecisionForest"><code>SoleModels.DecisionForest</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Decision Forest</code> is a symbolic model that wraps an ensemble of models</p><pre><code class="nohighlight hljs">struct DecisionForest{
    O,
    A&lt;:Formula,
    FFM&lt;:LeafModel
} &lt;: ConstrainedModel{O,Union{&lt;:Branch{&lt;:O,&lt;:A},&lt;:FFM}}
    trees::Vector{&lt;:DecisionTree}
    info::NamedTuple
end</code></pre><p>See also <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.MixedSymbolicModel"><code>MixedSymbolicModel</code></a>, <a href="#SoleModels.DecisionList"><code>DecisionList</code></a>, <a href="#SoleModels.DecisionTree"><code>DecisionTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L1178-L1193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.DecisionList" href="#SoleModels.DecisionList"><code>SoleModels.DecisionList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DecisionList{
    O,
    A&lt;:Formula,
    FM&lt;:AbstractModel
} &lt;: ConstrainedModel{O,FM}
    rulebase::Vector{Rule{_O,_C,_FM} where {_O&lt;:O,_C&lt;:A,_FM&lt;:FM}}
    defaultconsequent::FM
    info::NamedTuple
end</code></pre><p>A <code>DecisionList</code> (or <em>decision table</em>, or <em>rule-based model</em>) is a symbolic model that has the semantics of an IF-ELSEIF-ELSE block:</p><pre><code class="nohighlight hljs">IF (antecedent_1)     THEN (consequent_1)
ELSEIF (antecedent_2) THEN (consequent_2)
...
ELSEIF (antecedent_n) THEN (consequent_n)
ELSE (consequent_default) END</code></pre><p>where the antecedents are formulas to be, and the consequents are the feasible local outcomes of the block. Using the classical semantics, the antecedents are evaluated in order, and a consequent is returned as soon as a valid antecedent is found, or when the computation reaches the ELSE clause.</p><p>Note that <code>FM</code> refers to the Feasible Models (<code>FM</code>) allowed in the model&#39;s sub-tree.</p><p>See also <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.DecisionTree"><code>DecisionTree</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L867-L900">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.DecisionTree" href="#SoleModels.DecisionTree"><code>SoleModels.DecisionTree</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>DecisionTree</code> is a symbolic model that operates as a nested structure of IF-THEN-ELSE blocks:</p><pre><code class="nohighlight hljs">IF (antecedent_1) THEN
    IF (antecedent_2) THEN
        (consequent_1)
    ELSE
        (consequent_2)
    END
ELSE
    IF (antecedent_3) THEN
        (consequent_3)
    ELSE
        (consequent_4)
    END
END</code></pre><p>where the antecedents are formulas to be, and the consequents are the feasible local outcomes of the block.</p><p>In practice, a <code>DecisionTree</code> simply wraps a constrained sub-tree of <code>Branch</code> and <code>LeafModel</code>:</p><pre><code class="nohighlight hljs">struct DecisionTree{
O,
    A&lt;:Formula,
    FFM&lt;:LeafModel
} &lt;: ConstrainedModel{O,Union{&lt;:Branch{&lt;:O,&lt;:A},&lt;:FFM}}
    root::M where {M&lt;:Union{FFM,Branch}}
    info::NamedTuple
end</code></pre><p>Note that <code>FM</code> refers to the Feasible Models (<code>FM</code>) allowed in the model&#39;s sub-tree. Also note that this structure also includes an <code>info::NamedTuple</code> for storing additional information.</p><p>See also <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.MixedSymbolicModel"><code>MixedSymbolicModel</code></a>, <a href="#SoleModels.DecisionList"><code>DecisionList</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L1061-L1099">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ExistentialTopFormula" href="#SoleModels.ExistentialTopFormula"><code>SoleModels.ExistentialTopFormula</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Templated formula for ⟨R⟩⊤.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/templated-formulas.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ExplicitBooleanLogiset" href="#SoleModels.ExplicitBooleanLogiset"><code>SoleModels.ExplicitBooleanLogiset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExplicitBooleanLogiset{
    W&lt;:AbstractWorld,
    FT&lt;:AbstractFeature,
    FR&lt;:AbstractFrame{W},
} &lt;: AbstractLogiset{W,Bool,FT,FR}

    d :: Vector{Tuple{Dict{W,Vector{FT}},FR}}

end</code></pre><p>A logiset where the features are boolean, and where each instance associates to each world the set of features with <code>true</code>.</p><p>See also <a href="#SoleModels.AbstractLogiset"><code>AbstractLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/logiset.jl#L187-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ExplicitFeature" href="#SoleModels.ExplicitFeature"><code>SoleModels.ExplicitFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExplicitFeature{T} &lt;: AbstractFeature
    name::String
    featstruct
end</code></pre><p>A feature encoded explicitly, for example, as a slice of <a href="#SoleModels.DimensionalDatasets.UniformFullDimensionalLogiset"><code>DimensionalDatasets.UniformFullDimensionalLogiset</code></a>&#39;s feature structure.</p><p>See also <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/features.jl#L91-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ExplicitLogiset" href="#SoleModels.ExplicitLogiset"><code>SoleModels.ExplicitLogiset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExplicitLogiset{
    W&lt;:AbstractWorld,
    U,
    FT&lt;:AbstractFeature,
    FR&lt;:AbstractFrame{W},
} &lt;: AbstractLogiset{W,U,FT,FR}

    d :: Vector{Tuple{Dict{W,Dict{FT,U}},FR}}

end</code></pre><p>A logiset where the features are boolean, and where each instance associates to each world the set of features with <code>true</code>.</p><p>See also <a href="#SoleModels.AbstractLogiset"><code>AbstractLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/logiset.jl#L324-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.Feature" href="#SoleModels.Feature"><code>SoleModels.Feature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Feature{A} &lt;: AbstractFeature
    atom::A
end</code></pre><p>A feature solely identified by an atom (e.g., a string with its name, a tuple of strings, etc.)</p><p>See also <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/features.jl#L58-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.FullMemoset" href="#SoleModels.FullMemoset"><code>SoleModels.FullMemoset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A generic, full memoization structure that works for any <em>crisp</em> logic; For each instance of a dataset, this structure associates formulas to the set of worlds where the formula holds; it was introduced by Emerson-Clarke for the well-known model checking algorithm for CTL*.</p><p>See also <a href="#SoleModels.SupportedLogiset"><code>SupportedLogiset</code></a>, <a href="#SoleModels.AbstractMemoset"><code>AbstractMemoset</code></a>, <a href="#SoleModels.AbstractLogiset"><code>AbstractLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/memosets.jl#L104-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.FunctionModel" href="#SoleModels.FunctionModel"><code>SoleModels.FunctionModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FunctionModel{O} &lt;: LeafModel{O}
    f::FunctionWrapper{O}
    info::NamedTuple
end</code></pre><p>A <code>FunctionModel</code> is a <code>LeafModel</code> that applies a native Julia <code>Function</code> in order to compute the outcome. Over efficiency concerns, it is mandatory to make explicit the output type <code>O</code> by wrapping the <code>Function</code> into an object of type <code>FunctionWrapper{O}</code> (see <a href="https://github.com/yuyichao/FunctionWrappers.jl">FunctionWrappers</a>.</p><p>See also <a href="#SoleModels.ConstantModel"><code>ConstantModel</code></a>, <a href="#SoleModels.LeafModel"><code>LeafModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L274-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.FunctionalCondition" href="#SoleModels.FunctionalCondition"><code>SoleModels.FunctionalCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FunctionalCondition{FT&lt;:AbstractFeature} &lt;: AbstractCondition{FT}
    feature::FT
    f::FT
end</code></pre><p>A condition which yields a truth value equal to the value of a function.</p><p>See also <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/conditions.jl#L117-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.LeafModel" href="#SoleModels.LeafModel"><code>SoleModels.LeafModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type LeafModel{O} &lt;: AbstractModel{O} end</code></pre><p>Abstract type for leaf models, that is, models which outcomes do not depend other models, and represents the bottom of the computation. In general, an <code>AbstractModel</code> can generally wrap other <code>AbstractModel</code>s; in such case, the outcome can depend on the inner models being applied on the instance object. Otherwise, the model is considered as a <em>leaf</em>, or <em>final</em>, and is the <em>leaf</em> of a tree of <code>AbstractModel</code>s.</p><p>See also <a href="#SoleModels.ConstantModel"><code>ConstantModel</code></a>, <a href="#SoleModels.FunctionModel"><code>FunctionModel</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L198-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.MixedSymbolicModel" href="#SoleModels.MixedSymbolicModel"><code>SoleModels.MixedSymbolicModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>MixedSymbolicModel</code> is a symbolic model that operaters as a free nested structure of IF-THEN-ELSE and IF-ELSEIF-ELSE blocks:</p><pre><code class="nohighlight hljs">IF (antecedent_1) THEN
    IF (antecedent_1)     THEN (consequent_1)
    ELSEIF (antecedent_2) THEN (consequent_2)
    ELSE (consequent_1_default) END
ELSE
    IF (antecedent_3) THEN
        (consequent_3)
    ELSE
        (consequent_4)
    END
END</code></pre><p>where the antecedents are formulas to be checked, and the consequents are the feasible local outcomes of the block.</p><p>In Sole.jl, this logic can implemented using <code>ConstrainedModel</code>s such as <code>Rule</code>s, <code>Branch</code>s, <code>DecisionList</code>s, <code>DecisionTree</code>s, and the be wrapped into a <code>MixedSymbolicModel</code>:</p><pre><code class="nohighlight hljs">struct MixedSymbolicModel{O,FM&lt;:AbstractModel} &lt;: ConstrainedModel{O,FM}
    root::M where {M&lt;:Union{LeafModel{&lt;:O},ConstrainedModel{&lt;:O,&lt;:FM}}}
    info::NamedTuple
end</code></pre><p>Note that <code>FM</code> refers to the Feasible Models (<code>FM</code>) allowed in the model&#39;s sub-tree.</p><p>See also <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.DecisionTree"><code>DecisionTree</code></a>, <a href="#SoleModels.DecisionList"><code>DecisionList</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L1256-L1287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.MultiFormula" href="#SoleModels.MultiFormula"><code>SoleModels.MultiFormula</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MultiFormula{F&lt;:Formula} &lt;: AbstractSyntaxStructure
    modforms::Dict{Int,F}
end</code></pre><p>A symbolic antecedent that can be checked on a <code>MultiLogiset</code>, associating antecedents to modalities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/multilogiset.jl#L195-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.MultiLogiset" href="#SoleModels.MultiLogiset"><code>SoleModels.MultiLogiset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MultiLogiset{L&lt;:AbstractLogiset}
    modalities  :: Vector{L}
end</code></pre><p>A logical dataset composed of different <a href="https://en.wikipedia.org/wiki/Multimodal_learning">modalities</a>); this structure is useful for representing multimodal datasets in logical terms.</p><p>See also <a href="#SoleModels.AbstractLogiset"><code>AbstractLogiset</code></a>, <a href="#SoleModels.minify-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Union{Missing, Nothing, Real}"><code>minify</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/multilogiset.jl#L7-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.MultivariateFeature" href="#SoleModels.MultivariateFeature"><code>SoleModels.MultivariateFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MultivariateFeature{U} &lt;: VarFeature
    f::Function
end</code></pre><p>A dimensional feature represented by the application of a function to a dimensional channel. For example, it can wrap a scalar function computing how much a <code>Interval2D</code> world, when interpreted on an image, resembles a horse. Note that the image has a number of spatial variables (3, for the case of RGB), and &quot;resembling a horse&quot; may require a computation involving all variables.</p><p>See also <a href="../logic/#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="../logic/#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleModels.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleModels.VarFeature"><code>VarFeature</code></a>, <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/var-features.jl#L66-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.RLabel" href="#SoleModels.RLabel"><code>SoleModels.RLabel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const CLabel  = Union{String,Integer,CategoricalValue}
const RLabel  = AbstractFloat
const Label   = Union{CLabel,RLabel}</code></pre><p>Types for supervised machine learning labels (classification and regression).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/machine-learning.jl#L14-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.Rule" href="#SoleModels.Rule"><code>SoleModels.Rule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Rule{
    O,
    A&lt;:Formula,
    FM&lt;:AbstractModel
} &lt;: ConstrainedModel{O,FM}
    antecedent::A
    consequent::FM
    info::NamedTuple
end</code></pre><p>A <code>Rule</code> is one of the fundamental building blocks of symbolic modeling, and has the semantics:</p><pre><code class="nohighlight hljs">IF (antecedent) THEN (consequent) END</code></pre><p>where the antecedent is a formula to be checked, and the consequent is the local outcome of the block.</p><p>Note that <code>FM</code> refers to the Feasible Models (<code>FM</code>) allowed in the model&#39;s sub-tree.</p><p>See also <a href="#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="#SoleModels.consequent-Tuple{Rule}"><code>consequent</code></a>, <a href="../logic/#SoleLogics.Formula"><code>SoleLogics.Formula</code></a>, <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L483-L510">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ScalarChainedMemoset" href="#SoleModels.ScalarChainedMemoset"><code>SoleModels.ScalarChainedMemoset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A full memoization structure used for checking formulas of scalar conditions on datasets with scalar features. This structure is the equivalent to <a href="#SoleModels.FullMemoset"><code>FullMemoset</code></a>, but with scalar features some important optimizations can be done.</p><p>See also <a href="#SoleModels.FullMemoset"><code>FullMemoset</code></a>, <a href="#SoleModels.SupportedLogiset"><code>SupportedLogiset</code></a>, <a href="#SoleModels.AbstractLogiset"><code>AbstractLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/memosets.jl#L23-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ScalarCondition" href="#SoleModels.ScalarCondition"><code>SoleModels.ScalarCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ScalarCondition{U,FT,M&lt;:ScalarMetaCondition{FT}} &lt;: AbstractCondition{FT}
    metacond::M
    a::U
end</code></pre><p>A scalar condition comparing a computed feature value (see <code>ScalarMetaCondition</code>) and a threshold value <code>a</code>. It can be evaluated on a world of an instance of a logical dataset.</p><p>For example: <span>$min[V1] ≥ 10$</span>, which translates to &quot;Within this world, the minimum of variable 1 is greater or equal than 10.&quot; In this case, the feature a <a href="#SoleModels.UnivariateMin"><code>UnivariateMin</code></a> object.</p><p>See also <a href="#SoleModels.AbstractCondition"><code>AbstractCondition</code></a>, <a href="#SoleModels.ScalarMetaCondition"><code>ScalarMetaCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/conditions.jl#L98-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ScalarExistentialFormula" href="#SoleModels.ScalarExistentialFormula"><code>SoleModels.ScalarExistentialFormula</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Templated formula for ⟨R⟩ f ⋈ t.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/templated-formulas.jl#L40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ScalarFormula" href="#SoleModels.ScalarFormula"><code>SoleModels.ScalarFormula</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for templated formulas on scalar conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/templated-formulas.jl#L7-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ScalarMetaCondition" href="#SoleModels.ScalarMetaCondition"><code>SoleModels.ScalarMetaCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ScalarMetaCondition{FT&lt;:AbstractFeature,O&lt;:TestOperator} &lt;: AbstractCondition{FT}
    feature::FT
    test_operator::O
end</code></pre><p>A metacondition representing a scalar comparison method. Here, the <code>feature</code> is a scalar function that can be computed on a world of an instance of a logical dataset. A test operator is a binary mathematical relation, comparing the computed feature value and an external threshold value (see <code>ScalarCondition</code>). A metacondition can also be used for representing the infinite set of conditions that arise with a free threshold (see <code>UnboundedScalarConditions</code>): <span>${min[V1] ≥ a, a ∈ ℝ}$</span>.</p><p>See also <a href="#SoleModels.AbstractCondition"><code>AbstractCondition</code></a>, <a href="#SoleModels.ScalarCondition"><code>ScalarCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/conditions.jl#L6-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ScalarOneStepMemoset" href="#SoleModels.ScalarOneStepMemoset"><code>SoleModels.ScalarOneStepMemoset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>One-step memoization structures for optimized check of formulas of type <code>⟨R⟩p</code>, where <code>p</code> wraps a scalar condition, such as <code>MyFeature ≥ 10</code>. With such formulas, scalar one-step optimization can be performed.</p><p>For example, checking <code>⟨R⟩(MyFeature ≥ 10)</code> on a world <code>w</code> of a Kripke structure involves comparing the <em>maximum</em> MyFeature across <code>w</code>s accessible worlds with 10; but the same <em>maximum</em> value can be reused to check <em>sibling formulas</em> such as <code>⟨R⟩(MyFeature ≥ 100)</code>. This sparks the idea of storing and reusing scalar aggregations (e.g., minimum/maximum) over the feature values. Each value refers to a specific world, and an object of type <code>⟨R⟩(f ⋈ ?)</code>, called a &quot;scalar <em>metacondition</em>&quot;.</p><p>Similar cases arise depending on the relation and the test operator (or, better, its <em>aggregator</em>), and further optimizations can be applied for specific feature types (see <a href="#SoleModels.representatives-Union{Tuple{W}, Tuple{SoleLogics.AbstractFrame{W}, W, AbstractRelation, SoleModels.AbstractCondition}} where W&lt;:AbstractWorld"><code>representatives</code></a>).</p><p>An immediate special case, however, arises when <code>R</code> is the global relation <code>G</code> since, in such case, a single aggregate value is enough for all worlds within the Kripke structure. Therefore, we differentiate between generic, <em>relational</em> memosets (see <a href="#SoleModels.AbstractScalarOneStepRelationalMemoset"><code>AbstractScalarOneStepRelationalMemoset</code></a>), and <em>global</em> memosets (see <a href="#SoleModels.AbstractScalarOneStepGlobalMemoset"><code>AbstractScalarOneStepGlobalMemoset</code></a>), which are usually much smaller.</p><p>Given a logiset <code>X</code>, a <code>ScalarOneStepMemoset</code> covers a set of <code>relations</code> and <code>metaconditions</code>, and it holds both a <em>relational</em> and a <em>global</em> memoset. It can be instantiated via:</p><pre><code class="language-julia hljs">ScalarOneStepMemoset(
    X                       :: AbstractLogiset{W,U},
    metaconditions          :: AbstractVector{&lt;:ScalarMetaCondition},
    relations               :: AbstractVector{&lt;:AbstractRelation};
    precompute_globmemoset  :: Bool = true,
    precompute_relmemoset   :: Bool = false,
    print_progress          :: Bool = false,
)</code></pre><p>If <code>precompute_relmemoset</code> is <code>false</code>, then the relational memoset is simply initialized as an empty structure, and memoization is performed on it upon checking formulas. <code>precompute_globmemoset</code> works similarly.</p><p>See <a href="#SoleModels.SupportedLogiset"><code>SupportedLogiset</code></a>, <a href="#SoleModels.ScalarMetaCondition"><code>ScalarMetaCondition</code></a>, <a href="#SoleModels.AbstractOneStepMemoset"><code>AbstractOneStepMemoset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/onestep-memoset.jl#L176-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ScalarOneStepRelationalMemoset" href="#SoleModels.ScalarOneStepRelationalMemoset"><code>SoleModels.ScalarOneStepRelationalMemoset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A generic, one-step memoization structure used for checking specific formulas of scalar conditions on datasets with scalar features. The formulas are of type ⟨R⟩ (f ⋈ t)</p><p>See also <a href="#SoleModels.AbstractScalarOneStepRelationalMemoset"><code>AbstractScalarOneStepRelationalMemoset</code></a>, <a href="#SoleModels.FullMemoset"><code>FullMemoset</code></a>, <a href="#SoleModels.SupportedLogiset"><code>SupportedLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/onestep-memoset.jl#L596-L605">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ScalarPropositionFormula" href="#SoleModels.ScalarPropositionFormula"><code>SoleModels.ScalarPropositionFormula</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Templated formula for f ⋈ t.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/templated-formulas.jl#L12-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ScalarUniversalFormula" href="#SoleModels.ScalarUniversalFormula"><code>SoleModels.ScalarUniversalFormula</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Templated formula for [R] f ⋈ t.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/templated-formulas.jl#L98-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.SupportedLogiset" href="#SoleModels.SupportedLogiset"><code>SoleModels.SupportedLogiset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A logiset, associated to a number of cascading full or one-step memoization structures, that are used for optimizing the checking of formulas.</p><p>See also <a href="#SoleModels.SupportedLogiset"><code>SupportedLogiset</code></a>, <a href="#SoleModels.AbstractFullMemoset"><code>AbstractFullMemoset</code></a>, <a href="#SoleModels.AbstractOneStepMemoset"><code>AbstractOneStepMemoset</code></a>, <a href="#SoleModels.AbstractLogiset"><code>AbstractLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/supported-logiset.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.TestOperator" href="#SoleModels.TestOperator"><code>SoleModels.TestOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const TestOperator = Function</code></pre><p>A test operator is a binary Julia <code>Function</code> used for comparing a feature value and a threshold. In a crisp (i.e., boolean, non-fuzzy) setting, the test operator returns a Boolean value, and <code>&lt;</code>, <code>&gt;</code>, <code>≥</code>, <code>≤</code>, <code>!=</code>, and <code>==</code> are typically used.</p><p>See also <a href="#SoleModels.Aggregator"><code>Aggregator</code></a>, <a href="#SoleModels.ScalarCondition"><code>ScalarCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/test-operators.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.UnboundedScalarConditions" href="#SoleModels.UnboundedScalarConditions"><code>SoleModels.UnboundedScalarConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UnboundedScalarConditions{C&lt;:ScalarCondition} &lt;: AbstractConditionalAlphabet{C}
    metaconditions::Vector{&lt;:ScalarMetaCondition}
end</code></pre><p>An infinite alphabet of conditions induced from a finite set of metaconditions. For example, if <code>metaconditions = [ScalarMetaCondition(UnivariateMin(1), ≥)]</code>, the alphabet represents the (infinite) set: <span>${min[V1] ≥ a, a ∈ ℝ}$</span>.</p><p>See also <a href="#SoleModels.BoundedScalarConditions"><code>BoundedScalarConditions</code></a>, <a href="#SoleModels.ScalarCondition"><code>ScalarCondition</code></a>, <a href="#SoleModels.ScalarMetaCondition"><code>ScalarMetaCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/conditions.jl#L272-L285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.UnivariateFeature" href="#SoleModels.UnivariateFeature"><code>SoleModels.UnivariateFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UnivariateFeature{U} &lt;: AbstractUnivariateFeature
    i_variable::Integer
    f::Function
end</code></pre><p>A dimensional feature represented by the application of a generic function <code>f</code> to a single variable of a dimensional channel. For example, it can wrap a scalar function computing how much red a <code>Interval2D</code> world, when interpreted on an image, contains.</p><p>See also <a href="../logic/#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="../logic/#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleModels.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleModels.VarFeature"><code>VarFeature</code></a>, <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/var-features.jl#L178-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.UnivariateMax" href="#SoleModels.UnivariateMax"><code>SoleModels.UnivariateMax</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UnivariateMax &lt;: AbstractUnivariateFeature
    i_variable::Integer
end</code></pre><p>Notable univariate feature computing the maximum value for a given variable.</p><p>See also <a href="../logic/#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="../logic/#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleModels.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleModels.UnivariateMin"><code>UnivariateMin</code></a>, <a href="#SoleModels.VarFeature"><code>VarFeature</code></a>, <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/var-features.jl#L314-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.UnivariateMin" href="#SoleModels.UnivariateMin"><code>SoleModels.UnivariateMin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UnivariateMin &lt;: AbstractUnivariateFeature
    i_variable::Integer
end</code></pre><p>Notable univariate feature computing the minimum value for a given variable.</p><p>See also <a href="../logic/#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="../logic/#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleModels.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleModels.UnivariateMax"><code>UnivariateMax</code></a>, <a href="#SoleModels.VarFeature"><code>VarFeature</code></a>, <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/var-features.jl#L286-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.UnivariateNamedFeature" href="#SoleModels.UnivariateNamedFeature"><code>SoleModels.UnivariateNamedFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UnivariateNamedFeature{U} &lt;: AbstractUnivariateFeature
    i_variable::Integer
    name::String
end</code></pre><p>A univariate feature solely identified by its name and reference variable.</p><p>See also <a href="../logic/#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="../logic/#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleModels.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleModels.VarFeature"><code>VarFeature</code></a>, <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/var-features.jl#L214-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.UnivariateSoftMax" href="#SoleModels.UnivariateSoftMax"><code>SoleModels.UnivariateSoftMax</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UnivariateSoftMax{T&lt;:AbstractFloat} &lt;: AbstractUnivariateFeature
    i_variable::Integer
    alpha::T
end</code></pre><p>Univariate feature computing a &quot;softened&quot; version of the maximum value for a given variable.</p><p>See also <a href="../logic/#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="../logic/#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleModels.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleModels.UnivariateMax"><code>UnivariateMax</code></a>, <a href="#SoleModels.VarFeature"><code>VarFeature</code></a>, <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/var-features.jl#L377-L390">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.UnivariateSoftMin" href="#SoleModels.UnivariateSoftMin"><code>SoleModels.UnivariateSoftMin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UnivariateSoftMin{T&lt;:AbstractFloat} &lt;: AbstractUnivariateFeature
    i_variable::Integer
    alpha::T
end</code></pre><p>Univariate feature computing a &quot;softened&quot; version of the minimum value for a given variable.</p><p>See also <a href="../logic/#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="../logic/#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleModels.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleModels.UnivariateMin"><code>UnivariateMin</code></a>, <a href="#SoleModels.VarFeature"><code>VarFeature</code></a>, <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/var-features.jl#L344-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.UnivariateValue" href="#SoleModels.UnivariateValue"><code>SoleModels.UnivariateValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UnivariateValue &lt;: AbstractUnivariateFeature
    i_variable::Integer
end</code></pre><p>Simply the value of a scalar variable (propositional case, when the frame has a single world).</p><p>See also <a href="../logic/#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="../logic/#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleModels.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleModels.UnivariateMax"><code>UnivariateMax</code></a>, <a href="#SoleModels.VarFeature"><code>VarFeature</code></a>, <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/var-features.jl#L248-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.UniversalBotFormula" href="#SoleModels.UniversalBotFormula"><code>SoleModels.UniversalBotFormula</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Templated formula for [R]⊥.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/templated-formulas.jl#L12-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ValueCondition" href="#SoleModels.ValueCondition"><code>SoleModels.ValueCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ValueCondition{FT&lt;:AbstractFeature} &lt;: AbstractCondition{FT}
    feature::FT
end</code></pre><p>A condition which yields a truth value equal to the value of a feature.</p><p>See also <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/conditions.jl#L78-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.VarFeature" href="#SoleModels.VarFeature"><code>SoleModels.VarFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type VarFeature &lt;: AbstractFeature end</code></pre><p>Abstract type for feature functions that can be computed on (multi)variate data. Instances of multivariate datasets have values for a number of <em>variables</em>, which can be used to define logical features.</p><p>For example, with dimensional data (e.g., multivariate time series, digital images and videos), features can be computed as the minimum value for a given variable on a specific interval/rectangle/cuboid (in general, a <a href="@ref">`SoleLogics.GeometricalWorld</a>).</p><p>As an example of a dimensional feature, consider <em>min[V1]</em>, which computes the minimum for variable 1 for a given world. <code>ScalarCondition</code>s such as <em>min[V1] &gt;= 10</em> can be, then, evaluated on worlds.</p><p>See also <a href="#SoleModels.scalarlogiset"><code>scalarlogiset</code></a>, <a href="#SoleModels.featvaltype-Tuple{Any, VarFeature}"><code>featvaltype</code></a>, <a href="#SoleModels.computefeature-Tuple{VarFeature, Any}"><code>computefeature</code></a>, <a href="../logic/#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/var-features.jl#L14-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isopen-Tuple{SoleModels.AbstractModel}" href="#Base.isopen-Tuple{SoleModels.AbstractModel}"><code>Base.isopen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isopen(::AbstractModel)::Bool</code></pre><p>Return whether a model is open. An <code>AbstractModel{O}</code> is <em>closed</em> if it is always able to provide an outcome of type <code>O</code>. Otherwise, the model can output <code>nothing</code> values and is referred to as <em>open</em>.</p><p><a href="#SoleModels.Rule"><code>Rule</code></a> is an example of an <em>open</em> model, while <a href="#SoleModels.Branch"><code>Branch</code></a> is an example of <em>closed</em> model.</p><p>See also <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L49-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{Random.AbstractRNG, SoleModels.BoundedScalarConditions}" href="#Base.rand-Tuple{Random.AbstractRNG, SoleModels.BoundedScalarConditions}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.rand(
    rng::AbstractRNG,
    a::BoundedScalarConditions;
    metaconditions::Union{Nothing,ScalarMetaCondition,AbstractVector{&lt;:ScalarMetaCondition}} = nothing,
    feature::Union{Nothing,AbstractFeature,AbstractVector{&lt;:AbstractFeature}} = nothing,
    test_operator::Union{Nothing,TestOperator,AbstractVector{&lt;:TestOperator}} = nothing,
)::Atom</code></pre><p>Randomly sample an <code>Atom</code> holding a <code>ScalarCondition</code> from conditional alphabet <code>a</code>, such that:</p><ul><li>if <code>metaconditions</code> are specified, then the set of metaconditions (feature-operator pairs)</li></ul><p>is limited to <code>metaconditions</code>;</p><ul><li>if <code>feature</code> is specified, then the set of metaconditions (feature-operator pairs)</li></ul><p>is limited to those with <code>feature</code>;</p><ul><li>if <code>test_operator</code> is specified, then the set of metaconditions (feature-operator pairs)</li></ul><p>is limited to those with <code>test_operator</code>.</p><p>See also <a href="#SoleModels.BoundedScalarConditions"><code>BoundedScalarConditions</code></a>, <a href="#SoleModels.ScalarCondition"><code>ScalarCondition</code></a>, <a href="#SoleModels.ScalarMetaCondition"><code>ScalarMetaCondition</code></a>, <a href="../logic/#SoleLogics.AbstractAlphabet"><code>SoleLogics.AbstractAlphabet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/random.jl#L4-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.antecedent-Tuple{Rule}" href="#SoleModels.antecedent-Tuple{Rule}"><code>SoleModels.antecedent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">antecedent(m::Union{Rule,Branch})::Formula</code></pre><p>Return the antecedent of a rule/branch, that is, the formula to be checked upon applying the model.</p><p>See also <a href="#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>apply</code></a>, <a href="#SoleModels.consequent-Tuple{Rule}"><code>consequent</code></a>, <a href="#SoleModels.checkantecedent"><code>checkantecedent</code></a>, <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="#SoleModels.Branch"><code>Branch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L553-L565">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}" href="#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>SoleModels.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply(
    m::AbstractModel,
    i::AbstractInterpretation;
    check_args::Tuple = (),
    check_kwargs::NamedTuple = (;),
    functional_args::Tuple = (),
    functional_kwargs::NamedTuple = (;),
    kwargs...
)::outputtype(m)

apply(
    m::AbstractModel,
    d::AbstractInterpretationSet;
    check_args::Tuple = (),
    check_kwargs::NamedTuple = (;),
    functional_args::Tuple = (),
    functional_kwargs::NamedTuple = (;),
    kwargs...
)::AbstractVector{&lt;:outputtype(m)}</code></pre><p>Return the output prediction of the model on an instance, or on each instance of a dataset. The predictions can be <code>nothing</code> if the model is <em>open</em>.</p><p><code>check_args</code> and <code>check_kwargs</code> can influence check&#39;s behavior at the time of its computation (see <a href="@ref">`SoleLogics.check</a>)</p><p><code>functional_args</code> and <code>functional_kwargs</code> can influence FunctionModel&#39;s behavior when the corresponding function is applied to AbstractInterpretation (see <a href="#SoleModels.FunctionModel"><code>FunctionModel</code></a>, <a href="@ref">`SoleLogics.AbstractInterpretation</a>)</p><p>See also <a href="#Base.isopen-Tuple{SoleModels.AbstractModel}"><code>isopen</code></a>, <a href="#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>outcometype</code></a>, <a href="#SoleModels.outputtype-Tuple{SoleModels.AbstractModel}"><code>outputtype</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>, <a href="../logic/#SoleLogics.AbstractInterpretation"><code>SoleLogics.AbstractInterpretation</code></a>, <a href="../logic/#SoleLogics.AbstractInterpretationSet"><code>SoleLogics.AbstractInterpretationSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L81-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.apply_test_operator-Union{Tuple{T2}, Tuple{T1}, Tuple{Function, T1, T2}} where {T1, T2}" href="#SoleModels.apply_test_operator-Union{Tuple{T2}, Tuple{T1}, Tuple{Function, T1, T2}} where {T1, T2}"><code>SoleModels.apply_test_operator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a test operator by simply passing the feature value and threshold to the (binary) test operator function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/test-operators.jl#L15-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.balanced_weights-Union{Tuple{AbstractVector{L}}, Tuple{L}} where L&lt;:Union{Integer, String, CategoricalArrays.CategoricalValue}" href="#SoleModels.balanced_weights-Union{Tuple{AbstractVector{L}}, Tuple{L}} where L&lt;:Union{Integer, String, CategoricalArrays.CategoricalValue}"><code>SoleModels.balanced_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_weights(Y::AbstractVector{L}) where {L&lt;:CLabel}::AbstractVector{&lt;:Number}</code></pre><p>Return a class-rebalancing weight vector, given a label vector <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/machine-learning.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.bestguess" href="#SoleModels.bestguess"><code>SoleModels.bestguess</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bestguess(
    labels::AbstractVector{&lt;:Label},
    weights::Union{Nothing,AbstractVector} = nothing;
    suppress_parity_warning = false,
)</code></pre><p>Return the best guess for a set of labels; that is, the label that best approximates the labels provided. For classification labels, this function returns the majority class; for regression labels, the average value. If no labels are provided, <code>nothing</code> is returned. The computation can be weighted.</p><p>See also <a href="#SoleModels.CLabel"><code>CLabel</code></a>, <a href="#SoleModels.RLabel"><code>RLabel</code></a>, <a href="#SoleModels.Label"><code>Label</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/machine-learning.jl#L48-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.check_model_constraints" href="#SoleModels.check_model_constraints"><code>SoleModels.check_model_constraints</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This function is used when constructing <code>ConstrainedModel</code>s to check that the inner models satisfy the desired type constraints.</p><p>See also <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="#SoleModels.Branch"><code>Branch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L442-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.checkantecedent" href="#SoleModels.checkantecedent"><code>SoleModels.checkantecedent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">checkantecedent(
    m::Union{Rule,Branch},
    args...;
    kwargs...
)
    check(antecedent(m), args...; kwargs...)
end</code></pre><p>Simply check the antecedent of a rule on an instance or dataset.</p><p>See also <a href="#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="#SoleModels.Branch"><code>Branch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L584-L599">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.computefeature-Tuple{VarFeature, Any}" href="#SoleModels.computefeature-Tuple{VarFeature, Any}"><code>SoleModels.computefeature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computefeature(f::VarFeature, featchannel; kwargs...)</code></pre><p>Compute a feature on a featchannel (i.e., world reading) of an instance.</p><p>See also <a href="#SoleModels.VarFeature"><code>VarFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/var-features.jl#L50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.computeunivariatefeature-Tuple{SoleModels.AbstractUnivariateFeature, Any}" href="#SoleModels.computeunivariatefeature-Tuple{SoleModels.AbstractUnivariateFeature, Any}"><code>SoleModels.computeunivariatefeature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeunivariatefeature(f::AbstractUnivariateFeature, varchannel; kwargs...)</code></pre><p>Compute a feature on a variable channel (i.e., world reading) of an instance.</p><p>See also <a href="#SoleModels.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/var-features.jl#L108-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.consequent-Tuple{Rule}" href="#SoleModels.consequent-Tuple{Rule}"><code>SoleModels.consequent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">consequent(m::Rule)::AbstractModel</code></pre><p>Return the consequent of a rule.</p><p>See also <a href="#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="#SoleModels.Rule"><code>Rule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L568-L576">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.default_weights-Tuple{Integer}" href="#SoleModels.default_weights-Tuple{Integer}"><code>SoleModels.default_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_weights(n::Integer)::AbstractVector{&lt;:Number}</code></pre><p>Return a default weight vector of <code>n</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/machine-learning.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.displaymodel-Tuple{SoleModels.AbstractModel}" href="#SoleModels.displaymodel-Tuple{SoleModels.AbstractModel}"><code>SoleModels.displaymodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printmodel(io::IO, m::AbstractModel; kwargs...)
displaymodel(m::AbstractModel; kwargs...)</code></pre><p>prints or returns a string representation of model <code>m</code>.</p><p><strong>Arguments</strong></p><ul><li><code>header::Bool = true</code>: when set to <code>true</code>, a header is printed, displaying</li></ul><p>the <code>info</code> structure for <code>m</code>;</p><ul><li><code>show_subtree_info::Bool = false</code>: when set to <code>true</code>, the header is printed for</li></ul><p>models in the sub-tree of <code>m</code>;</p><ul><li><code>show_metrics::Bool = false</code>: when set to <code>true</code>, performance metrics at each point of the</li></ul><p>subtree are shown, whenever they are available in the <code>info</code> structure;</p><ul><li><code>max_depth::Union{Nothing,Int} = nothing</code>: when it is an <code>Int</code>, models in the sub-tree</li></ul><p>with a depth higher than <code>max_depth</code> are ellipsed with &quot;...&quot;;</p><ul><li><code>syntaxstring_kwargs::NamedTuple = (;)</code>: kwargs to be passed to <code>syntaxstring</code> for</li></ul><p>formatting logical formulas.</p><p>See also <a href="../logic/#SoleLogics.syntaxstring"><code>syntaxstring</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/print.jl#L114-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.evaluaterule-Union{Tuple{FM}, Tuple{A}, Tuple{O}, Tuple{Rule{O, A, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}}}} where {O, A, FM&lt;:SoleModels.AbstractModel}" href="#SoleModels.evaluaterule-Union{Tuple{FM}, Tuple{A}, Tuple{O}, Tuple{Rule{O, A, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}}}} where {O, A, FM&lt;:SoleModels.AbstractModel}"><code>SoleModels.evaluaterule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluaterule(
    r::Rule{O},
    X::AbstractInterpretationSet,
    Y::AbstractVector{L}
) where {O,L&lt;:Label}</code></pre><p>Evaluate the rule on a labelled dataset, and return a <code>NamedTuple</code> consisting of:</p><ul><li><code>antsat::Vector{Bool}</code>: satsfaction of the antecedent for each instance in the dataset;</li><li><code>ys::Vector{Union{Nothing,O}}</code>: rule prediction. For each instance in X:<ul><li><code>consequent(rule)</code> if the antecedent is satisfied,</li><li><code>nothing</code> otherwise.</li></ul></li></ul><p>See also <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="../logic/#SoleLogics.AbstractInterpretationSet"><code>SoleLogics.AbstractInterpretationSet</code></a>, <a href="#SoleModels.Label"><code>Label</code></a>, <a href="#SoleModels.checkantecedent"><code>checkantecedent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/evaluation.jl#L53-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.feasiblemodelstype-Union{Tuple{Type{M}}, Tuple{M}, Tuple{O}} where {O, M&lt;:SoleModels.AbstractModel{O}}" href="#SoleModels.feasiblemodelstype-Union{Tuple{Type{M}}, Tuple{M}, Tuple{O}} where {O, M&lt;:SoleModels.AbstractModel{O}}"><code>SoleModels.feasiblemodelstype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feasiblemodelstype(m::AbstractModel)</code></pre><p>Return a <code>Union</code> of the Feasible Models (<code>FM</code>) allowed in the sub-tree of any AbstractModel. Note that for a <code>ConstrainedModel{O,FM&lt;:AbstractModel}</code>, it simply returns <code>FM</code>.</p><p>See also <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L410-L418">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.featvaltype-Tuple{Any, VarFeature}" href="#SoleModels.featvaltype-Tuple{Any, VarFeature}"><code>SoleModels.featvaltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">featvaltype(dataset, f::VarFeature)</code></pre><p>Return the type of the values returned by feature <code>f</code> on logiseed <code>dataset</code>.</p><p>See also <a href="#SoleModels.VarFeature"><code>VarFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/var-features.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.immediatesubmodels-Union{Tuple{SoleModels.AbstractModel{O}}, Tuple{O}} where O" href="#SoleModels.immediatesubmodels-Union{Tuple{SoleModels.AbstractModel{O}}, Tuple{O}} where O"><code>SoleModels.immediatesubmodels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">immediatesubmodels(m::AbstractModel)</code></pre><p>Return the list of immediate child models. Note: if the model is a leaf model, then the returned list will be empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SoleLogics

julia&gt; branch = Branch(SoleLogics.parseformula(&quot;p∧q∨r&quot;), &quot;YES&quot;, &quot;NO&quot;);

julia&gt; immediatesubmodels(branch)
2-element Vector{SoleModels.ConstantModel{String}}:
 SoleModels.ConstantModel{String}
YES

 SoleModels.ConstantModel{String}
NO

julia&gt; branch2 = Branch(SoleLogics.parseformula(&quot;s→p&quot;), branch, 42);


julia&gt; printmodel.(immediatesubmodels(branch2));
Branch
┐ p ∧ (q ∨ r)
├ ✔ YES
└ ✘ NO

ConstantModel
42</code></pre><p>See also <a href="#SoleModels.submodels-Tuple{SoleModels.AbstractModel}"><code>submodels</code></a>, <a href="#SoleModels.LeafModel"><code>LeafModel</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/symbolic-utils.jl#L6-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.info-Tuple{SoleModels.AbstractModel}" href="#SoleModels.info-Tuple{SoleModels.AbstractModel}"><code>SoleModels.info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">info(m::AbstractModel)::NamedTuple = m.info
info(m::AbstractModel, key) = m.info[key]
info(m::AbstractModel, key, defaultval)
info!(m::AbstractModel, key, val)</code></pre><p>Return the <code>info</code> structure for model <code>m</code>; this structure is used for storing additional information that does not affect the model&#39;s behavior. This structure can hold, for example, information about the model&#39;s statistical performance during the learning phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L177-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.isminifiable-Tuple{Any}" href="#SoleModels.isminifiable-Tuple{Any}"><code>SoleModels.isminifiable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isminifiable(::Any)::Bool</code></pre><p>Return whether minification can be applied on a dataset structure. See also <a href="#SoleModels.minify-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Union{Missing, Nothing, Real}"><code>minify</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/utils/minify.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.issymbolic-Tuple{SoleModels.AbstractModel}" href="#SoleModels.issymbolic-Tuple{SoleModels.AbstractModel}"><code>SoleModels.issymbolic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">issymbolic(::AbstractModel)::Bool</code></pre><p>Return whether a model is symbolic or not. A model is said to be <code>symbolic</code> when its application relies on checking formulas of a certain logical language (see <a href="https://github.com/aclai-lab/SoleLogics.jl">SoleLogics.jl</a> package) on the instance. Symbolic models provide a form of transparent and interpretable modeling, as a symbolic model can be synthethised into a set of mutually exclusive logical rules that can often be translated into natural language.</p><p>Examples of purely symbolic models are <a href="#SoleModels.Rule"><code>Rule</code></a>s, <a href="#SoleModels.Branch"><code>Branch</code></a>, <a href="#SoleModels.DecisionList"><code>DecisionList</code></a>s and <a href="#SoleModels.DecisionTree"><code>DecisionTree</code></a>s. Examples of non-symbolic models are those encoding algebraic mathematical functions (e.g., neural networks). Note that <a href="#SoleModels.DecisionForest"><code>DecisionForest</code></a>s are not purely symbolic, as they rely on an algebraic aggregation step.</p><p>See also <a href="#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>apply</code></a>, <a href="#SoleModels.listrules-Tuple{SoleModels.AbstractModel}"><code>listrules</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L152-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.joinrules" href="#SoleModels.joinrules"><code>SoleModels.joinrules</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">joinrules(rules::AbstractVector{&lt;:Rule})::Vector{&lt;:Rule}</code></pre><p>Return a set of rules, with exactly one rule per different outcome from the input set of rules. For each outcome, the output rule is computed as the logical disjunction of the antecedents of the input rules for that outcome.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SoleLogics

julia&gt; branch = Branch(SoleLogics.parseformula(&quot;p&quot;), Branch(SoleLogics.parseformula(&quot;q&quot;), &quot;YES&quot;, &quot;NO&quot;), &quot;NO&quot;)
 p
├✔ q
│├✔ YES
│└✘ NO
└✘ NO


julia&gt; printmodel.(listrules(branch); tree_mode = true);
▣ p ∧ q
└✔ YES

▣ p ∧ ¬q
└✔ NO

▣ ¬p
└✔ NO

julia&gt; printmodel.(joinrules(listrules(branch)); tree_mode = true);
▣ (p ∧ q)
└✔ YES

▣ (p ∧ ¬q) ∨ ¬p
└✔ NO
</code></pre><p>See also <a href="#SoleModels.listrules-Tuple{SoleModels.AbstractModel}"><code>listrules</code></a>, <a href="#SoleModels.issymbolic-Tuple{SoleModels.AbstractModel}"><code>issymbolic</code></a>, <a href="../logic/#SoleLogics.DISJUNCTION"><code>SoleLogics.DISJUNCTION</code></a>, <a href="#SoleModels.LeafModel"><code>LeafModel</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/symbolic-utils.jl#L422-L463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.listimmediaterules-Tuple{SoleModels.AbstractModel}" href="#SoleModels.listimmediaterules-Tuple{SoleModels.AbstractModel}"><code>SoleModels.listimmediaterules</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">listimmediaterules(m::AbstractModel{O} where {O})::Rule{&lt;:O}</code></pre><p>List the immediate rules equivalent to a symbolic model.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SoleLogics

julia&gt; branch = Branch(SoleLogics.parseformula(&quot;p&quot;), Branch(SoleLogics.parseformula(&quot;q&quot;), &quot;YES&quot;, &quot;NO&quot;), &quot;NO&quot;)
 p
├✔ q
│├✔ YES
│└✘ NO
└✘ NO


julia&gt; printmodel.(listimmediaterules(branch); tree_mode = true);
▣ p
└✔ q
 ├✔ YES
 └✘ NO

▣ ¬(p)
└✔ NO

</code></pre><p>See also <a href="#SoleModels.listrules-Tuple{SoleModels.AbstractModel}"><code>listrules</code></a>, <a href="#SoleModels.issymbolic-Tuple{SoleModels.AbstractModel}"><code>issymbolic</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/symbolic-utils.jl#L162-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.listrules-Tuple{SoleModels.AbstractModel}" href="#SoleModels.listrules-Tuple{SoleModels.AbstractModel}"><code>SoleModels.listrules</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">listrules(
    m::AbstractModel;
    use_shortforms::Bool = true,
    use_leftmostlinearform::Bool = false,
    normalize::Bool = false,
    force_syntaxtree::Bool = false,
)::Vector{&lt;:Rule}</code></pre><p>Return a list of rules capturing the knowledge enclosed in symbolic model. The behavior of any symbolic model can be synthesised and represented as a set of mutually exclusive (and jointly exaustive, if the model is closed) rules, which can be useful for many purposes.</p><p>The keyword argument <code>force_syntaxtree</code>, when set to true, causes the logical antecedents in the returned rules to be represented as <code>SyntaxTree</code>s, as opposed to other syntax structure (e.g., <code>LeftmostConjunctiveForm</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SoleLogics

julia&gt; branch = Branch(SoleLogics.parseformula(&quot;p&quot;), Branch(SoleLogics.parseformula(&quot;q&quot;), &quot;YES&quot;, &quot;NO&quot;), &quot;NO&quot;)
 p
├✔ q
│├✔ YES
│└✘ NO
└✘ NO


julia&gt; printmodel.(listrules(branch); tree_mode = true);
▣ p ∧ q
└✔ YES

▣ p ∧ ¬q
└✔ NO

▣ ¬p
└✔ NO
</code></pre><p>See also <a href="#SoleModels.listimmediaterules-Tuple{SoleModels.AbstractModel}"><code>listimmediaterules</code></a>, <a href="../logic/#SoleLogics.CONJUNCTION"><code>SoleLogics.CONJUNCTION</code></a>, <a href="#SoleModels.joinrules"><code>joinrules</code></a>, <a href="#SoleModels.issymbolic-Tuple{SoleModels.AbstractModel}"><code>issymbolic</code></a>, <a href="#SoleModels.LeafModel"><code>LeafModel</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/symbolic-utils.jl#L233-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.minify-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Union{Missing, Nothing, Real}" href="#SoleModels.minify-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Union{Missing, Nothing, Real}"><code>SoleModels.minify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minify(dataset::D1)::Tuple{D2,Function} where {D1,D2}</code></pre><p>Return a <em>minified</em> version of a dataset, as well as a backmap for reverting to the original dataset. Dataset minification remaps each scalar values in the dataset to a new value such that the overall order of the values is preserved; the output dataset is smaller in size, since it relies on values of type UInt8, UInt16, UInt32, etc.</p><p>See also <a href="#SoleModels.isminifiable-Tuple{Any}"><code>isminifiable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/utils/minify.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.naturalgrouping-Tuple{DataFrames.AbstractDataFrame}" href="#SoleModels.naturalgrouping-Tuple{DataFrames.AbstractDataFrame}"><code>SoleModels.naturalgrouping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">naturalgrouping(
    X::AbstractDataFrame;
    allow_variable_drop = false,
)::AbstractVector{&lt;:AbstractVector{&lt;:Symbol}}</code></pre><p>Return variables grouped by their logical nature; the nature of a variable is automatically derived from its type (e.g., Real, Vector{&lt;:Real} or Matrix{&lt;:Real}) and frame. All instances must have the same frame (e.g., channel size/number of worlds).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/dataset-bindings.jl#L484-L494">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.negconsequent-Tuple{Branch}" href="#SoleModels.negconsequent-Tuple{Branch}"><code>SoleModels.negconsequent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">negconsequent(m::Branch)::AbstractModel</code></pre><p>Return the negative consequent of a branch; that is, the model to be applied if the antecedent evaluates to <code>false</code>.</p><p>See also <a href="#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="#SoleModels.Branch"><code>Branch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L748-L757">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O" href="#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>SoleModels.outcometype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outcometype(::Type{&lt;:AbstractModel{O}}) where {O} = O
outcometype(m::AbstractModel) = outcometype(typeof(m))</code></pre><p>Return the outcome type of a model (type).</p><p>See also <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L33-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.outputtype-Tuple{SoleModels.AbstractModel}" href="#SoleModels.outputtype-Tuple{SoleModels.AbstractModel}"><code>SoleModels.outputtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outputtype(m::AbstractModel)</code></pre><p>Return a supertype for the outputs obtained when <code>apply</code>ing a model. The result depends on whether the model is open or closed:</p><pre><code class="nohighlight hljs">outputtype(M::AbstractModel{O}) = isopen(M) ? Union{Nothing,O} : O</code></pre><p>Note that if the model is closed, then <code>outputtype(m)</code> is equal to <code>outcometype(m)</code>.</p><p>See also <a href="#Base.isopen-Tuple{SoleModels.AbstractModel}"><code>isopen</code></a>, <a href="#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>apply</code></a>, <a href="#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>outcometype</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L61-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.parsecondition-Tuple{Type{&lt;:SoleModels.AbstractCondition}, String}" href="#SoleModels.parsecondition-Tuple{Type{&lt;:SoleModels.AbstractCondition}, String}"><code>SoleModels.parsecondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsecondition(C::Type{&lt;:AbstractCondition}, expr::String; kwargs...)</code></pre><p>Parse a condition of type <code>C</code> from its <a href="../logic/#SoleLogics.syntaxstring"><code>syntaxstring</code></a> representation. Depending on <code>C</code>, specifying keyword arguments such as <code>featuretype::Type{&lt;:AbstractFeature}</code>, and <code>featvaltype::Type</code> may be required or recommended.</p><p>See also <a href="#SoleModels.parsefeature-Tuple{Type{&lt;:AbstractFeature}, String}"><code>parsefeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/conditions.jl#L58-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.parsefeature-Tuple{Type{&lt;:AbstractFeature}, String}" href="#SoleModels.parsefeature-Tuple{Type{&lt;:AbstractFeature}, String}"><code>SoleModels.parsefeature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsefeature(FT::Type{&lt;:AbstractFeature}, expr::String; kwargs...)</code></pre><p>Parse a feature of type <code>FT</code> from its <a href="../logic/#SoleLogics.syntaxstring"><code>syntaxstring</code></a> representation. Depending on <code>FT</code>, specifying keyword arguments such as <code>featvaltype::Type</code> may be required or recommended.</p><p>See also <a href="#SoleModels.parsecondition-Tuple{Type{&lt;:SoleModels.AbstractCondition}, String}"><code>parsecondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/features.jl#L36-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.posconsequent-Tuple{Branch}" href="#SoleModels.posconsequent-Tuple{Branch}"><code>SoleModels.posconsequent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">posconsequent(m::Branch)::AbstractModel</code></pre><p>Return the positive consequent of a branch; that is, the model to be applied if the antecedent evaluates to <code>true</code>.</p><p>See also <a href="#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="#SoleModels.Branch"><code>Branch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L736-L745">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.printmodel-Tuple{IO, SoleModels.AbstractModel}" href="#SoleModels.printmodel-Tuple{IO, SoleModels.AbstractModel}"><code>SoleModels.printmodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printmodel(io::IO, m::AbstractModel; kwargs...)
displaymodel(m::AbstractModel; kwargs...)</code></pre><p>prints or returns a string representation of model <code>m</code>.</p><p><strong>Arguments</strong></p><ul><li><code>header::Bool = true</code>: when set to <code>true</code>, a header is printed, displaying</li></ul><p>the <code>info</code> structure for <code>m</code>;</p><ul><li><code>show_subtree_info::Bool = false</code>: when set to <code>true</code>, the header is printed for</li></ul><p>models in the sub-tree of <code>m</code>;</p><ul><li><code>show_metrics::Bool = false</code>: when set to <code>true</code>, performance metrics at each point of the</li></ul><p>subtree are shown, whenever they are available in the <code>info</code> structure;</p><ul><li><code>max_depth::Union{Nothing,Int} = nothing</code>: when it is an <code>Int</code>, models in the sub-tree</li></ul><p>with a depth higher than <code>max_depth</code> are ellipsed with &quot;...&quot;;</p><ul><li><code>syntaxstring_kwargs::NamedTuple = (;)</code>: kwargs to be passed to <code>syntaxstring</code> for</li></ul><p>formatting logical formulas.</p><p>See also <a href="../logic/#SoleLogics.syntaxstring"><code>syntaxstring</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/print.jl#L70-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.propagate_feasiblemodels-Tuple{Type{&lt;:SoleModels.AbstractModel}}" href="#SoleModels.propagate_feasiblemodels-Tuple{Type{&lt;:SoleModels.AbstractModel}}"><code>SoleModels.propagate_feasiblemodels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_feasiblemodels(M::Type{&lt;:AbstractModel}) = Union{typename(M){outcometype(M)}, feasiblemodelstype(M)}
propagate_feasiblemodels(m::AbstractModel) = propagate_feasiblemodels(typeof(m))</code></pre><p>This function is used upon construction of a <code>ConstrainedModel</code>, to compute its Feasible Models (<code>FM</code>). In general, its <code>FM</code> are a <code>Union</code> of the <code>FM</code> of its immediate child models, but a trick is used in order to avoid unneccessary propagation of types throughout the model tree. Note that this trick assumes that the first type parameter of any <code>ConstrainedModel</code> is its <code>outcometype</code> <code>O</code>.</p><p>See also <a href="#SoleModels.feasiblemodelstype-Union{Tuple{Type{M}}, Tuple{M}, Tuple{O}} where {O, M&lt;:SoleModels.AbstractModel{O}}"><code>feasiblemodelstype</code></a>, <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L426-L438">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.readmetrics-Union{Tuple{SoleModels.LeafModel{L}}, Tuple{L}} where L&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}" href="#SoleModels.readmetrics-Union{Tuple{SoleModels.LeafModel{L}}, Tuple{L}} where L&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}"><code>SoleModels.readmetrics</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readmetrics(m::AbstractModel; digits = 2)</code></pre><p>Return a <code>NamedTuple</code> with some performance metrics for the given symbolic model. Performance metrics can be computed when the <code>info</code> structure of the model has the     following keys:     - :supporting<em>labels     - :supporting</em>predictions</p><p>The <code>digits</code> keyword argument is used to <code>round</code> accuracy/confidence metrics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/evaluation.jl#L6-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.representatives-Union{Tuple{W}, Tuple{SoleLogics.AbstractFrame{W}, W, AbstractRelation, SoleModels.AbstractCondition}} where W&lt;:AbstractWorld" href="#SoleModels.representatives-Union{Tuple{W}, Tuple{SoleLogics.AbstractFrame{W}, W, AbstractRelation, SoleModels.AbstractCondition}} where W&lt;:AbstractWorld"><code>SoleModels.representatives</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">representatives(
    fr::AbstractFrame{W},
    S::W,
    ::AbstractRelation,
    ::AbstractCondition
) where {W&lt;:AbstractWorld}</code></pre><p>Return an iterator to the (few) <em>representative</em> accessible worlds that are necessary for computing and propagating truth values through existential modal connectives. When this optimization is possible (e.g., when checking specific formulas on scalar conditions), it allows to further boost &quot;one-step&quot; optimizations (see <a href="#SoleModels.AbstractOneStepMemoset"><code>AbstractOneStepMemoset</code></a>).</p><p>For example, consider a Kripke structure with a 1-dimensional <code>FullDimensionalFrame</code> of length 100, and the problem of checking a formula &quot;⟨L⟩(max[V1] ≥ 10)&quot; on a <a href="../logic/#SoleLogics.Interval"><code>SoleLogics.Interval</code></a> <code>SoleLogics.Interval{Int64}(1, 2)</code> (with <code>L</code> being Allen&#39;s &quot;Later&quot; relation, see <a href="../logic/#SoleLogics.IA_L"><code>SoleLogics.IA_L</code></a>). Comparing 10 with the (maximum) &quot;max[V1]&quot; computed on all worlds is the naïve strategy to check the formula. However, in this case, comparing 10 to the &quot;max[V1]&quot; computed on the single <code>Interval</code> SoleLogics.Interval{Int64}(2, 101) suffice to establish whether the structure satisfies the formula. Similar cases arise depending on the relation, feature and test operator (or, better, its <em>aggregator</em>).</p><p>Note that this method fallsback to <code>accessibles</code>.</p><p>See also <a href="../logic/#SoleLogics.accessibles"><code>SoleLogics.accessibles</code></a>, <a href="#SoleModels.ScalarCondition"><code>ScalarCondition</code></a>, <a href="../logic/#SoleLogics.AbstractFrame"><code>SoleLogics.AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/representatives.jl#L5-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.rulemetrics-Union{Tuple{FM}, Tuple{A}, Tuple{O}, Tuple{Rule{O, A, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}}}} where {O, A, FM&lt;:SoleModels.AbstractModel}" href="#SoleModels.rulemetrics-Union{Tuple{FM}, Tuple{A}, Tuple{O}, Tuple{Rule{O, A, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}}}} where {O, A, FM&lt;:SoleModels.AbstractModel}"><code>SoleModels.rulemetrics</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rulemetrics(
    r::Rule,
    X::AbstractInterpretationSet,
    Y::AbstractVector{&lt;:Label}
)</code></pre><p>Compute metrics for a rule with respect to a labelled dataset and returns a <code>NamedTuple</code> consisting of:</p><ul><li><code>support</code>: number of instances satisfying the antecedent of the rule divided by   the total number of instances;</li><li><code>error</code>:<ul><li>For classification problems: number of instances that were not classified</li></ul>correctly divided by the total number of instances;<ul><li>For regression problems: mean squared error;</li></ul></li><li><code>length</code>: number of atoms in the rule&#39;s antecedent.</li></ul><p>See also <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="../logic/#SoleLogics.AbstractInterpretationSet"><code>SoleLogics.AbstractInterpretationSet</code></a>, <a href="#SoleModels.Label"><code>Label</code></a>, <a href="#SoleModels.evaluaterule-Union{Tuple{FM}, Tuple{A}, Tuple{O}, Tuple{Rule{O, A, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}}}} where {O, A, FM&lt;:SoleModels.AbstractModel}"><code>evaluaterule</code></a>, <a href="#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>outcometype</code></a>, <a href="#SoleModels.consequent-Tuple{Rule}"><code>consequent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/evaluation.jl#L125-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.scalarlogiset" href="#SoleModels.scalarlogiset"><code>SoleModels.scalarlogiset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scalarlogiset(dataset, features; kwargs...)</code></pre><p>Converts a dataset structure (with variables) to a logiset with scalar-valued features. If <code>dataset</code> is not a multimodal dataset, the following methods should be defined: TODO explain</p><pre><code class="language-julia hljs">    islogiseed(::typeof(dataset)) = true
    initlogiset(dataset, features)
    ninstances(dataset)
    nvariables(dataset)
    frame(dataset, i_instance::Integer)
    featvalue(dataset, i_instance::Integer, w::AbstractWorld, feature::VarFeature)
    vareltype(dataset, i_variable::Integer)</code></pre><p>If <code>dataset</code> represents a multimodal dataset, the following methods should be defined, while its modalities (iterated via <code>eachmodality</code>) should provide the methods above:</p><pre><code class="language-julia hljs">    ismultilogiseed(dataset)
    nmodalities(dataset)
    eachmodality(dataset)</code></pre><p>See also <a href="#SoleModels.AbstractLogiset"><code>AbstractLogiset</code></a>, <a href="#SoleModels.VarFeature"><code>VarFeature</code></a>, <a href="#SoleModels.ScalarCondition"><code>ScalarCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/dataset-bindings.jl#L123-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.submodels-Tuple{SoleModels.AbstractModel}" href="#SoleModels.submodels-Tuple{SoleModels.AbstractModel}"><code>SoleModels.submodels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">submodels(m::AbstractModel)</code></pre><p>Enumerate all submodels in the sub-tree. This function is the transitive closure of <code>immediatesubmodels</code>; in fact, the returned list includes the immediate submodels (<code>immediatesubmodels(m)</code>), but also their immediate submodels, and so on.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SoleLogics

julia&gt; branch = Branch(SoleLogics.parseformula(&quot;p∧q∨r&quot;), &quot;YES&quot;, &quot;NO&quot;);

julia&gt; submodels(branch)
2-element Vector{SoleModels.ConstantModel{String}}:
 ConstantModel
YES

 ConstantModel
NO


julia&gt; branch2 = Branch(SoleLogics.parseformula(&quot;s→p&quot;), branch, 42);

julia&gt; printmodel.(submodels(branch2));
Branch
┐ p ∧ (q ∨ r)
├ ✔ YES
└ ✘ NO

ConstantModel
YES

ConstantModel
NO

ConstantModel
42

julia&gt; submodels(branch) == immediatesubmodels(branch)
true

julia&gt; submodels(branch2) == immediatesubmodels(branch2)
false</code></pre><p>See also <a href="#SoleModels.immediatesubmodels-Union{Tuple{SoleModels.AbstractModel{O}}, Tuple{O}} where O"><code>immediatesubmodels</code></a>, <a href="#SoleModels.LeafModel"><code>LeafModel</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/symbolic-utils.jl#L66-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.variable_name-Tuple{SoleModels.AbstractUnivariateFeature}" href="#SoleModels.variable_name-Tuple{SoleModels.AbstractUnivariateFeature}"><code>SoleModels.variable_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable_name(
    f::AbstractUnivariateFeature;
    variable_names_map::Union{Nothing,AbstractDict,AbstractVector} = nothing,
    variable_name_prefix::Union{Nothing,String} = &quot;V&quot;,
)::String</code></pre><p>Return the name of the variable targeted by a univariate feature. By default, an variable name is a number prefixed by &quot;V&quot;; however, <code>variable_names_map</code> or <code>variable_name_prefix</code> can be used to customize variable names. The prefix can be customized by specifying <code>variable_name_prefix</code>. Alternatively, a mapping from string to integer (either via a Dictionary or a Vector) can be passed as <code>variable_names_map</code>. Note that only one in <code>variable_names_map</code> and <code>variable_name_prefix</code> should be provided.</p><p>See also <a href="#SoleModels.parsecondition-Tuple{Type{&lt;:SoleModels.AbstractCondition}, String}"><code>parsecondition</code></a>, <a href="#SoleModels.ScalarCondition"><code>ScalarCondition</code></a>, <a href="../logic/#SoleLogics.syntaxstring"><code>syntaxstring</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/scalar/var-features.jl#L125-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.wrap-Tuple{Any, Type{&lt;:SoleModels.AbstractModel}}" href="#SoleModels.wrap-Tuple{Any, Type{&lt;:SoleModels.AbstractModel}}"><code>SoleModels.wrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap(o::Any)::AbstractModel</code></pre><p>This function wraps anything into an AbstractModel. The default behavior is the following:</p><ul><li>when called on an <code>AbstractModel</code>, the model is</li></ul><p>simply returned (no wrapping is performed);</p><ul><li><code>Function</code>s and <code>FunctionWrapper</code>s are wrapped into a <code>FunctionModel</code>;</li><li>every other object is wrapped into a <code>ConstantModel</code>.</li></ul><p>See also <a href="#SoleModels.ConstantModel"><code>ConstantModel</code></a>, <a href="#SoleModels.FunctionModel"><code>FunctionModel</code></a>, <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.LeafModel"><code>LeafModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/models/base.jl#L366-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.DimensionalDatasets.AbstractUniformFullDimensionalLogiset" href="#SoleModels.DimensionalDatasets.AbstractUniformFullDimensionalLogiset"><code>SoleModels.DimensionalDatasets.AbstractUniformFullDimensionalLogiset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for optimized, uniform logisets with full dimensional frames. Here, &quot;uniform&quot; refers to the fact that all instances have the same frame, and &quot;full&quot; refers to the fact that <em>all</em> worlds of a given kind are considered (e.g., <em>all</em> points/intervals/rectangles)</p><p>See also <a href="#SoleModels.DimensionalDatasets.UniformFullDimensionalLogiset"><code>UniformFullDimensionalLogiset</code></a>, <a href="@ref">`SoleLogics.FullDimensionalFrame</a>, <a href="#SoleModels.AbstractLogiset"><code>AbstractLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/dimensional-structures/logiset.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.DimensionalDatasets.AbstractUniformFullDimensionalOneStepRelationalMemoset" href="#SoleModels.DimensionalDatasets.AbstractUniformFullDimensionalOneStepRelationalMemoset"><code>SoleModels.DimensionalDatasets.AbstractUniformFullDimensionalOneStepRelationalMemoset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for relational memosets optimized for uniform logisets with full dimensional frames.</p><p>See also <a href="#SoleModels.DimensionalDatasets.UniformFullDimensionalLogiset"><code>UniformFullDimensionalLogiset</code></a>, <a href="#SoleModels.AbstractScalarOneStepRelationalMemoset"><code>AbstractScalarOneStepRelationalMemoset</code></a>, <a href="@ref">`SoleLogics.FullDimensionalFrame</a>, <a href="#SoleModels.AbstractLogiset"><code>AbstractLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/dimensional-structures/onestep-memosets.jl#L4-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.DimensionalDatasets.UniformFullDimensionalLogiset" href="#SoleModels.DimensionalDatasets.UniformFullDimensionalLogiset"><code>SoleModels.DimensionalDatasets.UniformFullDimensionalLogiset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Uniform scalar logiset with full dimensional frames of dimensionality <code>N</code>, storing values for each world in a <code>ninstances</code> × <code>nfeatures</code> array. Each world is a hyper-interval, and its <code>N*2</code> components are used to index different array dimensions, ultimately resulting in a <code>(N*2+2)</code>-dimensional array.</p><p>See also <a href="#SoleModels.DimensionalDatasets.AbstractUniformFullDimensionalLogiset"><code>AbstractUniformFullDimensionalLogiset</code></a>, <a href="@ref">`SoleLogics.FullDimensionalFrame</a>, <a href="#SoleModels.AbstractLogiset"><code>AbstractLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/dimensional-structures/logiset.jl#L32-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.DimensionalDatasets.UniformFullDimensionalOneStepRelationalMemoset" href="#SoleModels.DimensionalDatasets.UniformFullDimensionalOneStepRelationalMemoset"><code>SoleModels.DimensionalDatasets.UniformFullDimensionalOneStepRelationalMemoset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A relational memoset optimized for uniform scalar logisets with full dimensional frames of dimensionality <code>N</code>, storing values for each world in a <code>ninstances</code> × <code>nmetaconditions</code> × <code>nrelations</code> array. Each world is a hyper-interval, and its <code>N*2</code> components are used to index different array dimensions, ultimately resulting in a <code>(N*2+3)</code>-dimensional array.</p><p>See also <a href="#SoleModels.DimensionalDatasets.UniformFullDimensionalLogiset"><code>UniformFullDimensionalLogiset</code></a>, <a href="@ref">`FullDimensionalFrame</a>, <a href="#SoleModels.AbstractLogiset"><code>AbstractLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/54eafcb356bfcee9cd24493cfd96d63a9c761b47/src/logisets/dimensional-structures/onestep-memosets.jl#L22-L33">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/">« Symbolic models</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.0 on <span class="colophon-date" title="Thursday 30 November 2023 06:34">Thursday 30 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
