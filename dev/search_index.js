var documenterSearchIndex = {"docs":
[{"location":"models/","page":"Symbolic models","title":"Symbolic models","text":"CurrentModule = SoleModels","category":"page"},{"location":"models/#Symbolic-models","page":"Symbolic models","title":"Symbolic models","text":"","category":"section"},{"location":"models/","page":"Symbolic models","title":"Symbolic models","text":"Modules = [SoleModels, SoleModels.DimensionalDatasets]\nPages   = [\"models/base.jl\"]","category":"page"},{"location":"models/","page":"Symbolic models","title":"Symbolic models","text":"printmodel","category":"page"},{"location":"models/#SoleModels.printmodel","page":"Symbolic models","title":"SoleModels.printmodel","text":"printmodel(io::IO, m::AbstractModel; kwargs...)\ndisplaymodel(m::AbstractModel; kwargs...)\n\nprints or returns a string representation of model m.\n\nArguments\n\nheader::Bool = true: when set to true, a header is printed, displaying\n\nthe info structure for m;\n\nshow_subtree_info::Bool = false: when set to true, the header is printed for\n\nmodels in the sub-tree of m;\n\nshow_metrics::Bool = false: when set to true, performance metrics at each point of the\n\nsubtree are shown, whenever they are available in the info structure;\n\nmax_depth::Union{Nothing,Int} = nothing: when it is an Int, models in the sub-tree\n\nwith a depth higher than max_depth are ellipsed with \"...\";\n\nsyntaxstring_kwargs::NamedTuple = (;): kwargs to be passed to syntaxstring for\n\nformatting logical formulas.\n\nSee also syntaxstring, AbstractModel.\n\n\n\n\n\n","category":"function"},{"location":"models/#Evaluating-symbolic-models","page":"Symbolic models","title":"Evaluating symbolic models","text":"","category":"section"},{"location":"models/","page":"Symbolic models","title":"Symbolic models","text":"Modules = [SoleModels, SoleModels.DimensionalDatasets]\nPages   = [\"models/evaluation.jl\"]","category":"page"},{"location":"models/#Manipulating-symbolic-knowledge","page":"Symbolic models","title":"Manipulating symbolic knowledge","text":"","category":"section"},{"location":"models/","page":"Symbolic models","title":"Symbolic models","text":"Modules = [SoleModels, SoleModels.DimensionalDatasets]\nPages   = [\"models/symbolic-utils.jl\"]","category":"page"},{"location":"models/","page":"Symbolic models","title":"Symbolic models","text":"<!– ","category":"page"},{"location":"models/","page":"Symbolic models","title":"Symbolic models","text":"Modules = [SoleModels, SoleModels.DimensionalDatasets]\nPages   = [\"machine-learning.jl\"]","category":"page"},{"location":"models/","page":"Symbolic models","title":"Symbolic models","text":"–>","category":"page"},{"location":"logisets/","page":"Logisets","title":"Logisets","text":"CurrentModule = SoleModels","category":"page"},{"location":"logisets/","page":"Logisets","title":"Logisets","text":"Pages = [\"logisets.md\"]","category":"page"},{"location":"logisets/#Logisets","page":"Logisets","title":"Logisets","text":"","category":"section"},{"location":"logisets/","page":"Logisets","title":"Logisets","text":"Modules = [SoleModels, SoleModels.DimensionalDatasets]\nPages   = [\"logisets/features.jl\", \"logisets/conditions.jl\"]","category":"page"},{"location":"logisets/","page":"Logisets","title":"Logisets","text":"Modules = [SoleModels, SoleModels.DimensionalDatasets]\nPages   = [\"logisets/representatives.jl\"]","category":"page"},{"location":"logisets/","page":"Logisets","title":"Logisets","text":"Modules = [SoleModels, SoleModels.DimensionalDatasets]\nPages   = [\"logisets/logiset.jl\"]","category":"page"},{"location":"logisets/","page":"Logisets","title":"Logisets","text":"Modules = [SoleModels, SoleModels.DimensionalDatasets]\nPages   = [\"logisets/memosets.jl\"]","category":"page"},{"location":"logisets/","page":"Logisets","title":"Logisets","text":"Modules = [SoleModels, SoleModels.DimensionalDatasets]\nPages   = [\"logisets/supported-logiset.jl\"]","category":"page"},{"location":"logisets/","page":"Logisets","title":"Logisets","text":"Modules = [SoleModels, SoleModels.DimensionalDatasets]\nPages   = [\"logisets/check.jl\"]","category":"page"},{"location":"logisets/#Scalar-Logisets","page":"Logisets","title":"Scalar Logisets","text":"","category":"section"},{"location":"logisets/","page":"Logisets","title":"Logisets","text":"Modules = [SoleModels, SoleModels.DimensionalDatasets]\nPages   = [\"logisets/scalar/main.jl\"]","category":"page"},{"location":"logisets/#Scalar-Dimensional-Logisets","page":"Logisets","title":"Scalar Dimensional Logisets","text":"","category":"section"},{"location":"logisets/","page":"Logisets","title":"Logisets","text":"Modules = [SoleModels, SoleModels.DimensionalDatasets]\nPages   = [\"logisets/dimensional-structures/main.jl\"]","category":"page"},{"location":"logisets/#MultiLogisets","page":"Logisets","title":"MultiLogisets","text":"","category":"section"},{"location":"logisets/","page":"Logisets","title":"Logisets","text":"Modules = [SoleModels, SoleModels.DimensionalDatasets]\nPages   = [\"logisets/multilogiset.jl\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SoleModels","category":"page"},{"location":"#SoleModels","page":"Home","title":"SoleModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SoleModels, the first ever framework for symbolic learning. This package provides the basic structures for representing symbolic models and data. Note that it does not provide any implementation of symbolic learning algorithms. At the current state, ModalDecisionTrees is the only implemented algorithm that is Sole-compatible.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"autodocs/","page":"Full reference","title":"Full reference","text":"CurrentModule = SoleModels","category":"page"},{"location":"autodocs/#Full-Reference","page":"Full reference","title":"Full Reference","text":"","category":"section"},{"location":"autodocs/","page":"Full reference","title":"Full reference","text":"","category":"page"},{"location":"autodocs/","page":"Full reference","title":"Full reference","text":"Modules = [SoleModels, SoleModels.DimensionalDatasets]","category":"page"},{"location":"autodocs/#SoleModels.BASE_FEATURE_ALIASES","page":"Full reference","title":"SoleModels.BASE_FEATURE_ALIASES","text":"Syntaxstring aliases for standard features, such as \"min\", \"max\", \"avg\".\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#SoleModels.CLabel","page":"Full reference","title":"SoleModels.CLabel","text":"const CLabel  = Union{String,Integer,CategoricalValue}\nconst RLabel  = AbstractFloat\nconst Label   = Union{CLabel,RLabel}\n\nTypes for supervised machine learning labels (classification and regression).\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.Label","page":"Full reference","title":"SoleModels.Label","text":"const CLabel  = Union{String,Integer,CategoricalValue}\nconst RLabel  = AbstractFloat\nconst Label   = Union{CLabel,RLabel}\n\nTypes for supervised machine learning labels (classification and regression).\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.AbstractCondition","page":"Full reference","title":"SoleModels.AbstractCondition","text":"abstract type AbstractCondition{FT<:AbstractFeature} end\n\nAbstract type for representing conditions that can be interpreted and evaluated on worlds of instances of a logical dataset. In logical contexts, these are wrapped into Atoms.\n\nSee also Atom, syntaxstring, ScalarMetaCondition, ScalarCondition.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.AbstractConditionalAlphabet","page":"Full reference","title":"SoleModels.AbstractConditionalAlphabet","text":"abstract type AbstractConditionalAlphabet{C<:ScalarCondition} <: SoleLogics.AbstractAlphabet{C} end\n\nAbstract type for alphabets of conditions.\n\nSee also ScalarCondition, ScalarMetaCondition.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.AbstractFeature","page":"Full reference","title":"SoleModels.AbstractFeature","text":"abstract type AbstractFeature end\n\nAbstract type for features of worlds of [Kripke structures](https://en.wikipedia.org/wiki/Kripkestructure(model_checking).\n\nSee also VarFeature, featvaltype, SoleLogics.AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.AbstractFullMemoset","page":"Full reference","title":"SoleModels.AbstractFullMemoset","text":"Abstract type for full memoization structures for checking generic formulas.\n\nThese structures can be stacked and coupled with one-step memoization structures (see SupportedLogiset).\n\nSee AbstractOneStepMemoset, FullMemoset.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.AbstractLogiset","page":"Full reference","title":"SoleModels.AbstractLogiset","text":"abstract type AbstractLogiset{\n    W<:AbstractWorld,\n    U,\n    FT<:AbstractFeature,\n    FR<:AbstractFrame{W},\n} <: AbstractInterpretationSet{AbstractKripkeStructure} end\n\nAbstract type for logisets, that is, logical datasets for symbolic learning where each instance is a Kripke structure associating feature values to each world. Conditions (see AbstractCondition), and logical formulas with conditional letters can be checked on worlds of instances of the dataset.\n\nSee also AbstractCondition, AbstractFeature, SoleLogics.AbstractKripkeStructure, SoleLogics.AbstractInterpretationSet.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.AbstractMemoset","page":"Full reference","title":"SoleModels.AbstractMemoset","text":"abstract type AbstractMemoset{\n    W<:AbstractWorld,\n    U,\n    FT<:AbstractFeature,\n    FR<:AbstractFrame,\n} <: AbstractLogiset{W,U,FT,FR} end\n\nAbstract type for memoization structures to be used when checking formulas on logisets.\n\nSee also FullMemoset, SupportedLogiset, AbstractLogiset.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.AbstractModel","page":"Full reference","title":"SoleModels.AbstractModel","text":"abstract type AbstractModel{O} end\n\nAbstract type for mathematical models that, given an instance object (i.e., a piece of data), output an outcome of type O.\n\nSee also Rule, Branch, isopen, apply, issymbolic, info, outcometype.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.AbstractOneStepMemoset","page":"Full reference","title":"SoleModels.AbstractOneStepMemoset","text":"Abstract type for one-step memoization structures for checking formulas of type ⟨R⟩p; with these formulas, so-called \"one-step\" optimizations can be performed.\n\nThese structures can be stacked and coupled with full memoization structures (see SupportedLogiset).\n\nSee ScalarOneStepMemoset, AbstractFullMemoset, representatives.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.AbstractScalarOneStepGlobalMemoset","page":"Full reference","title":"SoleModels.AbstractScalarOneStepGlobalMemoset","text":"Abstract type for one-step memoization structure for checking \"global\" formulas of type ⟨G⟩ (f ⋈ t).     We refer to these structures as global memosets.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.AbstractScalarOneStepRelationalMemoset","page":"Full reference","title":"SoleModels.AbstractScalarOneStepRelationalMemoset","text":"Abstract type for one-step memoization structures for checking formulas of type ⟨R⟩ (f ⋈ t), for a generic relation R that is not the global relation (SoleLogics.globalrel). We refer to these structures as relational memosets.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.AbstractUnivariateFeature","page":"Full reference","title":"SoleModels.AbstractUnivariateFeature","text":"abstract type AbstractUnivariateFeature <: VarFeature end\n\nA dimensional feature represented by the application of a function to a single variable of a dimensional channel. For example, it can wrap a scalar function computing how much red a Interval2D world, when interpreted on an image, contains.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, UnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.Aggregator","page":"Full reference","title":"SoleModels.Aggregator","text":"const Aggregator = Function\n\nA test operator is a binary Julia Function used for comparing a feature value and a threshold. In a crisp (i.e., boolean, non-fuzzy) setting, the test operator returns a Boolean value, and <, >, ≥, ≤, !=, and == are typically used.\n\nSee also ScalarCondition, ScalarOneStepMemoset, TestOperator.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.BoundedScalarConditions","page":"Full reference","title":"SoleModels.BoundedScalarConditions","text":"struct BoundedScalarConditions{C<:ScalarCondition} <: AbstractConditionalAlphabet{C}\n    grouped_featconditions::Vector{Tuple{<:ScalarMetaCondition,Vector}}\nend\n\nA finite alphabet of conditions, grouped by (a finite set of) metaconditions.\n\nSee also UnboundedScalarConditions, ScalarCondition, ScalarMetaCondition.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.Branch","page":"Full reference","title":"SoleModels.Branch","text":"struct Branch{\n    O,\n    A<:Formula,\n    FM<:AbstractModel\n} <: ConstrainedModel{O,FM}\n    antecedent::A\n    posconsequent::FM\n    negconsequent::FM\n    info::NamedTuple\nend\n\nA Branch is one of the fundamental building blocks of symbolic modeling, and has the semantics:\n\nIF (antecedent) THEN (positive consequent) ELSE (negative consequent) END\n\nwhere the antecedent is a formula to be checked and the consequents are the feasible local outcomes of the block. If checking the antecedent evaluates to the top of the algebra, then the positive consequent is applied; otherwise, the negative consequenti is applied.\n\nNote that FM refers to the Feasible Models (FM) allowed in the model's sub-tree.\n\nSee also antecedent, posconsequent, negconsequent, SoleLogics.check, SoleLogics.Formula, Rule, ConstrainedModel, AbstractModel.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ConstantModel","page":"Full reference","title":"SoleModels.ConstantModel","text":"struct ConstantModel{O} <: LeafModel{O}\n    outcome::O\n    info::NamedTuple\nend\n\nThe simplest type of model is the ConstantModel; it is a LeafModel that always outputs the same outcome.\n\nExamples\n\njulia> SoleModels.LeafModel(2) isa SoleModels.ConstantModel\n\njulia> SoleModels.LeafModel(sum) isa SoleModels.FunctionModel\n┌ Warning: Over efficiency concerns, please consider wrappingJulia Function's into FunctionWrapper{O,Tuple{SoleModels.AbstractInterpretation}} structures,where O is their return type.\n└ @ SoleModels ~/.julia/dev/SoleModels/src/models/base.jl:337\ntrue\n\n\nSee also apply, FunctionModel, LeafModel.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ConstrainedModel","page":"Full reference","title":"SoleModels.ConstrainedModel","text":"An AbstractModel can wrap another AbstractModel, and use it to compute the outcome. As such, an AbstractModel can actually be the result of a composition of many models, and enclose a tree of AbstractModels (with LeafModels at the leaves). In order to typebound the Feasible Models (FM) allowed in the sub-tree, the ConstrainedModel type is introduced:\n\nabstract type ConstrainedModel{O,FM<:AbstractModel} <: AbstractModel{O} end\n\nFor example, ConstrainedModel{String,Union{Branch{String},ConstantModel{String}}} supertypes models that with String outcomes that make use of Branch{String} and ConstantModel{String} (essentially, a decision trees with Strings at the leaves).\n\nSee also LeafModel, AbstractModel.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.DecisionForest","page":"Full reference","title":"SoleModels.DecisionForest","text":"A Decision Forest is a symbolic model that wraps an ensemble of models\n\nstruct DecisionForest{\n    O,\n    A<:Formula,\n    FFM<:LeafModel\n} <: ConstrainedModel{O,Union{<:Branch{<:O,<:A},<:FFM}}\n    trees::Vector{<:DecisionTree}\n    info::NamedTuple\nend\n\nSee also ConstrainedModel, MixedSymbolicModel, DecisionList, DecisionTree.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.DecisionList","page":"Full reference","title":"SoleModels.DecisionList","text":"struct DecisionList{\n    O,\n    A<:Formula,\n    FM<:AbstractModel\n} <: ConstrainedModel{O,FM}\n    rulebase::Vector{Rule{_O,_C,_FM} where {_O<:O,_C<:A,_FM<:FM}}\n    defaultconsequent::FM\n    info::NamedTuple\nend\n\nA DecisionList (or decision table, or rule-based model) is a symbolic model that has the semantics of an IF-ELSEIF-ELSE block:\n\nIF (antecedent_1)     THEN (consequent_1)\nELSEIF (antecedent_2) THEN (consequent_2)\n...\nELSEIF (antecedent_n) THEN (consequent_n)\nELSE (consequent_default) END\n\nwhere the antecedents are formulas to be, and the consequents are the feasible local outcomes of the block. Using the classical semantics, the antecedents are evaluated in order, and a consequent is returned as soon as a valid antecedent is found, or when the computation reaches the ELSE clause.\n\nNote that FM refers to the Feasible Models (FM) allowed in the model's sub-tree.\n\nSee also Rule, ConstrainedModel, DecisionTree, AbstractModel.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.DecisionTree","page":"Full reference","title":"SoleModels.DecisionTree","text":"A DecisionTree is a symbolic model that operates as a nested structure of IF-THEN-ELSE blocks:\n\nIF (antecedent_1) THEN\n    IF (antecedent_2) THEN\n        (consequent_1)\n    ELSE\n        (consequent_2)\n    END\nELSE\n    IF (antecedent_3) THEN\n        (consequent_3)\n    ELSE\n        (consequent_4)\n    END\nEND\n\nwhere the antecedents are formulas to be, and the consequents are the feasible local outcomes of the block.\n\nIn practice, a DecisionTree simply wraps a constrained sub-tree of Branch and LeafModel:\n\nstruct DecisionTree{\nO,\n    A<:Formula,\n    FFM<:LeafModel\n} <: ConstrainedModel{O,Union{<:Branch{<:O,<:A},<:FFM}}\n    root::M where {M<:Union{FFM,Branch}}\n    info::NamedTuple\nend\n\nNote that FM refers to the Feasible Models (FM) allowed in the model's sub-tree. Also note that this structure also includes an info::NamedTuple for storing additional information.\n\nSee also ConstrainedModel, MixedSymbolicModel, DecisionList.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ExistentialTopFormula","page":"Full reference","title":"SoleModels.ExistentialTopFormula","text":"Templated formula for ⟨R⟩⊤.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ExplicitBooleanLogiset","page":"Full reference","title":"SoleModels.ExplicitBooleanLogiset","text":"struct ExplicitBooleanLogiset{\n    W<:AbstractWorld,\n    FT<:AbstractFeature,\n    FR<:AbstractFrame{W},\n} <: AbstractLogiset{W,Bool,FT,FR}\n\n    d :: Vector{Tuple{Dict{W,Vector{FT}},FR}}\n\nend\n\nA logiset where the features are boolean, and where each instance associates to each world the set of features with true.\n\nSee also AbstractLogiset.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ExplicitFeature","page":"Full reference","title":"SoleModels.ExplicitFeature","text":"struct ExplicitFeature{T} <: AbstractFeature\n    name::String\n    featstruct\nend\n\nA feature encoded explicitly, for example, as a slice of DimensionalDatasets.UniformFullDimensionalLogiset's feature structure.\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ExplicitLogiset","page":"Full reference","title":"SoleModels.ExplicitLogiset","text":"struct ExplicitLogiset{\n    W<:AbstractWorld,\n    U,\n    FT<:AbstractFeature,\n    FR<:AbstractFrame{W},\n} <: AbstractLogiset{W,U,FT,FR}\n\n    d :: Vector{Tuple{Dict{W,Dict{FT,U}},FR}}\n\nend\n\nA logiset where the features are boolean, and where each instance associates to each world the set of features with true.\n\nSee also AbstractLogiset.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.Feature","page":"Full reference","title":"SoleModels.Feature","text":"struct Feature{A} <: AbstractFeature\n    atom::A\nend\n\nA feature solely identified by an atom (e.g., a string with its name, a tuple of strings, etc.)\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.FullMemoset","page":"Full reference","title":"SoleModels.FullMemoset","text":"A generic, full memoization structure that works for any crisp logic; For each instance of a dataset, this structure associates formulas to the set of worlds where the formula holds; it was introduced by Emerson-Clarke for the well-known model checking algorithm for CTL*.\n\nSee also SupportedLogiset, AbstractMemoset, AbstractLogiset.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.FunctionModel","page":"Full reference","title":"SoleModels.FunctionModel","text":"struct FunctionModel{O} <: LeafModel{O}\n    f::FunctionWrapper{O}\n    info::NamedTuple\nend\n\nA FunctionModel is a LeafModel that applies a native Julia Function in order to compute the outcome. Over efficiency concerns, it is mandatory to make explicit the output type O by wrapping the Function into an object of type FunctionWrapper{O} (see FunctionWrappers.\n\nSee also ConstantModel, LeafModel.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.FunctionalCondition","page":"Full reference","title":"SoleModels.FunctionalCondition","text":"struct FunctionalCondition{FT<:AbstractFeature} <: AbstractCondition{FT}\n    feature::FT\n    f::FT\nend\n\nA condition which yields a truth value equal to the value of a function.\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.LeafModel","page":"Full reference","title":"SoleModels.LeafModel","text":"abstract type LeafModel{O} <: AbstractModel{O} end\n\nAbstract type for leaf models, that is, models which outcomes do not depend other models, and represents the bottom of the computation. In general, an AbstractModel can generally wrap other AbstractModels; in such case, the outcome can depend on the inner models being applied on the instance object. Otherwise, the model is considered as a leaf, or final, and is the leaf of a tree of AbstractModels.\n\nSee also ConstantModel, FunctionModel, AbstractModel.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.MixedSymbolicModel","page":"Full reference","title":"SoleModels.MixedSymbolicModel","text":"A MixedSymbolicModel is a symbolic model that operaters as a free nested structure of IF-THEN-ELSE and IF-ELSEIF-ELSE blocks:\n\nIF (antecedent_1) THEN\n    IF (antecedent_1)     THEN (consequent_1)\n    ELSEIF (antecedent_2) THEN (consequent_2)\n    ELSE (consequent_1_default) END\nELSE\n    IF (antecedent_3) THEN\n        (consequent_3)\n    ELSE\n        (consequent_4)\n    END\nEND\n\nwhere the antecedents are formulas to be checked, and the consequents are the feasible local outcomes of the block.\n\nIn Sole.jl, this logic can implemented using ConstrainedModels such as Rules, Branchs, DecisionLists, DecisionTrees, and the be wrapped into a MixedSymbolicModel:\n\nstruct MixedSymbolicModel{O,FM<:AbstractModel} <: ConstrainedModel{O,FM}\n    root::M where {M<:Union{LeafModel{<:O},ConstrainedModel{<:O,<:FM}}}\n    info::NamedTuple\nend\n\nNote that FM refers to the Feasible Models (FM) allowed in the model's sub-tree.\n\nSee also ConstrainedModel, DecisionTree, DecisionList.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.MultiFormula","page":"Full reference","title":"SoleModels.MultiFormula","text":"struct MultiFormula{F<:Formula} <: AbstractSyntaxStructure\n    modforms::Dict{Int,F}\nend\n\nA symbolic antecedent that can be checked on a MultiLogiset, associating antecedents to modalities.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.MultiLogiset","page":"Full reference","title":"SoleModels.MultiLogiset","text":"struct MultiLogiset{L<:AbstractLogiset}\n    modalities  :: Vector{L}\nend\n\nA logical dataset composed of different modalities); this structure is useful for representing multimodal datasets in logical terms.\n\nSee also AbstractLogiset, minify.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.MultivariateFeature","page":"Full reference","title":"SoleModels.MultivariateFeature","text":"struct MultivariateFeature{U} <: VarFeature\n    f::Function\nend\n\nA dimensional feature represented by the application of a function to a dimensional channel. For example, it can wrap a scalar function computing how much a Interval2D world, when interpreted on an image, resembles a horse. Note that the image has a number of spatial variables (3, for the case of RGB), and \"resembling a horse\" may require a computation involving all variables.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.RLabel","page":"Full reference","title":"SoleModels.RLabel","text":"const CLabel  = Union{String,Integer,CategoricalValue}\nconst RLabel  = AbstractFloat\nconst Label   = Union{CLabel,RLabel}\n\nTypes for supervised machine learning labels (classification and regression).\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.Rule","page":"Full reference","title":"SoleModels.Rule","text":"struct Rule{\n    O,\n    A<:Formula,\n    FM<:AbstractModel\n} <: ConstrainedModel{O,FM}\n    antecedent::A\n    consequent::FM\n    info::NamedTuple\nend\n\nA Rule is one of the fundamental building blocks of symbolic modeling, and has the semantics:\n\nIF (antecedent) THEN (consequent) END\n\nwhere the antecedent is a formula to be checked, and the consequent is the local outcome of the block.\n\nNote that FM refers to the Feasible Models (FM) allowed in the model's sub-tree.\n\nSee also antecedent, consequent, SoleLogics.Formula, ConstrainedModel, AbstractModel.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ScalarChainedMemoset","page":"Full reference","title":"SoleModels.ScalarChainedMemoset","text":"A full memoization structure used for checking formulas of scalar conditions on datasets with scalar features. This structure is the equivalent to FullMemoset, but with scalar features some important optimizations can be done.\n\nSee also FullMemoset, SupportedLogiset, AbstractLogiset.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ScalarCondition","page":"Full reference","title":"SoleModels.ScalarCondition","text":"struct ScalarCondition{U,FT,M<:ScalarMetaCondition{FT}} <: AbstractCondition{FT}\n    metacond::M\n    a::U\nend\n\nA scalar condition comparing a computed feature value (see ScalarMetaCondition) and a threshold value a. It can be evaluated on a world of an instance of a logical dataset.\n\nFor example: minV1  10, which translates to \"Within this world, the minimum of variable 1 is greater or equal than 10.\" In this case, the feature a UnivariateMin object.\n\nSee also AbstractCondition, ScalarMetaCondition.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ScalarExistentialFormula","page":"Full reference","title":"SoleModels.ScalarExistentialFormula","text":"Templated formula for ⟨R⟩ f ⋈ t.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ScalarFormula","page":"Full reference","title":"SoleModels.ScalarFormula","text":"Abstract type for templated formulas on scalar conditions.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ScalarMetaCondition","page":"Full reference","title":"SoleModels.ScalarMetaCondition","text":"struct ScalarMetaCondition{FT<:AbstractFeature,O<:TestOperator} <: AbstractCondition{FT}\n    feature::FT\n    test_operator::O\nend\n\nA metacondition representing a scalar comparison method. Here, the feature is a scalar function that can be computed on a world of an instance of a logical dataset. A test operator is a binary mathematical relation, comparing the computed feature value and an external threshold value (see ScalarCondition). A metacondition can also be used for representing the infinite set of conditions that arise with a free threshold (see UnboundedScalarConditions): minV1  a a  ℝ.\n\nSee also AbstractCondition, ScalarCondition.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ScalarOneStepMemoset","page":"Full reference","title":"SoleModels.ScalarOneStepMemoset","text":"One-step memoization structures for optimized check of formulas of type ⟨R⟩p, where p wraps a scalar condition, such as MyFeature ≥ 10. With such formulas, scalar one-step optimization can be performed.\n\nFor example, checking ⟨R⟩(MyFeature ≥ 10) on a world w of a Kripke structure involves comparing the maximum MyFeature across ws accessible worlds with 10; but the same maximum value can be reused to check sibling formulas such as ⟨R⟩(MyFeature ≥ 100). This sparks the idea of storing and reusing scalar aggregations (e.g., minimum/maximum) over the feature values. Each value refers to a specific world, and an object of type ⟨R⟩(f ⋈ ?), called a \"scalar metacondition\".\n\nSimilar cases arise depending on the relation and the test operator (or, better, its aggregator), and further optimizations can be applied for specific feature types (see representatives).\n\nAn immediate special case, however, arises when R is the global relation G since, in such case, a single aggregate value is enough for all worlds within the Kripke structure. Therefore, we differentiate between generic, relational memosets (see AbstractScalarOneStepRelationalMemoset), and global memosets (see AbstractScalarOneStepGlobalMemoset), which are usually much smaller.\n\nGiven a logiset X, a ScalarOneStepMemoset covers a set of relations and metaconditions, and it holds both a relational and a global memoset. It can be instantiated via:\n\nScalarOneStepMemoset(\n    X                       :: AbstractLogiset{W,U},\n    metaconditions          :: AbstractVector{<:ScalarMetaCondition},\n    relations               :: AbstractVector{<:AbstractRelation};\n    precompute_globmemoset  :: Bool = true,\n    precompute_relmemoset   :: Bool = false,\n    print_progress          :: Bool = false,\n)\n\nIf precompute_relmemoset is false, then the relational memoset is simply initialized as an empty structure, and memoization is performed on it upon checking formulas. precompute_globmemoset works similarly.\n\nSee SupportedLogiset, ScalarMetaCondition, AbstractOneStepMemoset.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ScalarOneStepRelationalMemoset","page":"Full reference","title":"SoleModels.ScalarOneStepRelationalMemoset","text":"A generic, one-step memoization structure used for checking specific formulas of scalar conditions on datasets with scalar features. The formulas are of type ⟨R⟩ (f ⋈ t)\n\nSee also AbstractScalarOneStepRelationalMemoset, FullMemoset, SupportedLogiset.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ScalarPropositionFormula","page":"Full reference","title":"SoleModels.ScalarPropositionFormula","text":"Templated formula for f ⋈ t.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ScalarUniversalFormula","page":"Full reference","title":"SoleModels.ScalarUniversalFormula","text":"Templated formula for [R] f ⋈ t.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.SupportedLogiset","page":"Full reference","title":"SoleModels.SupportedLogiset","text":"A logiset, associated to a number of cascading full or one-step memoization structures, that are used for optimizing the checking of formulas.\n\nSee also SupportedLogiset, AbstractFullMemoset, AbstractOneStepMemoset, AbstractLogiset.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.TestOperator","page":"Full reference","title":"SoleModels.TestOperator","text":"const TestOperator = Function\n\nA test operator is a binary Julia Function used for comparing a feature value and a threshold. In a crisp (i.e., boolean, non-fuzzy) setting, the test operator returns a Boolean value, and <, >, ≥, ≤, !=, and == are typically used.\n\nSee also Aggregator, ScalarCondition.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.UnboundedScalarConditions","page":"Full reference","title":"SoleModels.UnboundedScalarConditions","text":"struct UnboundedScalarConditions{C<:ScalarCondition} <: AbstractConditionalAlphabet{C}\n    metaconditions::Vector{<:ScalarMetaCondition}\nend\n\nAn infinite alphabet of conditions induced from a finite set of metaconditions. For example, if metaconditions = [ScalarMetaCondition(UnivariateMin(1), ≥)], the alphabet represents the (infinite) set: minV1  a a  ℝ.\n\nSee also BoundedScalarConditions, ScalarCondition, ScalarMetaCondition.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.UnivariateFeature","page":"Full reference","title":"SoleModels.UnivariateFeature","text":"struct UnivariateFeature{U} <: AbstractUnivariateFeature\n    i_variable::Integer\n    f::Function\nend\n\nA dimensional feature represented by the application of a generic function f to a single variable of a dimensional channel. For example, it can wrap a scalar function computing how much red a Interval2D world, when interpreted on an image, contains.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.UnivariateMax","page":"Full reference","title":"SoleModels.UnivariateMax","text":"struct UnivariateMax <: AbstractUnivariateFeature\n    i_variable::Integer\nend\n\nNotable univariate feature computing the maximum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, UnivariateMin, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.UnivariateMin","page":"Full reference","title":"SoleModels.UnivariateMin","text":"struct UnivariateMin <: AbstractUnivariateFeature\n    i_variable::Integer\nend\n\nNotable univariate feature computing the minimum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, UnivariateMax, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.UnivariateNamedFeature","page":"Full reference","title":"SoleModels.UnivariateNamedFeature","text":"struct UnivariateNamedFeature{U} <: AbstractUnivariateFeature\n    i_variable::Integer\n    name::String\nend\n\nA univariate feature solely identified by its name and reference variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.UnivariateSoftMax","page":"Full reference","title":"SoleModels.UnivariateSoftMax","text":"struct UnivariateSoftMax{T<:AbstractFloat} <: AbstractUnivariateFeature\n    i_variable::Integer\n    alpha::T\nend\n\nUnivariate feature computing a \"softened\" version of the maximum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, UnivariateMax, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.UnivariateSoftMin","page":"Full reference","title":"SoleModels.UnivariateSoftMin","text":"struct UnivariateSoftMin{T<:AbstractFloat} <: AbstractUnivariateFeature\n    i_variable::Integer\n    alpha::T\nend\n\nUnivariate feature computing a \"softened\" version of the minimum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, UnivariateMin, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.UnivariateValue","page":"Full reference","title":"SoleModels.UnivariateValue","text":"struct UnivariateValue <: AbstractUnivariateFeature\n    i_variable::Integer\nend\n\nSimply the value of a scalar variable (propositional case, when the frame has a single world).\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, UnivariateMax, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.UniversalBotFormula","page":"Full reference","title":"SoleModels.UniversalBotFormula","text":"Templated formula for [R]⊥.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.ValueCondition","page":"Full reference","title":"SoleModels.ValueCondition","text":"struct ValueCondition{FT<:AbstractFeature} <: AbstractCondition{FT}\n    feature::FT\nend\n\nA condition which yields a truth value equal to the value of a feature.\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.VarFeature","page":"Full reference","title":"SoleModels.VarFeature","text":"abstract type VarFeature <: AbstractFeature end\n\nAbstract type for feature functions that can be computed on (multi)variate data. Instances of multivariate datasets have values for a number of variables, which can be used to define logical features.\n\nFor example, with dimensional data (e.g., multivariate time series, digital images and videos), features can be computed as the minimum value for a given variable on a specific interval/rectangle/cuboid (in general, a `SoleLogics.GeometricalWorld).\n\nAs an example of a dimensional feature, consider min[V1], which computes the minimum for variable 1 for a given world. ScalarConditions such as min[V1] >= 10 can be, then, evaluated on worlds.\n\nSee also scalarlogiset, featvaltype, computefeature, SoleLogics.Interval.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#Base.isopen-Tuple{SoleModels.AbstractModel}","page":"Full reference","title":"Base.isopen","text":"isopen(::AbstractModel)::Bool\n\nReturn whether a model is open. An AbstractModel{O} is closed if it is always able to provide an outcome of type O. Otherwise, the model can output nothing values and is referred to as open.\n\nRule is an example of an open model, while Branch is an example of closed model.\n\nSee also AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.rand-Tuple{Random.AbstractRNG, SoleModels.BoundedScalarConditions}","page":"Full reference","title":"Base.rand","text":"Base.rand(\n    rng::AbstractRNG,\n    a::BoundedScalarConditions;\n    metaconditions::Union{Nothing,ScalarMetaCondition,AbstractVector{<:ScalarMetaCondition}} = nothing,\n    feature::Union{Nothing,AbstractFeature,AbstractVector{<:AbstractFeature}} = nothing,\n    test_operator::Union{Nothing,TestOperator,AbstractVector{<:TestOperator}} = nothing,\n)::Atom\n\nRandomly sample an Atom holding a ScalarCondition from conditional alphabet a, such that:\n\nif metaconditions are specified, then the set of metaconditions (feature-operator pairs)\n\nis limited to metaconditions;\n\nif feature is specified, then the set of metaconditions (feature-operator pairs)\n\nis limited to those with feature;\n\nif test_operator is specified, then the set of metaconditions (feature-operator pairs)\n\nis limited to those with test_operator.\n\nSee also BoundedScalarConditions, ScalarCondition, ScalarMetaCondition, SoleLogics.AbstractAlphabet.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.antecedent-Tuple{Rule}","page":"Full reference","title":"SoleModels.antecedent","text":"antecedent(m::Union{Rule,Branch})::Formula\n\nReturn the antecedent of a rule/branch, that is, the formula to be checked upon applying the model.\n\nSee also apply, consequent, checkantecedent, Rule, Branch.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}","page":"Full reference","title":"SoleModels.apply","text":"apply(\n    m::AbstractModel,\n    i::AbstractInterpretation;\n    check_args::Tuple = (),\n    check_kwargs::NamedTuple = (;),\n    functional_args::Tuple = (),\n    functional_kwargs::NamedTuple = (;),\n    kwargs...\n)::outputtype(m)\n\napply(\n    m::AbstractModel,\n    d::AbstractInterpretationSet;\n    check_args::Tuple = (),\n    check_kwargs::NamedTuple = (;),\n    functional_args::Tuple = (),\n    functional_kwargs::NamedTuple = (;),\n    kwargs...\n)::AbstractVector{<:outputtype(m)}\n\nReturn the output prediction of the model on an instance, or on each instance of a dataset. The predictions can be nothing if the model is open.\n\ncheck_args and check_kwargs can influence check's behavior at the time of its computation (see `SoleLogics.check)\n\nfunctional_args and functional_kwargs can influence FunctionModel's behavior when the corresponding function is applied to AbstractInterpretation (see FunctionModel, `SoleLogics.AbstractInterpretation)\n\nSee also isopen, outcometype, outputtype, AbstractModel, SoleLogics.AbstractInterpretation, SoleLogics.AbstractInterpretationSet.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.apply_test_operator-Union{Tuple{T2}, Tuple{T1}, Tuple{Function, T1, T2}} where {T1, T2}","page":"Full reference","title":"SoleModels.apply_test_operator","text":"Apply a test operator by simply passing the feature value and threshold to the (binary) test operator function.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.balanced_weights-Union{Tuple{AbstractVector{L}}, Tuple{L}} where L<:Union{Integer, String, CategoricalArrays.CategoricalValue}","page":"Full reference","title":"SoleModels.balanced_weights","text":"default_weights(Y::AbstractVector{L}) where {L<:CLabel}::AbstractVector{<:Number}\n\nReturn a class-rebalancing weight vector, given a label vector Y.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.bestguess","page":"Full reference","title":"SoleModels.bestguess","text":"bestguess(\n    labels::AbstractVector{<:Label},\n    weights::Union{Nothing,AbstractVector} = nothing;\n    suppress_parity_warning = false,\n)\n\nReturn the best guess for a set of labels; that is, the label that best approximates the labels provided. For classification labels, this function returns the majority class; for regression labels, the average value. If no labels are provided, nothing is returned. The computation can be weighted.\n\nSee also CLabel, RLabel, Label.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#SoleModels.check_model_constraints","page":"Full reference","title":"SoleModels.check_model_constraints","text":"This function is used when constructing ConstrainedModels to check that the inner models satisfy the desired type constraints.\n\nSee also ConstrainedModel, Rule, Branch.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#SoleModels.checkantecedent","page":"Full reference","title":"SoleModels.checkantecedent","text":"checkantecedent(\n    m::Union{Rule,Branch},\n    args...;\n    kwargs...\n)\n    check(antecedent(m), args...; kwargs...)\nend\n\nSimply check the antecedent of a rule on an instance or dataset.\n\nSee also antecedent, Rule, Branch.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#SoleModels.computefeature-Tuple{VarFeature, Any}","page":"Full reference","title":"SoleModels.computefeature","text":"computefeature(f::VarFeature, featchannel; kwargs...)\n\nCompute a feature on a featchannel (i.e., world reading) of an instance.\n\nSee also VarFeature.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.computeunivariatefeature-Tuple{SoleModels.AbstractUnivariateFeature, Any}","page":"Full reference","title":"SoleModels.computeunivariatefeature","text":"computeunivariatefeature(f::AbstractUnivariateFeature, varchannel; kwargs...)\n\nCompute a feature on a variable channel (i.e., world reading) of an instance.\n\nSee also AbstractUnivariateFeature.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.consequent-Tuple{Rule}","page":"Full reference","title":"SoleModels.consequent","text":"consequent(m::Rule)::AbstractModel\n\nReturn the consequent of a rule.\n\nSee also antecedent, Rule.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.default_weights-Tuple{Integer}","page":"Full reference","title":"SoleModels.default_weights","text":"default_weights(n::Integer)::AbstractVector{<:Number}\n\nReturn a default weight vector of n values.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.displaymodel-Tuple{SoleModels.AbstractModel}","page":"Full reference","title":"SoleModels.displaymodel","text":"printmodel(io::IO, m::AbstractModel; kwargs...)\ndisplaymodel(m::AbstractModel; kwargs...)\n\nprints or returns a string representation of model m.\n\nArguments\n\nheader::Bool = true: when set to true, a header is printed, displaying\n\nthe info structure for m;\n\nshow_subtree_info::Bool = false: when set to true, the header is printed for\n\nmodels in the sub-tree of m;\n\nshow_metrics::Bool = false: when set to true, performance metrics at each point of the\n\nsubtree are shown, whenever they are available in the info structure;\n\nmax_depth::Union{Nothing,Int} = nothing: when it is an Int, models in the sub-tree\n\nwith a depth higher than max_depth are ellipsed with \"...\";\n\nsyntaxstring_kwargs::NamedTuple = (;): kwargs to be passed to syntaxstring for\n\nformatting logical formulas.\n\nSee also syntaxstring, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.evaluaterule-Union{Tuple{FM}, Tuple{A}, Tuple{O}, Tuple{Rule{O, A, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{<:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}}}} where {O, A, FM<:SoleModels.AbstractModel}","page":"Full reference","title":"SoleModels.evaluaterule","text":"evaluaterule(\n    r::Rule{O},\n    X::AbstractInterpretationSet,\n    Y::AbstractVector{L}\n) where {O,L<:Label}\n\nEvaluate the rule on a labelled dataset, and return a NamedTuple consisting of:\n\nantsat::Vector{Bool}: satsfaction of the antecedent for each instance in the dataset;\nys::Vector{Union{Nothing,O}}: rule prediction. For each instance in X:\nconsequent(rule) if the antecedent is satisfied,\nnothing otherwise.\n\nSee also Rule, SoleLogics.AbstractInterpretationSet, Label, checkantecedent.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.feasiblemodelstype-Union{Tuple{Type{M}}, Tuple{M}, Tuple{O}} where {O, M<:SoleModels.AbstractModel{O}}","page":"Full reference","title":"SoleModels.feasiblemodelstype","text":"feasiblemodelstype(m::AbstractModel)\n\nReturn a Union of the Feasible Models (FM) allowed in the sub-tree of any AbstractModel. Note that for a ConstrainedModel{O,FM<:AbstractModel}, it simply returns FM.\n\nSee also ConstrainedModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.featvaltype-Tuple{Any, VarFeature}","page":"Full reference","title":"SoleModels.featvaltype","text":"featvaltype(dataset, f::VarFeature)\n\nReturn the type of the values returned by feature f on logiseed dataset.\n\nSee also VarFeature.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.immediatesubmodels-Union{Tuple{SoleModels.AbstractModel{O}}, Tuple{O}} where O","page":"Full reference","title":"SoleModels.immediatesubmodels","text":"immediatesubmodels(m::AbstractModel)\n\nReturn the list of immediate child models. Note: if the model is a leaf model, then the returned list will be empty.\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p∧q∨r\"), \"YES\", \"NO\");\n\njulia> immediatesubmodels(branch)\n2-element Vector{SoleModels.ConstantModel{String}}:\n SoleModels.ConstantModel{String}\nYES\n\n SoleModels.ConstantModel{String}\nNO\n\njulia> branch2 = Branch(SoleLogics.parseformula(\"s→p\"), branch, 42);\n\n\njulia> printmodel.(immediatesubmodels(branch2));\nBranch\n┐ p ∧ (q ∨ r)\n├ ✔ YES\n└ ✘ NO\n\nConstantModel\n42\n\nSee also submodels, LeafModel, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.info-Tuple{SoleModels.AbstractModel}","page":"Full reference","title":"SoleModels.info","text":"info(m::AbstractModel)::NamedTuple = m.info\ninfo(m::AbstractModel, key) = m.info[key]\ninfo(m::AbstractModel, key, defaultval)\ninfo!(m::AbstractModel, key, val)\n\nReturn the info structure for model m; this structure is used for storing additional information that does not affect the model's behavior. This structure can hold, for example, information about the model's statistical performance during the learning phase.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.isminifiable-Tuple{Any}","page":"Full reference","title":"SoleModels.isminifiable","text":"isminifiable(::Any)::Bool\n\nReturn whether minification can be applied on a dataset structure. See also minify.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.issymbolic-Tuple{SoleModels.AbstractModel}","page":"Full reference","title":"SoleModels.issymbolic","text":"issymbolic(::AbstractModel)::Bool\n\nReturn whether a model is symbolic or not. A model is said to be symbolic when its application relies on checking formulas of a certain logical language (see SoleLogics.jl package) on the instance. Symbolic models provide a form of transparent and interpretable modeling, as a symbolic model can be synthethised into a set of mutually exclusive logical rules that can often be translated into natural language.\n\nExamples of purely symbolic models are Rules, Branch, DecisionLists and DecisionTrees. Examples of non-symbolic models are those encoding algebraic mathematical functions (e.g., neural networks). Note that DecisionForests are not purely symbolic, as they rely on an algebraic aggregation step.\n\nSee also apply, listrules, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.joinrules","page":"Full reference","title":"SoleModels.joinrules","text":"joinrules(rules::AbstractVector{<:Rule})::Vector{<:Rule}\n\nReturn a set of rules, with exactly one rule per different outcome from the input set of rules. For each outcome, the output rule is computed as the logical disjunction of the antecedents of the input rules for that outcome.\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p\"), Branch(SoleLogics.parseformula(\"q\"), \"YES\", \"NO\"), \"NO\")\n p\n├✔ q\n│├✔ YES\n│└✘ NO\n└✘ NO\n\n\njulia> printmodel.(listrules(branch); tree_mode = true);\n▣ p ∧ q\n└✔ YES\n\n▣ p ∧ ¬q\n└✔ NO\n\n▣ ¬p\n└✔ NO\n\njulia> printmodel.(joinrules(listrules(branch)); tree_mode = true);\n▣ (p ∧ q)\n└✔ YES\n\n▣ (p ∧ ¬q) ∨ ¬p\n└✔ NO\n\n\nSee also listrules, issymbolic, SoleLogics.DISJUNCTION, LeafModel, AbstractModel.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#SoleModels.listimmediaterules-Tuple{SoleModels.AbstractModel}","page":"Full reference","title":"SoleModels.listimmediaterules","text":"listimmediaterules(m::AbstractModel{O} where {O})::Rule{<:O}\n\nList the immediate rules equivalent to a symbolic model.\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p\"), Branch(SoleLogics.parseformula(\"q\"), \"YES\", \"NO\"), \"NO\")\n p\n├✔ q\n│├✔ YES\n│└✘ NO\n└✘ NO\n\n\njulia> printmodel.(listimmediaterules(branch); tree_mode = true);\n▣ p\n└✔ q\n ├✔ YES\n └✘ NO\n\n▣ ¬(p)\n└✔ NO\n\n\n\nSee also listrules, issymbolic, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.listrules-Tuple{SoleModels.AbstractModel}","page":"Full reference","title":"SoleModels.listrules","text":"listrules(\n    m::AbstractModel;\n    use_shortforms::Bool = true,\n    use_leftmostlinearform::Bool = false,\n    normalize::Bool = false,\n    force_syntaxtree::Bool = false,\n)::Vector{<:Rule}\n\nReturn a list of rules capturing the knowledge enclosed in symbolic model. The behavior of any symbolic model can be synthesised and represented as a set of mutually exclusive (and jointly exaustive, if the model is closed) rules, which can be useful for many purposes.\n\nThe keyword argument force_syntaxtree, when set to true, causes the logical antecedents in the returned rules to be represented as SyntaxTrees, as opposed to other syntax structure (e.g., LeftmostConjunctiveForm).\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p\"), Branch(SoleLogics.parseformula(\"q\"), \"YES\", \"NO\"), \"NO\")\n p\n├✔ q\n│├✔ YES\n│└✘ NO\n└✘ NO\n\n\njulia> printmodel.(listrules(branch); tree_mode = true);\n▣ p ∧ q\n└✔ YES\n\n▣ p ∧ ¬q\n└✔ NO\n\n▣ ¬p\n└✔ NO\n\n\nSee also listimmediaterules, SoleLogics.CONJUNCTION, joinrules, issymbolic, LeafModel, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.minify-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T<:Union{Missing, Nothing, Real}","page":"Full reference","title":"SoleModels.minify","text":"minify(dataset::D1)::Tuple{D2,Function} where {D1,D2}\n\nReturn a minified version of a dataset, as well as a backmap for reverting to the original dataset. Dataset minification remaps each scalar values in the dataset to a new value such that the overall order of the values is preserved; the output dataset is smaller in size, since it relies on values of type UInt8, UInt16, UInt32, etc.\n\nSee also isminifiable.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.naturalgrouping-Tuple{DataFrames.AbstractDataFrame}","page":"Full reference","title":"SoleModels.naturalgrouping","text":"naturalgrouping(\n    X::AbstractDataFrame;\n    allow_variable_drop = false,\n)::AbstractVector{<:AbstractVector{<:Symbol}}\n\nReturn variables grouped by their logical nature; the nature of a variable is automatically derived from its type (e.g., Real, Vector{<:Real} or Matrix{<:Real}) and frame. All instances must have the same frame (e.g., channel size/number of worlds).\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.negconsequent-Tuple{Branch}","page":"Full reference","title":"SoleModels.negconsequent","text":"negconsequent(m::Branch)::AbstractModel\n\nReturn the negative consequent of a branch; that is, the model to be applied if the antecedent evaluates to false.\n\nSee also antecedent, Branch.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.outcometype-Union{Tuple{Type{<:SoleModels.AbstractModel{O}}}, Tuple{O}} where O","page":"Full reference","title":"SoleModels.outcometype","text":"outcometype(::Type{<:AbstractModel{O}}) where {O} = O\noutcometype(m::AbstractModel) = outcometype(typeof(m))\n\nReturn the outcome type of a model (type).\n\nSee also AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.outputtype-Tuple{SoleModels.AbstractModel}","page":"Full reference","title":"SoleModels.outputtype","text":"outputtype(m::AbstractModel)\n\nReturn a supertype for the outputs obtained when applying a model. The result depends on whether the model is open or closed:\n\noutputtype(M::AbstractModel{O}) = isopen(M) ? Union{Nothing,O} : O\n\nNote that if the model is closed, then outputtype(m) is equal to outcometype(m).\n\nSee also isopen, apply, outcometype, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.parsecondition-Tuple{Type{<:SoleModels.AbstractCondition}, String}","page":"Full reference","title":"SoleModels.parsecondition","text":"parsecondition(C::Type{<:AbstractCondition}, expr::String; kwargs...)\n\nParse a condition of type C from its syntaxstring representation. Depending on C, specifying keyword arguments such as featuretype::Type{<:AbstractFeature}, and featvaltype::Type may be required or recommended.\n\nSee also parsefeature.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.parsefeature-Tuple{Type{<:AbstractFeature}, String}","page":"Full reference","title":"SoleModels.parsefeature","text":"parsefeature(FT::Type{<:AbstractFeature}, expr::String; kwargs...)\n\nParse a feature of type FT from its syntaxstring representation. Depending on FT, specifying keyword arguments such as featvaltype::Type may be required or recommended.\n\nSee also parsecondition.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.posconsequent-Tuple{Branch}","page":"Full reference","title":"SoleModels.posconsequent","text":"posconsequent(m::Branch)::AbstractModel\n\nReturn the positive consequent of a branch; that is, the model to be applied if the antecedent evaluates to true.\n\nSee also antecedent, Branch.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.printmodel-Tuple{IO, SoleModels.AbstractModel}","page":"Full reference","title":"SoleModels.printmodel","text":"printmodel(io::IO, m::AbstractModel; kwargs...)\ndisplaymodel(m::AbstractModel; kwargs...)\n\nprints or returns a string representation of model m.\n\nArguments\n\nheader::Bool = true: when set to true, a header is printed, displaying\n\nthe info structure for m;\n\nshow_subtree_info::Bool = false: when set to true, the header is printed for\n\nmodels in the sub-tree of m;\n\nshow_metrics::Bool = false: when set to true, performance metrics at each point of the\n\nsubtree are shown, whenever they are available in the info structure;\n\nmax_depth::Union{Nothing,Int} = nothing: when it is an Int, models in the sub-tree\n\nwith a depth higher than max_depth are ellipsed with \"...\";\n\nsyntaxstring_kwargs::NamedTuple = (;): kwargs to be passed to syntaxstring for\n\nformatting logical formulas.\n\nSee also syntaxstring, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.propagate_feasiblemodels-Tuple{Type{<:SoleModels.AbstractModel}}","page":"Full reference","title":"SoleModels.propagate_feasiblemodels","text":"propagate_feasiblemodels(M::Type{<:AbstractModel}) = Union{typename(M){outcometype(M)}, feasiblemodelstype(M)}\npropagate_feasiblemodels(m::AbstractModel) = propagate_feasiblemodels(typeof(m))\n\nThis function is used upon construction of a ConstrainedModel, to compute its Feasible Models (FM). In general, its FM are a Union of the FM of its immediate child models, but a trick is used in order to avoid unneccessary propagation of types throughout the model tree. Note that this trick assumes that the first type parameter of any ConstrainedModel is its outcometype O.\n\nSee also feasiblemodelstype, ConstrainedModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.readmetrics-Union{Tuple{SoleModels.LeafModel{L}}, Tuple{L}} where L<:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}","page":"Full reference","title":"SoleModels.readmetrics","text":"readmetrics(m::AbstractModel; digits = 2)\n\nReturn a NamedTuple with some performance metrics for the given symbolic model. Performance metrics can be computed when the info structure of the model has the     following keys:     - :supportinglabels     - :supportingpredictions\n\nThe digits keyword argument is used to round accuracy/confidence metrics.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.representatives-Union{Tuple{W}, Tuple{SoleLogics.AbstractFrame{W}, W, AbstractRelation, SoleModels.AbstractCondition}} where W<:AbstractWorld","page":"Full reference","title":"SoleModels.representatives","text":"representatives(\n    fr::AbstractFrame{W},\n    S::W,\n    ::AbstractRelation,\n    ::AbstractCondition\n) where {W<:AbstractWorld}\n\nReturn an iterator to the (few) representative accessible worlds that are necessary for computing and propagating truth values through existential modal connectives. When this optimization is possible (e.g., when checking specific formulas on scalar conditions), it allows to further boost \"one-step\" optimizations (see AbstractOneStepMemoset).\n\nFor example, consider a Kripke structure with a 1-dimensional FullDimensionalFrame of length 100, and the problem of checking a formula \"⟨L⟩(max[V1] ≥ 10)\" on a SoleLogics.Interval SoleLogics.Interval{Int64}(1, 2) (with L being Allen's \"Later\" relation, see SoleLogics.IA_L). Comparing 10 with the (maximum) \"max[V1]\" computed on all worlds is the naïve strategy to check the formula. However, in this case, comparing 10 to the \"max[V1]\" computed on the single Interval SoleLogics.Interval{Int64}(2, 101) suffice to establish whether the structure satisfies the formula. Similar cases arise depending on the relation, feature and test operator (or, better, its aggregator).\n\nNote that this method fallsback to accessibles.\n\nSee also SoleLogics.accessibles, ScalarCondition, SoleLogics.AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.rulemetrics-Union{Tuple{FM}, Tuple{A}, Tuple{O}, Tuple{Rule{O, A, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{<:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}}}} where {O, A, FM<:SoleModels.AbstractModel}","page":"Full reference","title":"SoleModels.rulemetrics","text":"rulemetrics(\n    r::Rule,\n    X::AbstractInterpretationSet,\n    Y::AbstractVector{<:Label}\n)\n\nCompute metrics for a rule with respect to a labelled dataset and returns a NamedTuple consisting of:\n\nsupport: number of instances satisfying the antecedent of the rule divided by   the total number of instances;\nerror:\nFor classification problems: number of instances that were not classified\ncorrectly divided by the total number of instances;\nFor regression problems: mean squared error;\nlength: number of atoms in the rule's antecedent.\n\nSee also Rule, SoleLogics.AbstractInterpretationSet, Label, evaluaterule, outcometype, consequent.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.scalarlogiset","page":"Full reference","title":"SoleModels.scalarlogiset","text":"scalarlogiset(dataset, features; kwargs...)\n\nConverts a dataset structure (with variables) to a logiset with scalar-valued features. If dataset is not a multimodal dataset, the following methods should be defined: TODO explain\n\n    islogiseed(::typeof(dataset)) = true\n    initlogiset(dataset, features)\n    ninstances(dataset)\n    nvariables(dataset)\n    frame(dataset, i_instance::Integer)\n    featvalue(dataset, i_instance::Integer, w::AbstractWorld, feature::VarFeature)\n    vareltype(dataset, i_variable::Integer)\n\nIf dataset represents a multimodal dataset, the following methods should be defined, while its modalities (iterated via eachmodality) should provide the methods above:\n\n    ismultilogiseed(dataset)\n    nmodalities(dataset)\n    eachmodality(dataset)\n\nSee also AbstractLogiset, VarFeature, ScalarCondition.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#SoleModels.submodels-Tuple{SoleModels.AbstractModel}","page":"Full reference","title":"SoleModels.submodels","text":"submodels(m::AbstractModel)\n\nEnumerate all submodels in the sub-tree. This function is the transitive closure of immediatesubmodels; in fact, the returned list includes the immediate submodels (immediatesubmodels(m)), but also their immediate submodels, and so on.\n\nExamples\n\njulia> using SoleLogics\n\njulia> branch = Branch(SoleLogics.parseformula(\"p∧q∨r\"), \"YES\", \"NO\");\n\njulia> submodels(branch)\n2-element Vector{SoleModels.ConstantModel{String}}:\n ConstantModel\nYES\n\n ConstantModel\nNO\n\n\njulia> branch2 = Branch(SoleLogics.parseformula(\"s→p\"), branch, 42);\n\njulia> printmodel.(submodels(branch2));\nBranch\n┐ p ∧ (q ∨ r)\n├ ✔ YES\n└ ✘ NO\n\nConstantModel\nYES\n\nConstantModel\nNO\n\nConstantModel\n42\n\njulia> submodels(branch) == immediatesubmodels(branch)\ntrue\n\njulia> submodels(branch2) == immediatesubmodels(branch2)\nfalse\n\nSee also immediatesubmodels, LeafModel, AbstractModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.variable_name-Tuple{SoleModels.AbstractUnivariateFeature}","page":"Full reference","title":"SoleModels.variable_name","text":"variable_name(\n    f::AbstractUnivariateFeature;\n    variable_names_map::Union{Nothing,AbstractDict,AbstractVector} = nothing,\n    variable_name_prefix::Union{Nothing,String} = \"V\",\n)::String\n\nReturn the name of the variable targeted by a univariate feature. By default, an variable name is a number prefixed by \"V\"; however, variable_names_map or variable_name_prefix can be used to customize variable names. The prefix can be customized by specifying variable_name_prefix. Alternatively, a mapping from string to integer (either via a Dictionary or a Vector) can be passed as variable_names_map. Note that only one in variable_names_map and variable_name_prefix should be provided.\n\nSee also parsecondition, ScalarCondition, syntaxstring.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.wrap-Tuple{Any, Type{<:SoleModels.AbstractModel}}","page":"Full reference","title":"SoleModels.wrap","text":"wrap(o::Any)::AbstractModel\n\nThis function wraps anything into an AbstractModel. The default behavior is the following:\n\nwhen called on an AbstractModel, the model is\n\nsimply returned (no wrapping is performed);\n\nFunctions and FunctionWrappers are wrapped into a FunctionModel;\nevery other object is wrapped into a ConstantModel.\n\nSee also ConstantModel, FunctionModel, ConstrainedModel, LeafModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#SoleModels.DimensionalDatasets.AbstractUniformFullDimensionalLogiset","page":"Full reference","title":"SoleModels.DimensionalDatasets.AbstractUniformFullDimensionalLogiset","text":"Abstract type for optimized, uniform logisets with full dimensional frames. Here, \"uniform\" refers to the fact that all instances have the same frame, and \"full\" refers to the fact that all worlds of a given kind are considered (e.g., all points/intervals/rectangles)\n\nSee also UniformFullDimensionalLogiset, `SoleLogics.FullDimensionalFrame, AbstractLogiset.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.DimensionalDatasets.AbstractUniformFullDimensionalOneStepRelationalMemoset","page":"Full reference","title":"SoleModels.DimensionalDatasets.AbstractUniformFullDimensionalOneStepRelationalMemoset","text":"Abstract type for relational memosets optimized for uniform logisets with full dimensional frames.\n\nSee also UniformFullDimensionalLogiset, AbstractScalarOneStepRelationalMemoset, `SoleLogics.FullDimensionalFrame, AbstractLogiset.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.DimensionalDatasets.UniformFullDimensionalLogiset","page":"Full reference","title":"SoleModels.DimensionalDatasets.UniformFullDimensionalLogiset","text":"Uniform scalar logiset with full dimensional frames of dimensionality N, storing values for each world in a ninstances × nfeatures array. Each world is a hyper-interval, and its N*2 components are used to index different array dimensions, ultimately resulting in a (N*2+2)-dimensional array.\n\nSee also AbstractUniformFullDimensionalLogiset, `SoleLogics.FullDimensionalFrame, AbstractLogiset.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#SoleModels.DimensionalDatasets.UniformFullDimensionalOneStepRelationalMemoset","page":"Full reference","title":"SoleModels.DimensionalDatasets.UniformFullDimensionalOneStepRelationalMemoset","text":"A relational memoset optimized for uniform scalar logisets with full dimensional frames of dimensionality N, storing values for each world in a ninstances × nmetaconditions × nrelations array. Each world is a hyper-interval, and its N*2 components are used to index different array dimensions, ultimately resulting in a (N*2+3)-dimensional array.\n\nSee also UniformFullDimensionalLogiset, `FullDimensionalFrame, AbstractLogiset.\n\n\n\n\n\n","category":"type"},{"location":"logic/","page":"Logical foundations","title":"Logical foundations","text":"CurrentModule = SoleModels","category":"page"},{"location":"logic/#Logical-foundations","page":"Logical foundations","title":"Logical foundations","text":"","category":"section"},{"location":"logic/","page":"Logical foundations","title":"Logical foundations","text":"SoleLogics lays the logical foundations for this package. While the full reference for SoleLogics can be found here, these are the basic logical concepts needed for symbolic modelling.","category":"page"},{"location":"logic/","page":"Logical foundations","title":"Logical foundations","text":"SoleLogics.Atom\nSoleLogics.CONJUNCTION\nSoleLogics.DISJUNCTION\nSoleLogics.Formula\nSoleLogics.syntaxstring\n\nSoleLogics.AbstractAlphabet\nSoleLogics.AbstractInterpretation\nSoleLogics.AbstractInterpretationSet\n\nSoleLogics.check\n\nSoleLogics.AbstractWorld\nSoleLogics.GeometricalWorld\nSoleLogics.Interval\nSoleLogics.Interval2D\n\nSoleLogics.AbstractRelation\nSoleLogics.globalrel\nSoleLogics.IA_L\n\nSoleLogics.AbstractFrame\nSoleLogics.AbstractKripkeStructure\nSoleLogics.accessibles","category":"page"},{"location":"logic/#SoleLogics.Atom","page":"Logical foundations","title":"SoleLogics.Atom","text":"struct Atom{V} <: SyntaxLeaf\n    value::V\nend\n\nAn atom, sometimes called an atomic proposition, propositional letter (or simply letter), of type Atom{V} wraps a value::V representing a fact which truth can be assessed on a logical interpretation.\n\nAtoms are nullary tokens (i.e, they are at the leaves of a syntax tree); note that their atoms cannot be Atoms.\n\nSee also AbstractInterpretation, atoms, check, SyntaxToken.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.CONJUNCTION","page":"Logical foundations","title":"SoleLogics.CONJUNCTION","text":"const CONJUNCTION = NamedConnective{:∧}()\nconst ∧ = CONJUNCTION\narity(::typeof(∧)) = 2\n\nLogical conjunction. It can be typed by \\wedge<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"logic/#SoleLogics.DISJUNCTION","page":"Logical foundations","title":"SoleLogics.DISJUNCTION","text":"const DISJUNCTION = NamedConnective{:∨}()\nconst ∨ = DISJUNCTION\narity(::typeof(∨)) = 2\n\nLogical disjunction. It can be typed by \\vee<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"logic/#SoleLogics.Formula","page":"Logical foundations","title":"SoleLogics.Formula","text":"abstract type Formula <: Syntactical end\n\nAbstract type for logical formulas. Examples of Formulas are SyntaxLeafs (for example, Atoms and Truth values), AbstractSyntaxStructures (for example, SyntaxTrees and LeftmostLinearForms) and TruthTables ( enriched representation, which associates a syntactic structure with additional memoization structures, which can save computational time upon model checking).\n\nAny formula can be converted into its SyntaxTree representation via tree; its height can be computed, and it can be queried for its syntax tokens, atoms, etc... It can be parsed from its syntaxstring representation via parseformula.\n\nSee also tree, AbstractSyntaxStructure, SyntaxLeaf.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.syntaxstring","page":"Logical foundations","title":"SoleLogics.syntaxstring","text":"syntaxstring(s::Syntactical; kwargs...)::String\n\nReturn the string representation of any syntactic object (e.g., Formula, SyntaxTree, SyntaxToken, Atom, Truth, etc). Note that this representation may introduce redundant parentheses. kwargs can be used to specify how to display syntax tokens/trees under some specific conditions.\n\nThe following kwargs are currently supported:\n\nfunction_notation = false::Bool: when set to true, it forces the use of  function notation for binary operators  (see here).\nremove_redundant_parentheses = true::Bool: when set to false, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.\nparenthesize_atoms = !remove_redundant_parentheses::Bool: when set to true,  it forces the atoms (which are the leaves of a formula's tree structure) to be  wrapped in parentheses.\n\nExamples\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"))\n\"p ∧ q ∧ r ∧ s ∧ t\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), function_notation=true)\n\"∧(∧(∧(∧(p, q), r), s), t)\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=false)\n\"((((p) ∧ (q)) ∧ (r)) ∧ (s)) ∧ (t)\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=true, parenthesize_atoms=true)\n\"(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"))\n\"◊((p ∧ s) → q)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"); function_notation = true)\n\"◊(→(∧(p, s), q))\"\n\nSee also parseformula, SyntaxBranch, SyntaxToken.\n\nImplementation\n\nIn the case of a syntax tree, syntaxstring is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the syntaxstring must be defined (including the kwargs... part!) for every newly defined SyntaxToken (e.g., SyntaxLeafs, that is, Atoms and Truth values, and Operators), in a way that it produces a unique string representation, since Base.hash and Base.isequal, at least for SyntaxTrees, rely on it.\n\nIn particular, for the case of Atoms, the function calls itself on the wrapped value:\n\nsyntaxstring(a::Atom; kwargs...) = syntaxstring(value(a); kwargs...)\n\nThe syntaxstring for any value defaults to its string representation, but it can be defined by defining the appropriate syntaxstring method.\n\nwarning: Warning\nThe syntaxstring for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon parsing. For similar reasons, syntaxstrings should not contain parentheses ('(', ')'), and, when parsing in function notation, commas (',').\n\nSee also SyntaxLeaf, Operator, parseformula.\n\n\n\n\n\n","category":"function"},{"location":"logic/#SoleLogics.AbstractAlphabet","page":"Logical foundations","title":"SoleLogics.AbstractAlphabet","text":"abstract type AbstractAlphabet{V} end\n\nAbstract type for representing an alphabet of atoms with values of type V. An alphabet (or propositional alphabet) is a set of atoms (assumed to be countable).\n\nExamples\n\njulia> Atom(1) in ExplicitAlphabet(Atom.(1:10))\ntrue\n\njulia> Atom(1) in ExplicitAlphabet(1:10)\ntrue\n\njulia> Atom(1) in AlphabetOfAny{String}()\nfalse\n\njulia> Atom(\"mystring\") in AlphabetOfAny{String}()\ntrue\n\njulia> \"mystring\" in AlphabetOfAny{String}()\n┌ Warning: Please, use Base.in(Atom(mystring), alphabet::AlphabetOfAny{String}) instead of Base.in(mystring, alphabet::AlphabetOfAny{String})\n└ @ SoleLogics ...\ntrue\n\nImplementation\n\nWhen implementing a new alphabet type MyAlphabet, you should provide a method for establishing whether an atom belongs to it or not; while, in general, this method should be:\n\nfunction Base.in(p::Atom, a::MyAlphabet)::Bool\n\nin the case of finite alphabets, it suffices to define a method:\n\nfunction atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}\n\nBy default, an alphabet is considered finite:\n\nBase.isfinite(::Type{<:AbstractAlphabet}) = true\nBase.isfinite(a::AbstractAlphabet) = Base.isfinite(typeof(a))\nBase.in(p::Atom, a::AbstractAlphabet) = Base.isfinite(a) ? Base.in(p, atoms(a)) : error(...)\n\nSee also AbstractGrammar, AlphabetOfAny, Atom, ExplicitAlphabet.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.AbstractInterpretation","page":"Logical foundations","title":"SoleLogics.AbstractInterpretation","text":"abstract type AbstractInterpretation end\n\nAbstract type for representing a logical interpretation. In the case of propositional logic, is essentially a map atom → truth value.\n\nProperties expressed via logical formulas can be checked on logical interpretations.\n\nSee also check, AbstractAssignment, AbstractKripkeStructure.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.AbstractInterpretationSet","page":"Logical foundations","title":"SoleLogics.AbstractInterpretationSet","text":"abstract type AbstractInterpretationSet{M<:AbstractInterpretation} <: AbstractDataset end\n\nAbstract type for ordered sets of interpretations. A set of interpretations, also referred to as a dataset in this context, is a collection of instances, each of which is an interpretation, and is identified by an index iinstance::Integer. These structures are especially useful when performing [model checking](https://en.wikipedia.org/wiki/Modelchecking).\n\nSee alsotruthtype, InterpretationVector.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.check","page":"Logical foundations","title":"SoleLogics.check","text":"check(\n    φ::Formula,\n    i::AbstractInterpretation,\n    args...;\n    kwargs...\n)::Bool\n\nCheck a formula on a logical interpretation (or model), returning true if the truth value for the formula istop. This process is referred to as (finite) model checking, and there are many algorithms for it, typically depending on the complexity of the logic.\n\nExamples\n\njulia> @atoms String p q\n2-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n\njulia> td = TruthDict([p => TOP, q => BOT])\nTruthDict with values:\n┌────────┬────────┐\n│      q │      p │\n│ String │ String │\n├────────┼────────┤\n│      ⊥ │      ⊤ │\n└────────┴────────┘\n\njulia> check(CONJUNCTION(p,q), td)\nfalse\n\nSee also interpret, Formula, AbstractInterpretation, TruthDict.\n\n\n\n\n\nfunction check(\n    φ::SyntaxTree,\n    i::AbstractKripkeStructure,\n    w::Union{Nothing,<:AbstractWorld} = nothing;\n    use_memo::Union{Nothing,AbstractDict{<:Formula,<:Vector{<:AbstractWorld}}} = nothing,\n    perform_normalization::Bool = true,\n    memo_max_height::Union{Nothing,Int} = nothing,\n)::Bool\n\nCheck a formula on a specific word in a KripkeStructure.\n\nExamples\n\njulia> using Graphs, Random\n\njulia> @atoms String p q\n2-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n\njulia> fmodal = randformula(Random.MersenneTwister(14), 3, [p,q], SoleLogics.BASE_MODAL_CONNECTIVES)\n¬□(p ∨ q)\n\n# A special graph, called Kripke Frame, is created.\n# Nodes are called worlds, and the edges are relations between worlds.\njulia> worlds = SoleLogics.World.(1:5) # 5 worlds are created, numerated from 1 to 5\n\njulia> edges = Edge.([(1,2), (1,3), (2,4), (3,4), (3,5)])\n\njulia> kframe = SoleLogics.ExplicitCrispUniModalFrame(worlds, Graphs.SimpleDiGraph(edges))\n\n# A valuation function establishes which fact are true on each world\njulia> valuation = Dict([\n    worlds[1] => TruthDict([p => true, q => false]),\n    worlds[2] => TruthDict([p => true, q => true]),\n    worlds[3] => TruthDict([p => true, q => false]),\n    worlds[4] => TruthDict([p => false, q => false]),\n    worlds[5] => TruthDict([p => false, q => true]),\n ])\n\n# Kripke Frame and valuation function are merged in a Kripke Structure\njulia> kstruct = KripkeStructure(kframe, valuation)\n\njulia> [w => check(fmodal, kstruct, w) for w in worlds]\n5-element Vector{Pair{SoleLogics.World{Int64}, Bool}}:\n SoleLogics.World{Int64}(1) => 0\n SoleLogics.World{Int64}(2) => 1\n SoleLogics.World{Int64}(3) => 1\n SoleLogics.World{Int64}(4) => 0\n SoleLogics.World{Int64}(5) => 0\n\nSee also SyntaxTree, AbstractWorld, KripkeStructure.\n\n\n\n\n\ncheck(\n    φ::Formula,\n    s::AbstractInterpretationSet,\n    i_instance::Integer,\n    args...;\n    kwargs...\n)::Bool\n\nCheck a formula on the i-th instance of an AbstractInterpretationSet.\n\nSee also AbstractInterpretationSet, Formula.\n\n\n\n\n\ncheck(\n    φ::Formula,\n    s::AbstractInterpretationSet,\n    args...;\n    kwargs...\n)::Vector{Bool}\n\nCheck a formula on all instances of an AbstractInterpretationSet.\n\nSee also AbstractInterpretationSet, Formula.\n\n\n\n\n\n","category":"function"},{"location":"logic/#SoleLogics.AbstractWorld","page":"Logical foundations","title":"SoleLogics.AbstractWorld","text":"abstract type AbstractWorld end\n\nAbstract type for the nodes of an annotated accessibility graph (Kripke structure). This is used, for example, in modal logic, where the truth of formulas is relativized to worlds, that is, nodes of a graph.\n\nImplementing\n\nWhen implementing a new world type, the logical semantics should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.GeometricalWorld","page":"Logical foundations","title":"SoleLogics.GeometricalWorld","text":"abstract type GeometricalWorld <: AbstractWorld end\n\nAbstract type for worlds with a geometrical interpretation.\n\nSee also Point, Interval, Interval2D, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.Interval","page":"Logical foundations","title":"SoleLogics.Interval","text":"struct Interval{T} <: GeometricalWorld\n    x :: T\n    y :: T\nend\n\nAn interval in a 1-dimensional space, with coordinates of type T.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval(1,2),1)\ntrue\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval(1,2),2)\nfalse\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5), Interval(1,2), SoleLogics.IA_L))\n6-element Vector{Interval{Int64}}:\n (3−4)\n (3−5)\n (4−5)\n (3−6)\n (4−6)\n (5−6)\n\n\n\nSee also goeswithdim, accessibles, FullDimensionalFrame, Point, Interval2D, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.Interval2D","page":"Logical foundations","title":"SoleLogics.Interval2D","text":"struct Interval2D{T} <: GeometricalWorld\n    x :: Interval{T}\n    y :: Interval{T}\nend\n\nA orthogonal rectangle in a 2-dimensional space, with coordinates of type T. This is the 2-dimensional Interval counterpart, that is, the combination of two orthogonal Intervals.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),1)\nfalse\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),2)\ntrue\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5,5), Interval2D((2,3),(2,4)), SoleLogics.IA_LL))\n3-element Vector{Interval2D{Int64}}:\n ((4−5)×(5−6))\n ((4−6)×(5−6))\n ((5−6)×(5−6))\n\n\nSee also goeswithdim, accessibles, FullDimensionalFrame, Point, Interval, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.AbstractRelation","page":"Logical foundations","title":"SoleLogics.AbstractRelation","text":"abstract type AbstractRelation end\n\nAbstract type for the relations of a multi-modal annotated accessibility graph (Kripke structure). Two noteworthy relations are identityrel and globalrel, which access the current world and all worlds, respectively.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> Interval(8,11) in (accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nWhen implementing a new relation type R, please provide the methods:\n\narity(::R)::Int = ...\nsyntaxstring(::R; kwargs...)::String = ...\n\nIf the relation is symmetric, please specify its converse relation cr with:\n\nhasconverse(::R) = true\nconverse(::R) = cr\n\nIf the relation is many-to-one or one-to-one, please flag it with:\n\nistoone(::R) = true\n\nIf the relation is reflexive or transitive, flag it with:\n\nisreflexive(::R) = true\nistransitive(::R) = true\n\nMost importantly, the logical semantics for R should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also issymmetric, isreflexive, istransitive, isgrounding, arity, syntaxstring, converse, hasconverse, istoone, identityrel, globalrel, accessibles, AbstractKripkeStructure, AbstractFrame, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.globalrel","page":"Logical foundations","title":"SoleLogics.globalrel","text":"struct GlobalRel <: AbstractRelation end;\nconst globalrel  = GlobalRel();\n\nSingleton type for the global relation. This is a binary relation via which a world accesses every other world within the frame. The relation is also symmetric, reflexive and transitive.\n\nExamples\n\njulia> syntaxstring(SoleLogics.globalrel)\n\"G\"\n\njulia> SoleLogics.converse(globalrel)\nGlobalRel()\n\nSee also identityrel, AbstractRelation, AbstractWorld, AbstractFrame. AbstractKripkeStructure,\n\n\n\n\n\n","category":"constant"},{"location":"logic/#SoleLogics.IA_L","page":"Logical foundations","title":"SoleLogics.IA_L","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"logic/#SoleLogics.AbstractFrame","page":"Logical foundations","title":"SoleLogics.AbstractFrame","text":"abstract type AbstractFrame{W<:AbstractWorld} end\n\nAbstract type for an accessibility graph (Kripke frame), that gives the topology to Kripke structures. A frame can be queried for its set of vertices (also called worlds, see allworlds), and it can be browsed via its accessibility relation(s) (see accessibles). Refer to FullDimensionalFrame as an example.\n\nSee also truthtype, , allworlds, nworlds, AbstractKripkeStructure, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.AbstractKripkeStructure","page":"Logical foundations","title":"SoleLogics.AbstractKripkeStructure","text":"abstract type AbstractKripkeStructure <: AbstractInterpretation end\n\nAbstract type for representing Kripke structures's. It comprehends a directed graph structure (Kripke frame), where nodes are referred to as worlds, and the binary relation between them is referred to as the accessibility relation. Additionally, each world is associated with a mapping from Atoms to Truth values.\n\nSee also frame, worldtype, accessibles, AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"logic/#SoleLogics.accessibles","page":"Logical foundations","title":"SoleLogics.accessibles","text":"accessibles(fr::AbstractUniModalFrame{W}, w::W)::Worlds{W} where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w.\n\nSee also AbstractWorld, AbstractUniModalFrame.\n\n\n\n\n\naccessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation\n) where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w via relation r.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> typeof(accessibles(fr, Interval(2,5), IA_L))\nBase.Generator{...}\n\njulia> typeof(accessibles(fr, globalrel))\nBase.Generator{...}\n\njulia> @assert SoleLogics.nworlds(fr) == length(collect(accessibles(fr, globalrel)))\n\njulia> typeof(accessibles(fr, Interval(2,5), identityrel))\nVector{Interval{Int64}}\n\njulia> Interval(8,11) in collect(accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nSince accessibles always returns an iterator of worlds of the same type W, the current implementation of accessibles for multi-modal frames delegates the enumeration to a lower level _accessibles function, which returns an iterator of parameter tuples that are, then, fed to the world constructor the using IterTools generators, as in:\n\nfunction accessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    IterTools.imap(W, _accessibles(fr, w, r))\nend\n\nAs such, when defining new frames, worlds, and/or relations, one should provide new methods for _accessibles. For example:\n\n_accessibles(fr::Full1DFrame, w::Interval{Int}, ::_IA_A) = zip(Iterators.repeated(w.y), w.y+1:X(fr)+1)\n\nThis pattern is generally convenient; it can, however, be bypassed, although this requires defining two additional methods in order to resolve dispatch ambiguities. When defining a new frame type FR{W}, one can resolve the ambiguities and define a custom accessibles method by providing these three methods:\n\n# access worlds through relation `r`\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    ...\nend\n\n# access current world\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::IdentityRel,\n) where {W<:AbstractWorld}\n    [w]\nend\n\n# access all worlds\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::GlobalRel,\n) where {W<:AbstractWorld}\n    allworlds(fr)\nend\n\nIn general, it should be true that collect(accessibles(fr, w, r)) isa AbstractWorlds{W}.\n\nSee also AbstractWorld, AbstractRelation, AbstractMultiModalFrame.\n\n\n\n\n\n","category":"function"}]
}
