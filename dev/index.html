<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SoleModels.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://aclai-lab.github.io/SoleModels.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SoleModels.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aclai-lab/SoleModels.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SoleModels"><a class="docs-heading-anchor" href="#SoleModels">SoleModels</a><a id="SoleModels-1"></a><a class="docs-heading-anchor-permalink" href="#SoleModels" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/aclai-lab/SoleModels.jl">SoleModels</a>.</p><ul><li><a href="#SoleModels.AbstractActiveConditionalDataset"><code>SoleModels.AbstractActiveConditionalDataset</code></a></li><li><a href="#SoleModels.AbstractBooleanCondition"><code>SoleModels.AbstractBooleanCondition</code></a></li><li><a href="#SoleModels.AbstractCondition"><code>SoleModels.AbstractCondition</code></a></li><li><a href="#SoleModels.AbstractConditionalAlphabet"><code>SoleModels.AbstractConditionalAlphabet</code></a></li><li><a href="#SoleModels.AbstractConditionalDataset"><code>SoleModels.AbstractConditionalDataset</code></a></li><li><a href="#SoleModels.AbstractFeature"><code>SoleModels.AbstractFeature</code></a></li><li><a href="#SoleModels.AbstractLogicalBooleanCondition"><code>SoleModels.AbstractLogicalBooleanCondition</code></a></li><li><a href="#SoleModels.AbstractModel"><code>SoleModels.AbstractModel</code></a></li><li><a href="#SoleModels.Branch"><code>SoleModels.Branch</code></a></li><li><a href="#SoleModels.CLabel"><code>SoleModels.CLabel</code></a></li><li><a href="#SoleModels.ConstantModel"><code>SoleModels.ConstantModel</code></a></li><li><a href="#SoleModels.ConstrainedModel"><code>SoleModels.ConstrainedModel</code></a></li><li><a href="#SoleModels.DecisionForest"><code>SoleModels.DecisionForest</code></a></li><li><a href="#SoleModels.DecisionList"><code>SoleModels.DecisionList</code></a></li><li><a href="#SoleModels.DecisionTree"><code>SoleModels.DecisionTree</code></a></li><li><a href="#SoleModels.ExternalFWDFeature"><code>SoleModels.ExternalFWDFeature</code></a></li><li><a href="#SoleModels.FeatCondition"><code>SoleModels.FeatCondition</code></a></li><li><a href="#SoleModels.FeatMetaCondition"><code>SoleModels.FeatMetaCondition</code></a></li><li><a href="#SoleModels.FinalModel"><code>SoleModels.FinalModel</code></a></li><li><a href="#SoleModels.FunctionModel"><code>SoleModels.FunctionModel</code></a></li><li><a href="#SoleModels.Label"><code>SoleModels.Label</code></a></li><li><a href="#SoleModels.LogicalTruthCondition"><code>SoleModels.LogicalTruthCondition</code></a></li><li><a href="#SoleModels.MixedSymbolicModel"><code>SoleModels.MixedSymbolicModel</code></a></li><li><a href="#SoleModels.MultiFrameConditionalDataset"><code>SoleModels.MultiFrameConditionalDataset</code></a></li><li><a href="#SoleModels.NamedFeature"><code>SoleModels.NamedFeature</code></a></li><li><a href="#SoleModels.RLabel"><code>SoleModels.RLabel</code></a></li><li><a href="#SoleModels.Rule"><code>SoleModels.Rule</code></a></li><li><a href="#SoleModels.TestOperator"><code>SoleModels.TestOperator</code></a></li><li><a href="#SoleModels.TrueCondition"><code>SoleModels.TrueCondition</code></a></li><li><a href="#SoleModels.UnboundedExplicitConditionalAlphabet"><code>SoleModels.UnboundedExplicitConditionalAlphabet</code></a></li><li><a href="#Base.isopen-Tuple{SoleModels.AbstractModel}"><code>Base.isopen</code></a></li><li><a href="#Base.rand-Tuple{Random.AbstractRNG, SoleModels.BoundedExplicitConditionalAlphabet}"><code>Base.rand</code></a></li><li><a href="#SoleModels.antecedent-Tuple{Rule}"><code>SoleModels.antecedent</code></a></li><li><a href="#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>SoleModels.apply</code></a></li><li><a href="#SoleModels.apply_test_operator-Union{Tuple{T}, Tuple{Function, T, T}} where T"><code>SoleModels.apply_test_operator</code></a></li><li><a href="#SoleModels.balanced_weights-Union{Tuple{AbstractVector{L}}, Tuple{L}} where L&lt;:Union{Integer, String}"><code>SoleModels.balanced_weights</code></a></li><li><a href="#SoleModels.bestguess"><code>SoleModels.bestguess</code></a></li><li><a href="#SoleModels.check_antecedent-Tuple{Rule, Vararg{Any}}"><code>SoleModels.check_antecedent</code></a></li><li><a href="#SoleModels.check_model_constraints"><code>SoleModels.check_model_constraints</code></a></li><li><a href="#SoleModels.computefeature-Union{Tuple{U}, Tuple{AbstractFeature{U}, Any}} where U"><code>SoleModels.computefeature</code></a></li><li><a href="#SoleModels.consequent-Tuple{Rule}"><code>SoleModels.consequent</code></a></li><li><a href="#SoleModels.default_weights-Tuple{Integer}"><code>SoleModels.default_weights</code></a></li><li><a href="#SoleModels.displaymodel-Tuple{SoleModels.AbstractModel}"><code>SoleModels.displaymodel</code></a></li><li><a href="#SoleModels.evaluaterule-Union{Tuple{FM}, Tuple{C}, Tuple{O}, Tuple{Rule{O, C, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, Integer, String}}}} where {O, C, FM&lt;:SoleModels.AbstractModel}"><code>SoleModels.evaluaterule</code></a></li><li><a href="#SoleModels.feasiblemodelstype-Union{Tuple{Type{M}}, Tuple{M}, Tuple{O}} where {O, M&lt;:SoleModels.AbstractModel{O}}"><code>SoleModels.feasiblemodelstype</code></a></li><li><a href="#SoleModels.featvaltype-Union{Tuple{Type{&lt;:AbstractFeature{U}}}, Tuple{U}} where U"><code>SoleModels.featvaltype</code></a></li><li><a href="#SoleModels.formula-Tuple{SoleModels.AbstractLogicalBooleanCondition}"><code>SoleModels.formula</code></a></li><li><a href="#SoleModels.immediatesubmodels-Union{Tuple{SoleModels.AbstractModel{O}}, Tuple{O}} where O"><code>SoleModels.immediatesubmodels</code></a></li><li><a href="#SoleModels.info-Tuple{SoleModels.AbstractModel}"><code>SoleModels.info</code></a></li><li><a href="#SoleModels.isminifiable-Tuple{Any}"><code>SoleModels.isminifiable</code></a></li><li><a href="#SoleModels.issymbolic-Tuple{SoleModels.AbstractModel}"><code>SoleModels.issymbolic</code></a></li><li><a href="#SoleModels.listimmediaterules-Tuple{SoleModels.AbstractModel}"><code>SoleModels.listimmediaterules</code></a></li><li><a href="#SoleModels.listrules-Tuple{SoleModels.AbstractModel}"><code>SoleModels.listrules</code></a></li><li><a href="#SoleModels.minify-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Union{Missing, Nothing, Real}"><code>SoleModels.minify</code></a></li><li><a href="#SoleModels.negconsequent-Tuple{Branch}"><code>SoleModels.negconsequent</code></a></li><li><a href="#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>SoleModels.outcometype</code></a></li><li><a href="#SoleModels.outputtype-Tuple{SoleModels.AbstractModel}"><code>SoleModels.outputtype</code></a></li><li><a href="#SoleModels.posconsequent-Tuple{Branch}"><code>SoleModels.posconsequent</code></a></li><li><a href="#SoleModels.printmodel-Tuple{IO, SoleModels.AbstractModel}"><code>SoleModels.printmodel</code></a></li><li><a href="#SoleModels.representatives-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame{W}, W, SoleLogics.AbstractRelation, SoleModels.FeatMetaCondition}} where W&lt;:SoleLogics.AbstractWorld"><code>SoleModels.representatives</code></a></li><li><a href="#SoleModels.rulemetrics-Union{Tuple{FM}, Tuple{C}, Tuple{O}, Tuple{Rule{O, C, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, Integer, String}}}} where {O, C, FM&lt;:SoleModels.AbstractModel}"><code>SoleModels.rulemetrics</code></a></li><li><a href="#SoleModels.submodels-Tuple{SoleModels.AbstractModel}"><code>SoleModels.submodels</code></a></li><li><a href="#SoleModels.wrap-Tuple{Any, Type{&lt;:SoleModels.AbstractModel}}"><code>SoleModels.wrap</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="SoleModels.CLabel" href="#SoleModels.CLabel"><code>SoleModels.CLabel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const CLabel  = Union{String,Integer}
const RLabel  = AbstractFloat
const Label   = Union{CLabel,RLabel}</code></pre><p>Types for supervised machine learning labels (classification and regression).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/machine-learning.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.Label" href="#SoleModels.Label"><code>SoleModels.Label</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const CLabel  = Union{String,Integer}
const RLabel  = AbstractFloat
const Label   = Union{CLabel,RLabel}</code></pre><p>Types for supervised machine learning labels (classification and regression).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/machine-learning.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.AbstractActiveConditionalDataset" href="#SoleModels.AbstractActiveConditionalDataset"><code>SoleModels.AbstractActiveConditionalDataset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractActiveConditionalDataset{
    W&lt;:AbstractWorld,
    A&lt;:AbstractCondition,
    T&lt;:TruthValue,
    FR&lt;:AbstractFrame{W,T},
} &lt;: AbstractConditionalDataset{W,A,T,FR} end</code></pre><p>Abstract type for active conditional datasets, that is, conditional datasets that can be used in machine learning algorithms (e.g., they have an alphabet, can enumerate propositions and learn formulas from).</p><p>See also <a href="#SoleModels.AbstractConditionalDataset"><code>AbstractConditionalDataset</code></a>, <a href="#SoleModels.AbstractCondition"><code>AbstractCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/conditional-datasets.jl#L64-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.AbstractBooleanCondition" href="#SoleModels.AbstractBooleanCondition"><code>SoleModels.AbstractBooleanCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractBooleanCondition end</code></pre><p>A boolean condition is a condition that evaluates to a boolean truth value (<code>true</code>/<code>false</code>), when checked on a logical interpretation.</p><p>See also <a href="#SoleModels.TrueCondition"><code>TrueCondition</code></a>, <a href="#SoleModels.LogicalTruthCondition"><code>LogicalTruthCondition</code></a>, <a href="@ref"><code>check</code></a>, <a href="@ref"><code>syntaxstring</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.AbstractCondition" href="#SoleModels.AbstractCondition"><code>SoleModels.AbstractCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractCondition end</code></pre><p>Abstract type for representing conditions that can be interpreted and evaluated on worlds of instances of a conditional dataset. In logical contexts, these are wrapped into <code>Proposition</code>s.</p><p>See also <a href="@ref"><code>Proposition</code></a>, <a href="@ref"><code>syntaxstring</code></a>, <a href="#SoleModels.FeatMetaCondition"><code>FeatMetaCondition</code></a>, <a href="#SoleModels.FeatCondition"><code>FeatCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/conditions.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.AbstractConditionalAlphabet" href="#SoleModels.AbstractConditionalAlphabet"><code>SoleModels.AbstractConditionalAlphabet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractConditionalAlphabet{C&lt;:FeatCondition} &lt;: AbstractAlphabet{C} end</code></pre><p>Abstract type for alphabets of conditions.</p><p>See also <a href="#SoleModels.FeatCondition"><code>FeatCondition</code></a>, <a href="#SoleModels.FeatMetaCondition"><code>FeatMetaCondition</code></a>, <a href="@ref"><code>AbstractAlphabet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/conditional-alphabets.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.AbstractConditionalDataset" href="#SoleModels.AbstractConditionalDataset"><code>SoleModels.AbstractConditionalDataset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractConditionalDataset{
    W&lt;:AbstractWorld,
    A&lt;:AbstractCondition,
    T&lt;:TruthValue,
    FR&lt;:AbstractFrame{W,T},
} &lt;: AbstractInterpretationSet{AbstractKripkeStructure{W,A,T,FR}} end</code></pre><p>Abstract type for conditional datasets, that is, symbolic learning datasets where each instance is a Kripke model where conditions (see <a href="#SoleModels.AbstractCondition"><code>AbstractCondition</code></a>), and logical formulas with conditional letters can be checked on worlds.</p><p>See also <a href="@ref"><code>AbstractInterpretationSet</code></a>, <a href="#SoleModels.AbstractCondition"><code>AbstractCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/conditional-datasets.jl#L7-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.AbstractFeature" href="#SoleModels.AbstractFeature"><code>SoleModels.AbstractFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractFeature{U&lt;:Real} end</code></pre><p>Abstract type for features, representing a scalar functions that can be computed on a world.</p><p>See also <a href="#SoleModels.featvaltype-Union{Tuple{Type{&lt;:AbstractFeature{U}}}, Tuple{U}} where U"><code>featvaltype</code></a>, <a href="#SoleModels.computefeature-Union{Tuple{U}, Tuple{AbstractFeature{U}, Any}} where U"><code>computefeature</code></a>, <a href="@ref"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/features.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.AbstractLogicalBooleanCondition" href="#SoleModels.AbstractLogicalBooleanCondition"><code>SoleModels.AbstractLogicalBooleanCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractLogicalBooleanCondition &lt;: AbstractBooleanCondition end</code></pre><p>A boolean condition based on a formula of a given logic, that is to be checked on a logical interpretation.</p><p>See also <a href="#SoleModels.formula-Tuple{SoleModels.AbstractLogicalBooleanCondition}"><code>formula</code></a>, <a href="@ref"><code>syntaxstring</code></a>, <a href="@ref"><code>check</code></a>, <a href="#SoleModels.AbstractBooleanCondition"><code>AbstractBooleanCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L48-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.AbstractModel" href="#SoleModels.AbstractModel"><code>SoleModels.AbstractModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractModel{O} end</code></pre><p>Abstract type for mathematical models that, given an instance object (i.e., a piece of data), output an outcome of type <code>O</code>.</p><p>See also <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="#SoleModels.Branch"><code>Branch</code></a>, <a href="#Base.isopen-Tuple{SoleModels.AbstractModel}"><code>isopen</code></a>, <a href="#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>apply</code></a>, <a href="#SoleModels.issymbolic-Tuple{SoleModels.AbstractModel}"><code>issymbolic</code></a>, <a href="#SoleModels.info-Tuple{SoleModels.AbstractModel}"><code>info</code></a>, <a href="#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>outcometype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L147-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.Branch" href="#SoleModels.Branch"><code>SoleModels.Branch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Branch{
    O,
    C&lt;:AbstractBooleanCondition,
    FM&lt;:AbstractModel
} &lt;: ConstrainedModel{O,FM}
    antecedent::C
    posconsequent::FM
    negconsequent::FM
    info::NamedTuple
end</code></pre><p>A <code>Branch</code> is one of the fundamental building blocks of symbolic modeling, and has the semantics:</p><pre><code class="nohighlight hljs">IF (antecedent) THEN (consequent_1) ELSE (consequent_2) END</code></pre><p>where the antecedent is boolean condition to be tested and the consequents are the feasible local outcomes of the block.</p><p>Note that <code>FM</code> refers to the Feasible Models (<code>FM</code>) allowed in the model&#39;s sub-tree.</p><p>See also <a href="#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="#SoleModels.posconsequent-Tuple{Branch}"><code>posconsequent</code></a>, <a href="#SoleModels.negconsequent-Tuple{Branch}"><code>negconsequent</code></a>, <a href="#SoleModels.AbstractBooleanCondition"><code>AbstractBooleanCondition</code></a>, <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L798-L827">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.ConstantModel" href="#SoleModels.ConstantModel"><code>SoleModels.ConstantModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConstantModel{O} &lt;: FinalModel{O}
    outcome::O
    info::NamedTuple
end</code></pre><p>The simplest type of model is the <code>ConstantModel</code>; it is a <code>FinalModel</code> that always outputs the same outcome.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleModels.FinalModel(2) isa SoleModels.ConstantModel

julia&gt; SoleModels.FinalModel(sum) isa SoleModels.FunctionModel
┌ Warning: Over efficiency concerns, please consider wrappingJulia Function&#39;s into FunctionWrapper{O,Tuple{SoleModels.AbstractInterpretation}} structures,where O is their return type.
└ @ SoleModels ~/.julia/dev/SoleModels/src/models/base.jl:337
true
</code></pre><p>See also <a href="#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>apply</code></a>, <a href="#SoleModels.FunctionModel"><code>FunctionModel</code></a>, <a href="#SoleModels.FinalModel"><code>FinalModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L328-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.ConstrainedModel" href="#SoleModels.ConstrainedModel"><code>SoleModels.ConstrainedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <code>AbstractModel</code> can wrap another <code>AbstractModel</code>, and use it to compute the outcome. As such, an <code>AbstractModel</code> can actually be the result of a composition of many models, and enclose a <em>tree</em> of <code>AbstractModel</code>s (with <code>FinalModel</code>s at the leaves). In order to typebound the Feasible Models (<code>FM</code>) allowed in the sub-tree, the <code>ConstrainedModel</code> type is introduced:</p><pre><code class="nohighlight hljs">abstract type ConstrainedModel{O,FM&lt;:AbstractModel} &lt;: AbstractModel{O} end</code></pre><p>For example, <code>ConstrainedModel{String, Union{Branch{String}, ConstantModel{String}}}</code> supertypes models that with <code>String</code> outcomes that make use of <code>Branch{String}</code> and <code>ConstantModel{String}</code> (essentially, a decision trees with <code>String</code>s at the leaves).</p><p>See also <a href="#SoleModels.FinalModel"><code>FinalModel</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L509-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.DecisionForest" href="#SoleModels.DecisionForest"><code>SoleModels.DecisionForest</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Decision Forest</code> is a symbolic model that wraps an ensemble of models</p><pre><code class="nohighlight hljs">struct DecisionForest{
    O,
    C&lt;:AbstractBooleanCondition,
    FFM&lt;:FinalModel
} &lt;: ConstrainedModel{O, Union{&lt;:Branch{&lt;:O,&lt;:C}, &lt;:FFM}}
    trees::Vector{&lt;:DecisionTree}
    info::NamedTuple
end</code></pre><p>See also <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.MixedSymbolicModel"><code>MixedSymbolicModel</code></a>, <a href="#SoleModels.DecisionList"><code>DecisionList</code></a>, <a href="#SoleModels.DecisionTree"><code>DecisionTree</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L1298-L1313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.DecisionList" href="#SoleModels.DecisionList"><code>SoleModels.DecisionList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DecisionList{
    O,
    C&lt;:AbstractBooleanCondition,
    FM&lt;:AbstractModel
} &lt;: ConstrainedModel{O,FM}
    rulebase::Vector{Rule{_O,_C,_FM} where {_O&lt;:O,_C&lt;:C,_FM&lt;:FM}}
    defaultconsequent::FM
    info::NamedTuple
end</code></pre><p>A <code>DecisionList</code> (or <em>decision table</em>, or <em>rule-based model</em>) is a symbolic model that has the semantics of an IF-ELSEIF-ELSE block:</p><pre><code class="nohighlight hljs">IF (antecedent_1)     THEN (consequent_1)
ELSEIF (antecedent_2) THEN (consequent_2)
...
ELSEIF (antecedent_n) THEN (consequent_n)
ELSE (consequent_default) END</code></pre><p>where the antecedents are conditions to be tested and the consequents are the feasible local outcomes of the block. Using the classical semantics, the antecedents are evaluated in order, and a consequent is returned as soon as a valid antecedent is found, or when the computation reaches the ELSE clause.</p><p>Note that <code>FM</code> refers to the Feasible Models (<code>FM</code>) allowed in the model&#39;s sub-tree.</p><p>See also <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.DecisionTree"><code>DecisionTree</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L997-L1030">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.DecisionTree" href="#SoleModels.DecisionTree"><code>SoleModels.DecisionTree</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>DecisionTree</code> is a symbolic model that operates as a nested structure of IF-THEN-ELSE blocks:</p><pre><code class="nohighlight hljs">IF (antecedent_1) THEN
    IF (antecedent_2) THEN
        (consequent_1)
    ELSE
        (consequent_2)
    END
ELSE
    IF (antecedent_3) THEN
        (consequent_3)
    ELSE
        (consequent_4)
    END
END</code></pre><p>where the antecedents are conditions to be tested and the consequents are the feasible local outcomes of the block.</p><p>In practice, a <code>DecisionTree</code> simply wraps a constrained sub-tree of <code>Branch</code> and <code>FinalModel</code>:</p><pre><code class="nohighlight hljs">struct DecisionTree{
O,
    C&lt;:AbstractBooleanCondition,
    FFM&lt;:FinalModel
} &lt;: ConstrainedModel{O, Union{&lt;:Branch{&lt;:O,&lt;:C}, &lt;:FFM}}
    root::M where {M&lt;:Union{FFM,Branch}}
    info::NamedTuple
end</code></pre><p>Note that <code>FM</code> refers to the Feasible Models (<code>FM</code>) allowed in the model&#39;s sub-tree. Also note that this structure also includes an <code>info::NamedTuple</code> for storing additional information.</p><p>See also <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.MixedSymbolicModel"><code>MixedSymbolicModel</code></a>, <a href="#SoleModels.DecisionList"><code>DecisionList</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L1193-L1231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.ExternalFWDFeature" href="#SoleModels.ExternalFWDFeature"><code>SoleModels.ExternalFWDFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExternalFWDFeature{U} &lt;: AbstractFeature{U}
    name::String
    fwd::Any
end</code></pre><p>A feature encoded explicitly as (a slice of) an FWD structure (see <code>AbstractFWD</code>).</p><p>See also <a href="@ref"><code>AbstractFWD</code></a>, <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/features.jl#L76-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.FeatCondition" href="#SoleModels.FeatCondition"><code>SoleModels.FeatCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FeatCondition{U,M&lt;:FeatMetaCondition} &lt;: AbstractCondition
    metacond::M
    a::U
end</code></pre><p>A scalar condition comparing a computed feature value (see <code>FeatMetaCondition</code>) and a threshold value <code>a</code>. It can be evaluated on a world of an instance of a conditional dataset.</p><p>Example: <span>$min(V1) ≥ 10$</span>, which translates to &quot;Within this world, the minimum of variable 1 is greater or equal than 10.&quot;</p><p>See also <a href="#SoleModels.AbstractCondition"><code>AbstractCondition</code></a>, <a href="@ref"><code>negation</code></a>, <a href="#SoleModels.FeatMetaCondition"><code>FeatMetaCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/conditions.jl#L96-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.FeatMetaCondition" href="#SoleModels.FeatMetaCondition"><code>SoleModels.FeatMetaCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FeatMetaCondition{F&lt;:AbstractFeature,O&lt;:TestOperator} &lt;: AbstractCondition
    feature::F
    test_operator::O
end</code></pre><p>A metacondition representing a scalar comparison method. A feature is a scalar function that can be computed on a world of an instance of a conditional dataset. A test operator is a binary mathematical relation, comparing the computed feature value and an external threshold value (see <code>FeatCondition</code>). A metacondition can also be used for representing the infinite set of conditions that arise with a free threshold (see <code>UnboundedExplicitConditionalAlphabet</code>): <span>${min(V1) ≥ a, a ∈ ℝ}$</span>.</p><p>See also <a href="#SoleModels.AbstractCondition"><code>AbstractCondition</code></a>, <a href="@ref"><code>negation</code></a>, <a href="#SoleModels.FeatCondition"><code>FeatCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/conditions.jl#L39-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.FinalModel" href="#SoleModels.FinalModel"><code>SoleModels.FinalModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type FinalModel{O} &lt;: AbstractModel{O} end</code></pre><p>A <code>FinalModel</code> is a model which outcomes do not depend on another model. An <code>AbstractModel</code> can generally wrap other <code>AbstractModel</code>s. In such case, the outcome can depend on the inner models being applied on the instance object. Otherwise, the model is considered final; that is, it is a leaf of a tree of <code>AbstractModel</code>s.</p><p>See also <a href="#SoleModels.ConstantModel"><code>ConstantModel</code></a>, <a href="#SoleModels.FunctionModel"><code>FunctionModel</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L316-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.FunctionModel" href="#SoleModels.FunctionModel"><code>SoleModels.FunctionModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FunctionModel{O} &lt;: FinalModel{O}
    f::FunctionWrapper{O}
    info::NamedTuple
end</code></pre><p>A <code>FunctionModel</code> is a <code>FinalModel</code> that applies a native Julia <code>Function</code> in order to compute the outcome. Over efficiency concerns, it is mandatory to make explicit the output type <code>O</code> by wrapping the <code>Function</code> into an object of type <code>FunctionWrapper{O}</code>.</p><p>TODO @Michele explain functional<em>args/functional</em>kwargs</p><p>See also <a href="#SoleModels.ConstantModel"><code>ConstantModel</code></a>, <a href="@ref"><code>FunctionWrapper</code></a>, <a href="#SoleModels.FinalModel"><code>FinalModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L389-L403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.LogicalTruthCondition" href="#SoleModels.LogicalTruthCondition"><code>SoleModels.LogicalTruthCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LogicalTruthCondition{F&lt;:AbstractFormula} &lt;: AbstractLogicalBooleanCondition
    formula::F
end</code></pre><p>A boolean condition that, on a given logical interpretation, a logical formula evaluates to the <code>top</code> of the logic&#39;s algebra.</p><p>See also <a href="#SoleModels.formula-Tuple{SoleModels.AbstractLogicalBooleanCondition}"><code>formula</code></a>, <a href="#SoleModels.AbstractLogicalBooleanCondition"><code>AbstractLogicalBooleanCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L96-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.MixedSymbolicModel" href="#SoleModels.MixedSymbolicModel"><code>SoleModels.MixedSymbolicModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>MixedSymbolicModel</code> is a symbolic model that operaters as a free nested structure of IF-THEN-ELSE and IF-ELSEIF-ELSE blocks:</p><pre><code class="nohighlight hljs">IF (antecedent_1) THEN
    IF (antecedent_1)     THEN (consequent_1)
    ELSEIF (antecedent_2) THEN (consequent_2)
    ELSE (consequent_1_default) END
ELSE
    IF (antecedent_3) THEN
        (consequent_3)
    ELSE
        (consequent_4)
    END
END</code></pre><p>where the antecedents are conditinos and the consequents are the feasible local outcomes of the block.</p><p>In Sole.jl, this logic can implemented using <code>ConstrainedModel</code>s such as <code>Rule</code>s, <code>Branch</code>s, <code>DecisionList</code>s, <code>DecisionTree</code>s, and the be wrapped into a <code>MixedSymbolicModel</code>:</p><pre><code class="nohighlight hljs">struct MixedSymbolicModel{O,FM&lt;:AbstractModel} &lt;: ConstrainedModel{O,FM}
    root::M where {M&lt;:Union{FinalModel{&lt;:O},ConstrainedModel{&lt;:O,&lt;:FM}}}
    info::NamedTuple
end</code></pre><p>Note that <code>FM</code> refers to the Feasible Models (<code>FM</code>) allowed in the model&#39;s sub-tree.</p><p>See also <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.DecisionTree"><code>DecisionTree</code></a>, <a href="#SoleModels.DecisionList"><code>DecisionList</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L1363-L1394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.MultiFrameConditionalDataset" href="#SoleModels.MultiFrameConditionalDataset"><code>SoleModels.MultiFrameConditionalDataset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MultiFrameConditionalDataset{MD&lt;:AbstractConditionalDataset}
    modalities  :: Vector{&lt;:MD}
end</code></pre><p>A multi-frame conditional dataset. This structure is useful for representing multimodal datasets in logical terms.</p><p>See also <a href="#SoleModels.AbstractConditionalDataset"><code>AbstractConditionalDataset</code></a>, <a href="#SoleModels.minify-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Union{Missing, Nothing, Real}"><code>minify</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/multi-frame-conditional-datasets.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.NamedFeature" href="#SoleModels.NamedFeature"><code>SoleModels.NamedFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NamedFeature{U} &lt;: AbstractFeature{U}
    name::String
end</code></pre><p>A feature solely identified by its name.</p><p>See also <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/features.jl#L57-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.RLabel" href="#SoleModels.RLabel"><code>SoleModels.RLabel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const CLabel  = Union{String,Integer}
const RLabel  = AbstractFloat
const Label   = Union{CLabel,RLabel}</code></pre><p>Types for supervised machine learning labels (classification and regression).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/machine-learning.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.Rule" href="#SoleModels.Rule"><code>SoleModels.Rule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Rule{
    O,
    C&lt;:AbstractBooleanCondition,
    FM&lt;:AbstractModel
} &lt;: ConstrainedModel{O,FM}
    antecedent::C
    consequent::FM
    info::NamedTuple
end</code></pre><p>A <code>Rule</code> is one of the fundamental building blocks of symbolic modeling, and has the semantics:</p><pre><code class="nohighlight hljs">IF (antecedent) THEN (consequent) END</code></pre><p>where the antecedent is a condition to be tested and the consequent is the local outcome of the block.</p><p>Note that <code>FM</code> refers to the Feasible Models (<code>FM</code>) allowed in the model&#39;s sub-tree.</p><p>See also <a href="#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="#SoleModels.consequent-Tuple{Rule}"><code>consequent</code></a>, <a href="#SoleModels.AbstractBooleanCondition"><code>AbstractBooleanCondition</code></a>, <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L600-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.TestOperator" href="#SoleModels.TestOperator"><code>SoleModels.TestOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const TestOperator = Function</code></pre><p>A test operator is a binary Julia <code>Function</code> used for comparing a feature value and a threshold. In a crisp (i.e., boolean, non-fuzzy) setting, the test operator returns a boolean value, and <code>&lt;</code>, <code>&gt;</code>, <code>≥</code>, <code>≤</code>, <code>!=</code>, and <code>==</code> are typically used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/test-operators.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.TrueCondition" href="#SoleModels.TrueCondition"><code>SoleModels.TrueCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TrueCondition &lt;: AbstractLogicalBooleanCondition end</code></pre><p>A true condition is the boolean condition that always yields <code>true</code>.</p><p>See also <a href="#SoleModels.LogicalTruthCondition"><code>LogicalTruthCondition</code></a>, <a href="#SoleModels.AbstractLogicalBooleanCondition"><code>AbstractLogicalBooleanCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L80-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.UnboundedExplicitConditionalAlphabet" href="#SoleModels.UnboundedExplicitConditionalAlphabet"><code>SoleModels.UnboundedExplicitConditionalAlphabet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UnboundedExplicitConditionalAlphabet{C&lt;:FeatCondition} &lt;: AbstractConditionalAlphabet{C}
    metaconditions::Vector{&lt;:FeatMetaCondition}
end</code></pre><p>An infinite alphabet of conditions induced from a finite set of metaconditions. For example, if <code>metaconditions = [FeatMetaCondition(UnivariateMin(1), ≥)]</code>, the alphabet represents the (infinite) set: <span>${min(V1) ≥ a, a ∈ ℝ}$</span>.</p><p>See also <a href="@ref"><code>BoundedExplicitConditionalAlphabet</code></a>, <a href="#SoleModels.FeatCondition"><code>FeatCondition</code></a>, <a href="#SoleModels.FeatMetaCondition"><code>FeatMetaCondition</code></a>, <a href="@ref"><code>AbstractAlphabet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/conditional-alphabets.jl#L14-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isopen-Tuple{SoleModels.AbstractModel}" href="#Base.isopen-Tuple{SoleModels.AbstractModel}"><code>Base.isopen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isopen(::AbstractModel)::Bool</code></pre><p>Return whether a model is open. An <code>AbstractModel{O}</code> is <em>closed</em> if it is always able to provide an outcome of type <code>O</code>. Otherwise, the model can output <code>nothing</code> values and is referred to as <em>open</em>.</p><p><a href="#SoleModels.Rule"><code>Rule</code></a> is an example of an <em>open</em> model, while <a href="#SoleModels.Branch"><code>Branch</code></a> is an example of <em>closed</em> model.</p><p>See also <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L181-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{Random.AbstractRNG, SoleModels.BoundedExplicitConditionalAlphabet}" href="#Base.rand-Tuple{Random.AbstractRNG, SoleModels.BoundedExplicitConditionalAlphabet}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Base.rand(
    rng::AbstractRNG,
    a::BoundedExplicitConditionalAlphabet;
    metaconditions::Union{Nothing,FeatMetaCondition,AbstractVector{&lt;:FeatMetaCondition}} = nothing,
    feature::Union{Nothing,AbstractFeature,AbstractVector{&lt;:AbstractFeature}} = nothing,
    test_operator::Union{Nothing,TestOperator,AbstractVector{&lt;:TestOperator}} = nothing,
)::Proposition</code></pre><p>Randomly sample a <code>Proposition</code> holding a <code>FeatCondition</code> from conditional alphabet <code>a</code>, such that:</p><ul><li>if <code>metaconditions</code> are specified, then the set of metaconditions (feature-operator pairs)</li></ul><p>is limited to <code>metaconditions</code>;</p><ul><li>if <code>feature</code> is specified, then the set of metaconditions (feature-operator pairs)</li></ul><p>is limited to those with <code>feature</code>;</p><ul><li>if <code>test_operator</code> is specified, then the set of metaconditions (feature-operator pairs)</li></ul><p>is limited to those with <code>test_operator</code>.</p><p>TODO Examples</p><p>See also <a href="@ref"><code>BoundedExplicitConditionalAlphabet</code></a>, <a href="#SoleModels.FeatCondition"><code>FeatCondition</code></a>, <a href="#SoleModels.FeatMetaCondition"><code>FeatMetaCondition</code></a>, <a href="@ref">`AbstractAlphabet&#39;</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/random.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.antecedent-Tuple{Rule}" href="#SoleModels.antecedent-Tuple{Rule}"><code>SoleModels.antecedent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">antecedent(m::Union{Rule,Branch})::AbstractBooleanCondition</code></pre><p>Return the antecedent of a rule/branch; that is, the condition to be evaluated upon applying the model.</p><p>See also <a href="#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>apply</code></a>, <a href="#SoleModels.consequent-Tuple{Rule}"><code>consequent</code></a>, <a href="#SoleModels.check_antecedent-Tuple{Rule, Vararg{Any}}"><code>check_antecedent</code></a>, <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="#SoleModels.Branch"><code>Branch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L670-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}" href="#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>SoleModels.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply(
    m::AbstractModel,
    i::AbstractInterpretation;
    check_args::Tuple = (),
    check_kwargs::NamedTuple = (;),
    functional_args::Tuple = (),
    functional_kwargs::NamedTuple = (;),
    kwargs...
)::outputtype(m)

apply(
    m::AbstractModel,
    d::AbstractInterpretationSet;
    check_args::Tuple = (),
    check_kwargs::NamedTuple = (; use_memo = [ThreadSafeDict{SyntaxTree,WorldSet{worldtype(d)}}() for i in 1:ninstances(d)]),
    functional_args::Tuple = (),
    functional_kwargs::NamedTuple = (;),
    kwargs...
)::AbstractVector{&lt;:outputtype(m)}</code></pre><p>Return the output prediction of the model on an instance, or on each instance of a dataset. The predictions can be <code>nothing</code> if the model is <em>open</em>.</p><p><code>check_args</code> and <code>check_kwargs</code> can influence check&#39;s behavior at the time of its computation (see <a href="@ref"><code>check</code></a>)</p><p><code>functional_args</code> and <code>functional_kwargs</code> can influence FunctionModel&#39;s behavior when the corresponding function is applied to AbstractInterpretation (see <a href="#SoleModels.FunctionModel"><code>FunctionModel</code></a>, <a href="@ref"><code>AbstractInterpretation</code></a>)</p><p>See also <a href="#Base.isopen-Tuple{SoleModels.AbstractModel}"><code>isopen</code></a>, <a href="#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>outcometype</code></a>, <a href="#SoleModels.outputtype-Tuple{SoleModels.AbstractModel}"><code>outputtype</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>, <a href="@ref"><code>AbstractInterpretation</code></a>, <a href="@ref"><code>AbstractInterpretationSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L213-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.apply_test_operator-Union{Tuple{T}, Tuple{Function, T, T}} where T" href="#SoleModels.apply_test_operator-Union{Tuple{T}, Tuple{Function, T, T}} where T"><code>SoleModels.apply_test_operator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a test operator by simply passing the feature value and threshold to the (binary) test operator function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/test-operators.jl#L15-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.balanced_weights-Union{Tuple{AbstractVector{L}}, Tuple{L}} where L&lt;:Union{Integer, String}" href="#SoleModels.balanced_weights-Union{Tuple{AbstractVector{L}}, Tuple{L}} where L&lt;:Union{Integer, String}"><code>SoleModels.balanced_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_weights(Y::AbstractVector{L}) where {L&lt;:CLabel}::AbstractVector{&lt;:Number}</code></pre><p>Return a class-rebalancing weight vector, given a label vector <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/machine-learning.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.bestguess" href="#SoleModels.bestguess"><code>SoleModels.bestguess</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bestguess(
    labels::AbstractVector{&lt;:Label},
    weights::Union{Nothing,AbstractVector} = nothing;
    suppress_parity_warning = false,
)</code></pre><p>Return the best guess for a set of labels; that is, the label that best approximates the labels provided. For classification labels, this function returns the majority class; for regression labels, the average value. If no labels are provided, <code>nothing</code> is returned. The computation can be weighted.</p><p>See also <a href="#SoleModels.CLabel"><code>CLabel</code></a>, <a href="#SoleModels.RLabel"><code>RLabel</code></a>, <a href="#SoleModels.Label"><code>Label</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/machine-learning.jl#L47-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.check_antecedent-Tuple{Rule, Vararg{Any}}" href="#SoleModels.check_antecedent-Tuple{Rule, Vararg{Any}}"><code>SoleModels.check_antecedent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function check_antecedent(
    m::Union{Rule,Branch},
    args...;
    kwargs...
)
    check(antecedent(m), id, args...; kwargs...)
end</code></pre><p>Simply checks the antecedent of a rule on an instance or dataset.</p><p>See also <a href="#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="#SoleModels.Branch"><code>Branch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L701-L716">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.check_model_constraints" href="#SoleModels.check_model_constraints"><code>SoleModels.check_model_constraints</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This function is used when constructing <code>ConstrainedModel</code>s to check that the inner models satisfy the desired type constraints.</p><p>See also <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="#SoleModels.Branch"><code>Branch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L559-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.computefeature-Union{Tuple{U}, Tuple{AbstractFeature{U}, Any}} where U" href="#SoleModels.computefeature-Union{Tuple{U}, Tuple{AbstractFeature{U}, Any}} where U"><code>SoleModels.computefeature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computefeature(f::AbstractFeature{U}, channel; kwargs...)::U where {U}</code></pre><p>Compute a feature on a channel of an instance.</p><p>See also <a href="#SoleModels.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/features.jl#L28-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.consequent-Tuple{Rule}" href="#SoleModels.consequent-Tuple{Rule}"><code>SoleModels.consequent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">consequent(m::Rule)::AbstractModel</code></pre><p>Return the consequent of a rule.</p><p>See also <a href="#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="#SoleModels.Rule"><code>Rule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L685-L693">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.default_weights-Tuple{Integer}" href="#SoleModels.default_weights-Tuple{Integer}"><code>SoleModels.default_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_weights(n::Integer)::AbstractVector{&lt;:Number}</code></pre><p>Return a default weight vector of <code>n</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/machine-learning.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.displaymodel-Tuple{SoleModels.AbstractModel}" href="#SoleModels.displaymodel-Tuple{SoleModels.AbstractModel}"><code>SoleModels.displaymodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printmodel(io::IO, m::AbstractModel; kwargs...)
displaymodel(m::AbstractModel; kwargs...)</code></pre><p>prints or returns a string representation of model <code>m</code>.</p><p><strong>Arguments</strong></p><ul><li><code>header::Bool = true</code>: when set to <code>true</code>, a header is printed, displaying</li></ul><p>the <code>info</code> structure for <code>m</code>;</p><ul><li><code>show_subtree_info::Bool = false</code>: when set to <code>true</code>, the header is printed for</li></ul><p>models in the sub-tree of <code>m</code>;</p><ul><li><code>max_depth::Union{Nothing,Int} = nothing</code>: when it is an <code>Int</code>, models in the sub-tree</li></ul><p>with a depth higher than <code>max_depth</code> are ellipsed with &quot;...&quot;;</p><ul><li><code>syntaxstring_kwargs::NamedTuple = (;)</code>: kwargs to be passed to <code>syntaxstring</code> for</li></ul><p>formatting logical formulas.</p><p>See also <a href="@ref"><code>SoleLogics.syntaxstring</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/print.jl#L50-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.evaluaterule-Union{Tuple{FM}, Tuple{C}, Tuple{O}, Tuple{Rule{O, C, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, Integer, String}}}} where {O, C, FM&lt;:SoleModels.AbstractModel}" href="#SoleModels.evaluaterule-Union{Tuple{FM}, Tuple{C}, Tuple{O}, Tuple{Rule{O, C, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, Integer, String}}}} where {O, C, FM&lt;:SoleModels.AbstractModel}"><code>SoleModels.evaluaterule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluaterule(
    r::Rule{O},
    X::AbstractInterpretationSet,
    Y::AbstractVector{L}
) where {O,L&lt;:Label}</code></pre><p>Evaluate the rule on a labelled dataset, and return a <code>NamedTuple</code> consisting of:</p><ul><li><code>antsat::Vector{Bool}</code>: satsfaction of the antecedent for each instance in the dataset;</li><li><code>ys::Vector{Union{Nothing,O}}</code>: rule prediction. For each instance in X:<ul><li><code>consequent(rule)</code> if the antecedent is satisfied,</li><li><code>nothing</code> otherwise.</li></ul></li></ul><p>See also <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="@ref"><code>AbstractInterpretationSet</code></a>, <a href="#SoleModels.Label"><code>Label</code></a>, <a href="#SoleModels.check_antecedent-Tuple{Rule, Vararg{Any}}"><code>check_antecedent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/rule-evaluation.jl#L5-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.feasiblemodelstype-Union{Tuple{Type{M}}, Tuple{M}, Tuple{O}} where {O, M&lt;:SoleModels.AbstractModel{O}}" href="#SoleModels.feasiblemodelstype-Union{Tuple{Type{M}}, Tuple{M}, Tuple{O}} where {O, M&lt;:SoleModels.AbstractModel{O}}"><code>SoleModels.feasiblemodelstype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feasiblemodelstype(m::AbstractModel)</code></pre><p>Return a <code>Union</code> of the Feasible Models (<code>FM</code>) allowed in the sub-tree of any AbstractModel. Note that for a <code>ConstrainedModel{O,FM&lt;:AbstractModel}</code>, it simply returns <code>FM</code>.</p><p>See also <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L526-L534">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.featvaltype-Union{Tuple{Type{&lt;:AbstractFeature{U}}}, Tuple{U}} where U" href="#SoleModels.featvaltype-Union{Tuple{Type{&lt;:AbstractFeature{U}}}, Tuple{U}} where U"><code>SoleModels.featvaltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">featvaltype(::Type{&lt;:AbstractFeature{U}}) where {U} = U
featvaltype(::AbstractFeature{U}) where {U} = U</code></pre><p>Return the type returned by the feature.</p><p>See also <a href="@ref"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/features.jl#L17-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.formula-Tuple{SoleModels.AbstractLogicalBooleanCondition}" href="#SoleModels.formula-Tuple{SoleModels.AbstractLogicalBooleanCondition}"><code>SoleModels.formula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">formula(c::AbstractLogicalBooleanCondition)::AbstractFormula</code></pre><p>Return the logical formula (see <a href="@ref"><code>SoleLogics</code></a> package) of a given logical boolean condition.</p><p>See also <a href="@ref"><code>syntaxstring</code></a>, <a href="#SoleModels.AbstractLogicalBooleanCondition"><code>AbstractLogicalBooleanCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L62-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.immediatesubmodels-Union{Tuple{SoleModels.AbstractModel{O}}, Tuple{O}} where O" href="#SoleModels.immediatesubmodels-Union{Tuple{SoleModels.AbstractModel{O}}, Tuple{O}} where O"><code>SoleModels.immediatesubmodels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">immediatesubmodels(m::AbstractModel)</code></pre><p>Return the list of immediate child models. Note: if the model is final, then the returned list will be empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SoleLogics

julia&gt; branch = Branch(SoleLogics.parseformula(&quot;p∧q∨r&quot;), &quot;YES&quot;, &quot;NO&quot;);

julia&gt; immediatesubmodels(branch)
2-element Vector{SoleModels.ConstantModel{String}}:
 SoleModels.ConstantModel{String}
YES

 SoleModels.ConstantModel{String}
NO

julia&gt; branch2 = Branch(SoleLogics.parseformula(&quot;s→p&quot;), branch, 42);


julia&gt; printmodel.(immediatesubmodels(branch2));
Branch
┐ p ∧ (q ∨ r)
├ ✔ YES
└ ✘ NO

ConstantModel
42</code></pre><p>See also <a href="#SoleModels.submodels-Tuple{SoleModels.AbstractModel}"><code>submodels</code></a>, <a href="#SoleModels.FinalModel"><code>FinalModel</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/symbolic-utils.jl#L6-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.info-Tuple{SoleModels.AbstractModel}" href="#SoleModels.info-Tuple{SoleModels.AbstractModel}"><code>SoleModels.info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">info(m::AbstractModel)::NamedTuple = m.info</code></pre><p>Return the <code>info</code> structure for model <code>m</code>; this structure is used for storing additional information that does not affect the model&#39;s behavior. This structure can hold, for example, information about the model&#39;s statistical performance during the learning phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L301-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.isminifiable-Tuple{Any}" href="#SoleModels.isminifiable-Tuple{Any}"><code>SoleModels.isminifiable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isminifiable(::Any)::Bool</code></pre><p>Return whether minification can be applied on a dataset structure. See also <a href="#SoleModels.minify-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Union{Missing, Nothing, Real}"><code>minify</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/minify.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.issymbolic-Tuple{SoleModels.AbstractModel}" href="#SoleModels.issymbolic-Tuple{SoleModels.AbstractModel}"><code>SoleModels.issymbolic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">issymbolic(::AbstractModel)::Bool</code></pre><p>Return whether a model is symbolic or not. A model is said to be <code>symbolic</code> when its application relies on checking formulas of a certain logical language (see <a href="@ref"><code>SoleLogics</code></a> package) on the instance. Symbolic models provide a form of transparent and interpretable modeling.</p><p>Instead, a model is said to be functional when it encodes an algebraic mathematical function (e.g., a neural network). TODO explain listrules/cascade/rules A symbolic model is one where the computation has a <em>rule-base structure</em>.</p><p>See also <a href="#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>apply</code></a>, <a href="#SoleModels.listrules-Tuple{SoleModels.AbstractModel}"><code>listrules</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L282-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.listimmediaterules-Tuple{SoleModels.AbstractModel}" href="#SoleModels.listimmediaterules-Tuple{SoleModels.AbstractModel}"><code>SoleModels.listimmediaterules</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">listimmediaterules(m::AbstractModel{O} where {O})::Rule{&lt;:O}</code></pre><p>List the immediate rules equivalent to a symbolic model.</p><p>See also <a href="#SoleModels.listrules-Tuple{SoleModels.AbstractModel}"><code>listrules</code></a>, <a href="#SoleModels.issymbolic-Tuple{SoleModels.AbstractModel}"><code>issymbolic</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/symbolic-utils.jl#L128-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.listrules-Tuple{SoleModels.AbstractModel}" href="#SoleModels.listrules-Tuple{SoleModels.AbstractModel}"><code>SoleModels.listrules</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">listrules(m::AbstractModel; force_syntaxtree::Bool = false)::Vector{&lt;:Rule}</code></pre><p>Return a list of rules capturing the knowledge enclosed in symbolic model. The behavior of a symbolic model can be extracted and represented as a set of mutually exclusive (and jointly exaustive, if the model is closed) rules, which can be useful for many purposes.</p><p>The keyword argument <code>force_syntaxtree</code>, when set to true, causes the logical antecedents in the returned rules to be represented as <code>SyntaxTree</code>s, as opposed to other syntax structure (e.g., <code>LeftmostConjunctiveForm</code>).</p><p><strong>Examples</strong></p><p><strong>TODO @Michi questi esempi non sono chiari: cosa è r2_string?</strong></p><pre><code class="language-julia-repl hljs">@test listrules(r2_string) isa Vector{&lt;:Rule}
julia&gt; print(join(displaymodel.(listrules(rule); header = false)))
┐¬(r)
└ ✔ YES

julia&gt; print(join(displaymodel.(listrules(decision_list); header = false)))
┐(r ∧ s) ∧ t
└ ✔ YES
┐¬(r)
└ ✔ YES
┐⊤
└ ✔ YES

@test listrules(rcmodel) isa Vector{&lt;:Rule}
julia&gt; print(join(displaymodel.(listrules(rule_cascade); header = false)))
┐(p ∧ (q ∨ r)) ∧ ((p ∧ (q ∨ r)) ∧ (p ∧ (q ∨ r)))
└ ✔ 1

julia&gt; print(join(displaymodel.(listrules(branch); header = false)))
┐r ∧ s
└ ✔ YES
┐r ∧ (¬(s))
└ ✔ NO
┐(¬(r)) ∧ (t ∧ q)
└ ✔ YES
┐(¬(r)) ∧ (t ∧ (¬(q)))
└ ✔ NO
┐(¬(r)) ∧ (¬(t))
└ ✔ YES

julia&gt; print(join(displaymodel.(listrules(decision_tree); header = false)))
┐r ∧ s
└ ✔ YES
┐r ∧ (¬(s))
└ ✔ NO
┐(¬(r)) ∧ (t ∧ q)
└ ✔ YES
┐(¬(r)) ∧ (t ∧ (¬(q)))
└ ✔ NO
┐(¬(r)) ∧ (¬(t))
└ ✔ YES

julia&gt; print(join(displaymodel.(listrules(mixed_symbolic_model); header = false)))
┐q
└ ✔ 2
┐¬(q)
└ ✔ 1.5</code></pre><p>See also <a href="#SoleModels.listimmediaterules-Tuple{SoleModels.AbstractModel}"><code>listimmediaterules</code></a>, <a href="#SoleModels.issymbolic-Tuple{SoleModels.AbstractModel}"><code>issymbolic</code></a>, <a href="#SoleModels.FinalModel"><code>FinalModel</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/symbolic-utils.jl#L174-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.minify-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Union{Missing, Nothing, Real}" href="#SoleModels.minify-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Union{Missing, Nothing, Real}"><code>SoleModels.minify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minify(dataset::D1)::Tuple{D2,Function} where {D1,D2}</code></pre><p>Return a <em>minified</em> version of a dataset, as well as a backmap for reverting to the original dataset. Dataset minification remaps each scalar values in the dataset to a new value such that the overall order of the values is preserved; the output dataset is smaller in size, since it relies on values of type UInt8, UInt16, UInt32, etc.</p><p>See also <a href="#SoleModels.isminifiable-Tuple{Any}"><code>isminifiable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/minify.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.negconsequent-Tuple{Branch}" href="#SoleModels.negconsequent-Tuple{Branch}"><code>SoleModels.negconsequent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">negconsequent(m::Branch)::AbstractModel</code></pre><p>Return the negative consequent of a branch; that is, the model to be applied if the antecedent evaluates to <code>false</code>.</p><p>See also <a href="#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="#SoleModels.Branch"><code>Branch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L879-L888">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O" href="#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>SoleModels.outcometype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outcometype(::Type{&lt;:AbstractModel{O}}) where {O} = O
outcometype(m::AbstractModel) = outcometype(typeof(m))</code></pre><p>Return the outcome type of a model (type).</p><p>See also <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L165-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.outputtype-Tuple{SoleModels.AbstractModel}" href="#SoleModels.outputtype-Tuple{SoleModels.AbstractModel}"><code>SoleModels.outputtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outputtype(m::AbstractModel)</code></pre><p>Return a supertype for the outputs obtained when <code>apply</code>ing a model. The result depends on whether the model is open or closed:</p><pre><code class="nohighlight hljs">outputtype(M::AbstractModel{O}) = isopen(M) ? Union{Nothing,O} : O</code></pre><p>Note that if the model is closed, then <code>outputtype(m)</code> is equal to <code>outcometype(m)</code>.</p><p>See also <a href="#Base.isopen-Tuple{SoleModels.AbstractModel}"><code>isopen</code></a>, <a href="#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>apply</code></a>, <a href="#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>outcometype</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L193-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.posconsequent-Tuple{Branch}" href="#SoleModels.posconsequent-Tuple{Branch}"><code>SoleModels.posconsequent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">posconsequent(m::Branch)::AbstractModel</code></pre><p>Return the positive consequent of a branch; that is, the model to be applied if the antecedent evaluates to <code>true</code>.</p><p>See also <a href="#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="#SoleModels.Branch"><code>Branch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L867-L876">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.printmodel-Tuple{IO, SoleModels.AbstractModel}" href="#SoleModels.printmodel-Tuple{IO, SoleModels.AbstractModel}"><code>SoleModels.printmodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printmodel(io::IO, m::AbstractModel; kwargs...)
displaymodel(m::AbstractModel; kwargs...)</code></pre><p>prints or returns a string representation of model <code>m</code>.</p><p><strong>Arguments</strong></p><ul><li><code>header::Bool = true</code>: when set to <code>true</code>, a header is printed, displaying</li></ul><p>the <code>info</code> structure for <code>m</code>;</p><ul><li><code>show_subtree_info::Bool = false</code>: when set to <code>true</code>, the header is printed for</li></ul><p>models in the sub-tree of <code>m</code>;</p><ul><li><code>max_depth::Union{Nothing,Int} = nothing</code>: when it is an <code>Int</code>, models in the sub-tree</li></ul><p>with a depth higher than <code>max_depth</code> are ellipsed with &quot;...&quot;;</p><ul><li><code>syntaxstring_kwargs::NamedTuple = (;)</code>: kwargs to be passed to <code>syntaxstring</code> for</li></ul><p>formatting logical formulas.</p><p>See also <a href="@ref"><code>SoleLogics.syntaxstring</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/print.jl#L44-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.representatives-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame{W}, W, SoleLogics.AbstractRelation, SoleModels.FeatMetaCondition}} where W&lt;:SoleLogics.AbstractWorld" href="#SoleModels.representatives-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame{W}, W, SoleLogics.AbstractRelation, SoleModels.FeatMetaCondition}} where W&lt;:SoleLogics.AbstractWorld"><code>SoleModels.representatives</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function representatives(
    fr::AbstractMultiModalFrame{W},
    S::W,
    ::AbstractRelation,
    ::FeatMetaCondition
) where {W&lt;:AbstractWorld}</code></pre><p>Return an iterator to the (few) <em>representative</em> accessible worlds that are really necessary, upon collation, for computing and propagating truth values through existential modal operators.</p><p>This allows for some optimizations when model checking specific conditional formulas. For example, it turns out that when you need to test a formula &quot;⟨L⟩ (MyFeature ≥ 10)&quot; on a world w, instead of computing &quot;MyFeature&quot; on all worlds and then maximizing, computing it on a single world is enough to decide the truth. A few cases arise depending on the relation, the feature and the test operator (or, better, its <em>aggregator</em>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/conditional-data/representatives.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.rulemetrics-Union{Tuple{FM}, Tuple{C}, Tuple{O}, Tuple{Rule{O, C, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, Integer, String}}}} where {O, C, FM&lt;:SoleModels.AbstractModel}" href="#SoleModels.rulemetrics-Union{Tuple{FM}, Tuple{C}, Tuple{O}, Tuple{Rule{O, C, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, Integer, String}}}} where {O, C, FM&lt;:SoleModels.AbstractModel}"><code>SoleModels.rulemetrics</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rulemetrics(
    r::Rule,
    X::AbstractInterpretationSet,
    Y::AbstractVector{&lt;:Label}
)</code></pre><p>Calculate metrics for a rule with respect to a labelled dataset and returns a <code>NamedTuple</code> consisting of:</p><ul><li><code>support</code>: number of instances satisfying the antecedent of the rule divided by   the total number of instances;</li><li><code>error</code>:<ul><li>For classification problems: number of instances that were not classified</li></ul>correctly divided by the total number of instances;<ul><li>For regression problems: mean squared error;</li></ul></li><li><code>length</code>: number of propositions in the rule&#39;s antecedent.</li></ul><p>See also <a href="#SoleModels.Rule"><code>Rule</code></a>, <a href="@ref"><code>AbstractInterpretationSet</code></a>, <a href="#SoleModels.Label"><code>Label</code></a>, <a href="#SoleModels.evaluaterule-Union{Tuple{FM}, Tuple{C}, Tuple{O}, Tuple{Rule{O, C, FM}, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, Integer, String}}}} where {O, C, FM&lt;:SoleModels.AbstractModel}"><code>evaluaterule</code></a>, <a href="@ref"><code>ninstances</code></a>, <a href="#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>outcometype</code></a>, <a href="#SoleModels.consequent-Tuple{Rule}"><code>consequent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/rule-evaluation.jl#L77-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.submodels-Tuple{SoleModels.AbstractModel}" href="#SoleModels.submodels-Tuple{SoleModels.AbstractModel}"><code>SoleModels.submodels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">submodels(m::AbstractModel)</code></pre><p>Enumerate all submodels in the sub-tree. This function is the transitive closure of <code>immediatesubmodels</code>; in fact, the returned list includes the immediate submodels (<code>immediatesubmodels(m)</code>), but also their immediate submodels, and so on.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SoleLogics

julia&gt; branch = Branch(SoleLogics.parseformula(&quot;p∧q∨r&quot;), &quot;YES&quot;, &quot;NO&quot;);

julia&gt; submodels(branch)
2-element Vector{SoleModels.ConstantModel{String}}:
 ConstantModel
YES

 ConstantModel
NO


julia&gt; branch2 = Branch(SoleLogics.parseformula(&quot;s→p&quot;), branch, 42);

julia&gt; printmodel.(submodels(branch2));
Branch
┐ p ∧ (q ∨ r)
├ ✔ YES
└ ✘ NO

ConstantModel
YES

ConstantModel
NO

ConstantModel
42

julia&gt; submodels(branch) == immediatesubmodels(branch)
true

julia&gt; submodels(branch2) == immediatesubmodels(branch2)
false</code></pre><p>See also <a href="#SoleModels.immediatesubmodels-Union{Tuple{SoleModels.AbstractModel{O}}, Tuple{O}} where O"><code>immediatesubmodels</code></a>, <a href="#SoleModels.FinalModel"><code>FinalModel</code></a>, <a href="#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/symbolic-utils.jl#L57-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoleModels.wrap-Tuple{Any, Type{&lt;:SoleModels.AbstractModel}}" href="#SoleModels.wrap-Tuple{Any, Type{&lt;:SoleModels.AbstractModel}}"><code>SoleModels.wrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap(o::Any)::AbstractModel</code></pre><p>This function wraps anything into an AbstractModel. The default behavior is the following:</p><ul><li>when called on an <code>AbstractModel</code>, the model is</li></ul><p>simply returned (no wrapping is performed);</p><ul><li><code>Function</code>s and <code>FunctionWrapper</code>s are wrapped into a <code>FunctionModel</code>;</li><li>every other object is wrapped into a <code>ConstantModel</code>.</li></ul><p>See also <a href="#SoleModels.ConstantModel"><code>ConstantModel</code></a>, <a href="#SoleModels.FunctionModel"><code>FunctionModel</code></a>, <a href="#SoleModels.ConstrainedModel"><code>ConstrainedModel</code></a>, <a href="#SoleModels.FinalModel"><code>FinalModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/ceb4a0c28a5149cd0d9d7a0b346b1d949ce30fe4/src/models/base.jl#L482-L495">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 7 July 2023 18:07">Friday 7 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
