<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symbolic models · SoleModels.jl</title><meta name="title" content="Symbolic models · SoleModels.jl"/><meta property="og:title" content="Symbolic models · SoleModels.jl"/><meta property="twitter:title" content="Symbolic models · SoleModels.jl"/><meta name="description" content="Documentation for SoleModels.jl."/><meta property="og:description" content="Documentation for SoleModels.jl."/><meta property="twitter:description" content="Documentation for SoleModels.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SoleModels.jl/models/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SoleModels.jl/models/"/><link rel="canonical" href="https://aclai-lab.github.io/SoleModels.jl/models/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SoleModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../logic/">Logical foundations</a></li><li class="is-active"><a class="tocitem" href>Symbolic models</a><ul class="internal"><li><a class="tocitem" href="#Evaluating-symbolic-models"><span>Evaluating symbolic models</span></a></li><li><a class="tocitem" href="#Manipulating-symbolic-knowledge"><span>Manipulating symbolic knowledge</span></a></li></ul></li><li><a class="tocitem" href="../parse/">Parsing models from other frameworks</a></li><li><a class="tocitem" href="../autodocs/">Full reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Symbolic models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symbolic models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleModels.jl/blob/main/docs/src/models.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Symbolic-models"><a class="docs-heading-anchor" href="#Symbolic-models">Symbolic models</a><a id="Symbolic-models-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-models" title="Permalink"></a></h1><ul><li><a href="../autodocs/#SoleModels.AbstractModel"><code>SoleModels.AbstractModel</code></a></li><li><a href="../autodocs/#SoleModels.Branch"><code>SoleModels.Branch</code></a></li><li><a href="../autodocs/#SoleModels.ConstantModel"><code>SoleModels.ConstantModel</code></a></li><li><a href="../autodocs/#SoleModels.DecisionForest"><code>SoleModels.DecisionForest</code></a></li><li><a href="../autodocs/#SoleModels.DecisionList"><code>SoleModels.DecisionList</code></a></li><li><a href="../autodocs/#SoleModels.DecisionTree"><code>SoleModels.DecisionTree</code></a></li><li><a href="../autodocs/#SoleModels.FunctionModel"><code>SoleModels.FunctionModel</code></a></li><li><a href="../autodocs/#SoleModels.LeafModel"><code>SoleModels.LeafModel</code></a></li><li><a href="../autodocs/#SoleModels.MixedModel"><code>SoleModels.MixedModel</code></a></li><li><a href="../autodocs/#SoleModels.Rule"><code>SoleModels.Rule</code></a></li><li><a href="../autodocs/#Base.isopen-Tuple{SoleModels.AbstractModel}"><code>Base.isopen</code></a></li><li><a href="../autodocs/#SoleModels.antecedent-Tuple{Rule}"><code>SoleModels.antecedent</code></a></li><li><a href="../autodocs/#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>SoleModels.apply</code></a></li><li><a href="../autodocs/#SoleModels.checkantecedent"><code>SoleModels.checkantecedent</code></a></li><li><a href="../autodocs/#SoleModels.consequent-Tuple{Rule}"><code>SoleModels.consequent</code></a></li><li><a href="../autodocs/#SoleModels.displaymodel-Tuple{SoleModels.AbstractModel}"><code>SoleModels.displaymodel</code></a></li><li><a href="../autodocs/#SoleModels.evaluaterule-Tuple{Rule, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, AbstractString, Integer, CategoricalArrays.CategoricalValue}}}"><code>SoleModels.evaluaterule</code></a></li><li><a href="../autodocs/#SoleModels.immediatesubmodels-Union{Tuple{SoleModels.AbstractModel{O}}, Tuple{O}} where O"><code>SoleModels.immediatesubmodels</code></a></li><li><a href="../autodocs/#SoleModels.info-Tuple{SoleModels.AbstractModel}"><code>SoleModels.info</code></a></li><li><a href="../autodocs/#SoleModels.joinrules"><code>SoleModels.joinrules</code></a></li><li><a href="../autodocs/#SoleModels.listimmediaterules-Tuple{SoleModels.AbstractModel}"><code>SoleModels.listimmediaterules</code></a></li><li><a href="../autodocs/#SoleModels.listrules-Tuple{SoleModels.AbstractModel}"><code>SoleModels.listrules</code></a></li><li><a href="../autodocs/#SoleModels.negconsequent-Tuple{Branch}"><code>SoleModels.negconsequent</code></a></li><li><a href="../autodocs/#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>SoleModels.outcometype</code></a></li><li><a href="../autodocs/#SoleModels.outputtype-Tuple{SoleModels.AbstractModel}"><code>SoleModels.outputtype</code></a></li><li><a href="../autodocs/#SoleModels.parse_orange_decision_list"><code>SoleModels.parse_orange_decision_list</code></a></li><li><a href="../autodocs/#SoleModels.posconsequent-Tuple{Branch}"><code>SoleModels.posconsequent</code></a></li><li><a href="../autodocs/#SoleModels.printmodel-Tuple{SoleModels.AbstractModel}"><code>SoleModels.printmodel</code></a></li><li><a href="../autodocs/#SoleModels.readmetrics-Union{Tuple{SoleModels.LeafModel{L}}, Tuple{L}} where L&lt;:Union{AbstractFloat, AbstractString, Integer, CategoricalArrays.CategoricalValue}"><code>SoleModels.readmetrics</code></a></li><li><a href="../autodocs/#SoleModels.rulemetrics-Tuple{Rule, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, AbstractString, Integer, CategoricalArrays.CategoricalValue}}}"><code>SoleModels.rulemetrics</code></a></li><li><a href="../autodocs/#SoleModels.submodels-Tuple{SoleModels.AbstractModel}"><code>SoleModels.submodels</code></a></li><li><a href="../autodocs/#SoleModels.wrap-Tuple{Any, Type{&lt;:SoleModels.AbstractModel}}"><code>SoleModels.wrap</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.AbstractModel-models" href="#SoleModels.AbstractModel-models"><code>SoleModels.AbstractModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractModel{O} end</code></pre><p>Abstract type for symbolic models that, given an instance object (i.e., a piece of data), output an outcome of type <code>O</code>.</p><p>A model is said to be <em>symbolic</em> when its application relies on checking formulas of a certain logical language (see <a href="https://github.com/aclai-lab/SoleLogics.jl">SoleLogics.jl</a> package) on the instance. Symbolic models provide a form of transparent and <em>interpretable modeling</em>, as a symbolic model can be synthethised into a set of mutually exclusive logical rules that can often be translated into natural language.</p><p>Examples of symbolic models are <a href="../autodocs/#SoleModels.Rule"><code>Rule</code></a>s, <a href="../autodocs/#SoleModels.Branch"><code>Branch</code></a>es, <a href="../autodocs/#SoleModels.DecisionList"><code>DecisionList</code></a>s and <a href="../autodocs/#SoleModels.DecisionTree"><code>DecisionTree</code></a>s. Examples of non-symbolic (or <em>sub-symbolic</em>) models include those encoding algebraic mathematical functions (e.g., neural networks).</p><p>Symbolic models can wrap other <code>AbstractModel</code>s, and use them to compute the outcome. As such, an <code>AbstractModel</code> can actually be the result of a composition of many models, and enclose a <em>tree</em> of <code>AbstractModel</code>s (with <code>LeafModel</code>s at the leaves).</p><p>See also <a href="../autodocs/#SoleModels.LeafModel"><code>LeafModel</code></a>, <a href="../autodocs/#SoleModels.Rule"><code>Rule</code></a>, <a href="../autodocs/#SoleModels.Branch"><code>Branch</code></a>, <a href="../autodocs/#Base.isopen-Tuple{SoleModels.AbstractModel}"><code>isopen</code></a>, <a href="../autodocs/#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>apply</code></a>, <a href="../autodocs/#SoleModels.info-Tuple{SoleModels.AbstractModel}"><code>info</code></a>, <a href="../autodocs/#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>outcometype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L15-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.Branch-models" href="#SoleModels.Branch-models"><code>SoleModels.Branch</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Branch{O} &lt;: AbstractModel{O}
    antecedent::Formula
    posconsequent::M where {M&lt;:AbstractModel{&lt;:O}}
    negconsequent::M where {M&lt;:AbstractModel{&lt;:O}}
    info::NamedTuple
end</code></pre><p>A <code>Branch</code> is one of the fundamental building blocks of symbolic modeling, and has the semantics:</p><pre><code class="nohighlight hljs">IF (antecedent) THEN (positive consequent) ELSE (negative consequent) END</code></pre><p>where the antecedent is a formula to be checked and the consequents are the feasible local outcomes of the block. If checking the antecedent evaluates to the top of the algebra, then the positive consequent is applied; otherwise, the negative consequenti is applied.</p><p>See also <a href="../autodocs/#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="../autodocs/#SoleModels.posconsequent-Tuple{Branch}"><code>posconsequent</code></a>, <a href="../autodocs/#SoleModels.negconsequent-Tuple{Branch}"><code>negconsequent</code></a>, <a href="../logic/#SoleLogics.check-logic"><code>SoleLogics.check</code></a>, <a href="../logic/#SoleLogics.Formula-logic"><code>SoleLogics.Formula</code></a>, <a href="../autodocs/#SoleModels.Rule"><code>Rule</code></a>, <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L574-L599">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ConstantModel-models" href="#SoleModels.ConstantModel-models"><code>SoleModels.ConstantModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ConstantModel{O} &lt;: LeafModel{O}
    outcome::O
    info::NamedTuple
end</code></pre><p>The simplest type of model is the <code>ConstantModel</code>; it is a <code>LeafModel</code> that always outputs the same outcome.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleModels.LeafModel(2) isa SoleModels.ConstantModel

julia&gt; SoleModels.LeafModel(sum) isa SoleModels.FunctionModel
┌ Warning: Over efficiency concerns, please consider wrappingJulia Function&#39;s into FunctionWrapper{O,Tuple{SoleModels.AbstractInterpretation}} structures,where O is their return type.
└ @ SoleModels ~/.julia/dev/SoleModels/src/base.jl:337
true
</code></pre><p>See also <a href="../autodocs/#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>apply</code></a>, <a href="../autodocs/#SoleModels.FunctionModel"><code>FunctionModel</code></a>, <a href="../autodocs/#SoleModels.LeafModel"><code>LeafModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L209-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.DecisionForest-models" href="#SoleModels.DecisionForest-models"><code>SoleModels.DecisionForest</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A <code>Decision Forest</code> is a symbolic model that wraps an ensemble of models</p><pre><code class="nohighlight hljs">struct DecisionForest{O} &lt;: AbstractModel{O}
    trees::Vector{&lt;:DecisionTree}
    info::NamedTuple
end</code></pre><p>See also <a href="../autodocs/#SoleModels.MixedModel"><code>MixedModel</code></a>, <a href="../autodocs/#SoleModels.DecisionList"><code>DecisionList</code></a>, <a href="../autodocs/#SoleModels.DecisionTree"><code>DecisionTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L967-L978">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.DecisionList-models" href="#SoleModels.DecisionList-models"><code>SoleModels.DecisionList</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DecisionList{O} &lt;: AbstractModel{O}
    rulebase::Vector{Rule{_O} where {_O&lt;:O}}
    defaultconsequent::M where {M&lt;:AbstractModel{&lt;:O}}
    info::NamedTuple
end</code></pre><p>A <code>DecisionList</code> (or <em>decision table</em>, or <em>rule-based model</em>) is a symbolic model that has the semantics of an IF-ELSEIF-ELSE block:</p><pre><code class="nohighlight hljs">IF (antecedent_1)     THEN (consequent_1)
ELSEIF (antecedent_2) THEN (consequent_2)
...
ELSEIF (antecedent_n) THEN (consequent_n)
ELSE (consequent_default) END</code></pre><p>where the antecedents are formulas to be, and the consequents are the feasible local outcomes of the block. Using the classical semantics, the antecedents are evaluated in order, and a consequent is returned as soon as a valid antecedent is found, or when the computation reaches the ELSE clause.</p><p>See also <a href="../autodocs/#SoleModels.Rule"><code>Rule</code></a>, <a href="../autodocs/#SoleModels.DecisionTree"><code>DecisionTree</code></a>, <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L754-L780">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.DecisionTree-models" href="#SoleModels.DecisionTree-models"><code>SoleModels.DecisionTree</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A <code>DecisionTree</code> is a symbolic model that operates as a nested structure of IF-THEN-ELSE blocks:</p><pre><code class="nohighlight hljs">IF (antecedent_1) THEN
    IF (antecedent_2) THEN
        (consequent_1)
    ELSE
        (consequent_2)
    END
ELSE
    IF (antecedent_3) THEN
        (consequent_3)
    ELSE
        (consequent_4)
    END
END</code></pre><p>where the antecedents are formulas to be, and the consequents are the feasible local outcomes of the block.</p><p>In practice, a <code>DecisionTree</code> simply wraps a constrained sub-tree of <code>Branch</code> and <code>LeafModel</code>:</p><pre><code class="nohighlight hljs">struct DecisionTree{O} &lt;: AbstractModel{O}
    root::M where {M&lt;:AbstractModel}
    info::NamedTuple
end</code></pre><p>Note that this structure also includes an <code>info::NamedTuple</code> for storing additional information.</p><p>See also <a href="../autodocs/#SoleModels.MixedModel"><code>MixedModel</code></a>, <a href="../autodocs/#SoleModels.DecisionList"><code>DecisionList</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L849-L882">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.FunctionModel-models" href="#SoleModels.FunctionModel-models"><code>SoleModels.FunctionModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct FunctionModel{O} &lt;: LeafModel{O}
    f::FunctionWrapper{O}
    info::NamedTuple
end</code></pre><p>A <code>FunctionModel</code> is a <code>LeafModel</code> that applies a native Julia <code>Function</code> in order to compute the outcome. Over efficiency concerns, it is mandatory to make explicit the output type <code>O</code> by wrapping the <code>Function</code> into an object of type <code>FunctionWrapper{O}</code> (see <a href="https://github.com/yuyichao/FunctionWrappers.jl">FunctionWrappers</a>.</p><p>See also <a href="../autodocs/#SoleModels.ConstantModel"><code>ConstantModel</code></a>, <a href="../autodocs/#SoleModels.LeafModel"><code>LeafModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L271-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.LeafModel-models" href="#SoleModels.LeafModel-models"><code>SoleModels.LeafModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type LeafModel{O} &lt;: AbstractModel{O} end</code></pre><p>Abstract type for leaf models, that is, models which outcomes do not depend other models, and represents the bottom of the computation. In general, an <code>AbstractModel</code> can generally wrap other <code>AbstractModel</code>s; in such case, the outcome can depend on the inner models being applied on the instance object. Otherwise, the model is considered as a <em>leaf</em>, or <em>final</em>, and is the <em>leaf</em> of a tree of <code>AbstractModel</code>s.</p><p>See also <a href="../autodocs/#SoleModels.ConstantModel"><code>ConstantModel</code></a>, <a href="../autodocs/#SoleModels.FunctionModel"><code>FunctionModel</code></a>, <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L195-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.MixedModel-models" href="#SoleModels.MixedModel-models"><code>SoleModels.MixedModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A <code>MixedModel</code> is a symbolic model that operaters as a free nested structure of IF-THEN-ELSE and IF-ELSEIF-ELSE blocks:</p><pre><code class="nohighlight hljs">IF (antecedent_1) THEN
    IF (antecedent_1)     THEN (consequent_1)
    ELSEIF (antecedent_2) THEN (consequent_2)
    ELSE (consequent_1_default) END
ELSE
    IF (antecedent_3) THEN
        (consequent_3)
    ELSE
        (consequent_4)
    END
END</code></pre><p>where the antecedents are formulas to be checked, and the consequents are the feasible local outcomes of the block.</p><p>In Sole.jl, this logic can implemented using <code>AbstractModel</code>s such as <code>Rule</code>s, <code>Branch</code>s, <code>DecisionList</code>s, <code>DecisionTree</code>s, and the be wrapped into a <code>MixedModel</code>:</p><pre><code class="nohighlight hljs">struct MixedModel{O,FM&lt;:AbstractModel} &lt;: AbstractModel{O}
    root::M where {M&lt;:AbstractModel{&lt;:O}}
    info::NamedTuple
end</code></pre><p>Note that <code>FM</code> refers to the Feasible Models (<code>FM</code>) allowed in the model&#39;s sub-tree.</p><p>See also <a href="../autodocs/#SoleModels.DecisionTree"><code>DecisionTree</code></a>, <a href="../autodocs/#SoleModels.DecisionList"><code>DecisionList</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L1030-L1061">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.Rule-models" href="#SoleModels.Rule-models"><code>SoleModels.Rule</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Rule{O} &lt;: AbstractModel{O}
    antecedent::Formula
    consequent::M where {M&lt;:AbstractModel{&lt;:O}}
    info::NamedTuple
end</code></pre><p>A <code>Rule</code> is one of the fundamental building blocks of symbolic modeling, and has the semantics:</p><pre><code class="nohighlight hljs">IF (antecedent) THEN (consequent) END</code></pre><p>where the antecedent is a formula to be checked, and the consequent is the local outcome of the block.</p><p>See also <a href="../autodocs/#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="../autodocs/#SoleModels.consequent-Tuple{Rule}"><code>consequent</code></a>, <a href="../logic/#SoleLogics.Formula-logic"><code>SoleLogics.Formula</code></a>, <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L403-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isopen-Tuple{SoleModels.AbstractModel}-models" href="#Base.isopen-Tuple{SoleModels.AbstractModel}-models"><code>Base.isopen</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isopen(::AbstractModel)::Bool</code></pre><p>Return whether a model is open. An <code>AbstractModel{O}</code> is <em>closed</em> if it is always able to provide an outcome of type <code>O</code>. Otherwise, the model can output <code>nothing</code> values and is referred to as <em>open</em>.</p><p><a href="../autodocs/#SoleModels.Rule"><code>Rule</code></a> is an example of an <em>open</em> model, while <a href="../autodocs/#SoleModels.Branch"><code>Branch</code></a> is an example of <em>closed</em> model.</p><p>See also <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L66-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.antecedent-Tuple{Rule}-models" href="#SoleModels.antecedent-Tuple{Rule}-models"><code>SoleModels.antecedent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">antecedent(m::Union{Rule,Branch})::Formula</code></pre><p>Return the antecedent of a rule/branch, that is, the formula to be checked upon applying the model.</p><p>See also <a href="../autodocs/#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>apply</code></a>, <a href="../autodocs/#SoleModels.consequent-Tuple{Rule}"><code>consequent</code></a>, <a href="../autodocs/#SoleModels.checkantecedent"><code>checkantecedent</code></a>, <a href="../autodocs/#SoleModels.Rule"><code>Rule</code></a>, <a href="../autodocs/#SoleModels.Branch"><code>Branch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L459-L471">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}-models" href="#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}-models"><code>SoleModels.apply</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply(m, i; kwargs...)::outputtype(m)
apply(m, d; kwargs...)::AbstractVector{&lt;:outputtype(m)}
apply(m, d, i_instance; kwargs...)::outputtype(m)</code></pre><p>Return the output prediction of a model <code>m</code> on a logical interpretation <code>i</code>, on the <code>i_instance</code> of a dataset <code>d</code>, or on all instances of a dataset <code>d</code>. Note that predictions can be <code>nothing</code> if the model is <em>open</em> (e.g., if the model is a <code>Rule</code>).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>check_args::Tuple = ()</code>;</li><li><code>check_kwargs::NamedTuple = (;)</code>;</li><li><code>functional_args::Tuple = ()</code>;</li><li><code>functional_kwargs::NamedTuple = (;)</code>;</li><li>Any additional keyword argument is passed down to the model subtree&#39;s leaves</li></ul><p><code>check_args</code> and <code>check_kwargs</code> can influence check&#39;s behavior at the time of its computation (see <a href="../logic/#SoleLogics.check-logic">`SoleLogics.check</a>)</p><p><code>functional_args</code> and <code>functional_kwargs</code> can influence FunctionModel&#39;s behavior when the corresponding function is applied to AbstractInterpretation (see <a href="../autodocs/#SoleModels.FunctionModel"><code>FunctionModel</code></a>, <a href="../logic/#SoleLogics.AbstractInterpretation-logic">`SoleLogics.AbstractInterpretation</a>)</p><p>A model state-changing version of the function, [<code>apply!</code>], exist. While producing the output, this function affects the info keys <code>:supporting_labels</code> and <code>:supporting_predictions</code>, which are useful for inspecting the statistical performance of parts of the model.</p><p>See also <a href="../autodocs/#Base.isopen-Tuple{SoleModels.AbstractModel}"><code>isopen</code></a>, <a href="../autodocs/#SoleModels.readmetrics-Union{Tuple{SoleModels.LeafModel{L}}, Tuple{L}} where L&lt;:Union{AbstractFloat, AbstractString, Integer, CategoricalArrays.CategoricalValue}"><code>readmetrics</code></a>, <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>, <a href="../logic/#SoleLogics.AbstractInterpretation-logic"><code>SoleLogics.AbstractInterpretation</code></a>, <a href="../logic/#SoleLogics.AbstractInterpretationSet-logic"><code>SoleLogics.AbstractInterpretationSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L98-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.checkantecedent-models" href="#SoleModels.checkantecedent-models"><code>SoleModels.checkantecedent</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkantecedent(
    m::Union{Rule,Branch},
    args...;
    kwargs...
)
    check(antecedent(m), args...; kwargs...)
end</code></pre><p>Simply check the antecedent of a rule on an instance or dataset.</p><p>See also <a href="../autodocs/#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="../autodocs/#SoleModels.Rule"><code>Rule</code></a>, <a href="../autodocs/#SoleModels.Branch"><code>Branch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L485-L500">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.consequent-Tuple{Rule}-models" href="#SoleModels.consequent-Tuple{Rule}-models"><code>SoleModels.consequent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">consequent(m::Rule)::AbstractModel</code></pre><p>Return the consequent of a rule.</p><p>See also <a href="../autodocs/#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="../autodocs/#SoleModels.Rule"><code>Rule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L474-L482">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.info-Tuple{SoleModels.AbstractModel}-models" href="#SoleModels.info-Tuple{SoleModels.AbstractModel}-models"><code>SoleModels.info</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">info(m::AbstractModel)::NamedTuple = m.info
info(m::AbstractModel, key) = m.info[key]
info(m::AbstractModel, key, defaultval)

info!(m::AbstractModel, info::NamedTuple)
info!(m::AbstractModel, key, val)</code></pre><p>Return the <code>info</code> structure for model <code>m</code>; this structure is used for storing additional information that does not affect the model&#39;s behavior. This structure can hold, for example, information about the model&#39;s statistical performance during the learning phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L164-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.negconsequent-Tuple{Branch}-models" href="#SoleModels.negconsequent-Tuple{Branch}-models"><code>SoleModels.negconsequent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">negconsequent(m::Branch)::AbstractModel</code></pre><p>Return the negative consequent of a branch; that is, the model to be applied if the antecedent evaluates to <code>false</code>.</p><p>See also <a href="../autodocs/#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="../autodocs/#SoleModels.Branch"><code>Branch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L643-L652">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O-models" href="#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O-models"><code>SoleModels.outcometype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">outcometype(::Type{&lt;:AbstractModel{O}}) where {O} = O
outcometype(m::AbstractModel) = outcometype(typeof(m))</code></pre><p>Return the outcome type of a model (type).</p><p>See also <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L50-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.outputtype-Tuple{SoleModels.AbstractModel}-models" href="#SoleModels.outputtype-Tuple{SoleModels.AbstractModel}-models"><code>SoleModels.outputtype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">outputtype(m::AbstractModel)</code></pre><p>Return a supertype for the outputs obtained when <code>apply</code>ing a model. The result depends on whether the model is open or closed:</p><pre><code class="nohighlight hljs">outputtype(M::AbstractModel{O}) = isopen(M) ? Union{Nothing,O} : O</code></pre><p>Note that if the model is closed, then <code>outputtype(m)</code> is equal to <code>outcometype(m)</code>.</p><p>See also <a href="../autodocs/#Base.isopen-Tuple{SoleModels.AbstractModel}"><code>isopen</code></a>, <a href="../autodocs/#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>apply</code></a>, <a href="../autodocs/#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>outcometype</code></a>, <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L78-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.posconsequent-Tuple{Branch}-models" href="#SoleModels.posconsequent-Tuple{Branch}-models"><code>SoleModels.posconsequent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">posconsequent(m::Branch)::AbstractModel</code></pre><p>Return the positive consequent of a branch; that is, the model to be applied if the antecedent evaluates to <code>true</code>.</p><p>See also <a href="../autodocs/#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="../autodocs/#SoleModels.Branch"><code>Branch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L631-L640">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.wrap-Tuple{Any, Type{&lt;:SoleModels.AbstractModel}}-models" href="#SoleModels.wrap-Tuple{Any, Type{&lt;:SoleModels.AbstractModel}}-models"><code>SoleModels.wrap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">wrap(o::Any)::AbstractModel</code></pre><p>This function wraps anything into an AbstractModel. The default behavior is the following:</p><ul><li>when called on an <code>AbstractModel</code>, the model is</li></ul><p>simply returned (no wrapping is performed);</p><ul><li><code>Function</code>s and <code>FunctionWrapper</code>s are wrapped into a <code>FunctionModel</code>;</li><li>every other object is wrapped into a <code>ConstantModel</code>.</li></ul><p>See also <a href="../autodocs/#SoleModels.ConstantModel"><code>ConstantModel</code></a>, <a href="../autodocs/#SoleModels.FunctionModel"><code>FunctionModel</code></a>, <a href="../autodocs/#SoleModels.LeafModel"><code>LeafModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L367-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.ConstantModel-models-2" href="#SoleModels.ConstantModel-models-2"><code>SoleModels.ConstantModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ConstantModel{O} &lt;: LeafModel{O}
    outcome::O
    info::NamedTuple
end</code></pre><p>The simplest type of model is the <code>ConstantModel</code>; it is a <code>LeafModel</code> that always outputs the same outcome.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleModels.LeafModel(2) isa SoleModels.ConstantModel

julia&gt; SoleModels.LeafModel(sum) isa SoleModels.FunctionModel
┌ Warning: Over efficiency concerns, please consider wrappingJulia Function&#39;s into FunctionWrapper{O,Tuple{SoleModels.AbstractInterpretation}} structures,where O is their return type.
└ @ SoleModels ~/.julia/dev/SoleModels/src/base.jl:337
true
</code></pre><p>See also <a href="../autodocs/#SoleModels.apply-Tuple{SoleModels.AbstractModel, SoleLogics.AbstractInterpretation}"><code>apply</code></a>, <a href="../autodocs/#SoleModels.FunctionModel"><code>FunctionModel</code></a>, <a href="../autodocs/#SoleModels.LeafModel"><code>LeafModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L209-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.FunctionModel-models-2" href="#SoleModels.FunctionModel-models-2"><code>SoleModels.FunctionModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct FunctionModel{O} &lt;: LeafModel{O}
    f::FunctionWrapper{O}
    info::NamedTuple
end</code></pre><p>A <code>FunctionModel</code> is a <code>LeafModel</code> that applies a native Julia <code>Function</code> in order to compute the outcome. Over efficiency concerns, it is mandatory to make explicit the output type <code>O</code> by wrapping the <code>Function</code> into an object of type <code>FunctionWrapper{O}</code> (see <a href="https://github.com/yuyichao/FunctionWrappers.jl">FunctionWrappers</a>.</p><p>See also <a href="../autodocs/#SoleModels.ConstantModel"><code>ConstantModel</code></a>, <a href="../autodocs/#SoleModels.LeafModel"><code>LeafModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L271-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.Rule-models-2" href="#SoleModels.Rule-models-2"><code>SoleModels.Rule</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Rule{O} &lt;: AbstractModel{O}
    antecedent::Formula
    consequent::M where {M&lt;:AbstractModel{&lt;:O}}
    info::NamedTuple
end</code></pre><p>A <code>Rule</code> is one of the fundamental building blocks of symbolic modeling, and has the semantics:</p><pre><code class="nohighlight hljs">IF (antecedent) THEN (consequent) END</code></pre><p>where the antecedent is a formula to be checked, and the consequent is the local outcome of the block.</p><p>See also <a href="../autodocs/#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="../autodocs/#SoleModels.consequent-Tuple{Rule}"><code>consequent</code></a>, <a href="../logic/#SoleLogics.Formula-logic"><code>SoleLogics.Formula</code></a>, <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L403-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.Branch-models-2" href="#SoleModels.Branch-models-2"><code>SoleModels.Branch</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Branch{O} &lt;: AbstractModel{O}
    antecedent::Formula
    posconsequent::M where {M&lt;:AbstractModel{&lt;:O}}
    negconsequent::M where {M&lt;:AbstractModel{&lt;:O}}
    info::NamedTuple
end</code></pre><p>A <code>Branch</code> is one of the fundamental building blocks of symbolic modeling, and has the semantics:</p><pre><code class="nohighlight hljs">IF (antecedent) THEN (positive consequent) ELSE (negative consequent) END</code></pre><p>where the antecedent is a formula to be checked and the consequents are the feasible local outcomes of the block. If checking the antecedent evaluates to the top of the algebra, then the positive consequent is applied; otherwise, the negative consequenti is applied.</p><p>See also <a href="../autodocs/#SoleModels.antecedent-Tuple{Rule}"><code>antecedent</code></a>, <a href="../autodocs/#SoleModels.posconsequent-Tuple{Branch}"><code>posconsequent</code></a>, <a href="../autodocs/#SoleModels.negconsequent-Tuple{Branch}"><code>negconsequent</code></a>, <a href="../logic/#SoleLogics.check-logic"><code>SoleLogics.check</code></a>, <a href="../logic/#SoleLogics.Formula-logic"><code>SoleLogics.Formula</code></a>, <a href="../autodocs/#SoleModels.Rule"><code>Rule</code></a>, <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L574-L599">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.DecisionList-models-2" href="#SoleModels.DecisionList-models-2"><code>SoleModels.DecisionList</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DecisionList{O} &lt;: AbstractModel{O}
    rulebase::Vector{Rule{_O} where {_O&lt;:O}}
    defaultconsequent::M where {M&lt;:AbstractModel{&lt;:O}}
    info::NamedTuple
end</code></pre><p>A <code>DecisionList</code> (or <em>decision table</em>, or <em>rule-based model</em>) is a symbolic model that has the semantics of an IF-ELSEIF-ELSE block:</p><pre><code class="nohighlight hljs">IF (antecedent_1)     THEN (consequent_1)
ELSEIF (antecedent_2) THEN (consequent_2)
...
ELSEIF (antecedent_n) THEN (consequent_n)
ELSE (consequent_default) END</code></pre><p>where the antecedents are formulas to be, and the consequents are the feasible local outcomes of the block. Using the classical semantics, the antecedents are evaluated in order, and a consequent is returned as soon as a valid antecedent is found, or when the computation reaches the ELSE clause.</p><p>See also <a href="../autodocs/#SoleModels.Rule"><code>Rule</code></a>, <a href="../autodocs/#SoleModels.DecisionTree"><code>DecisionTree</code></a>, <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L754-L780">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.DecisionTree-models-2" href="#SoleModels.DecisionTree-models-2"><code>SoleModels.DecisionTree</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A <code>DecisionTree</code> is a symbolic model that operates as a nested structure of IF-THEN-ELSE blocks:</p><pre><code class="nohighlight hljs">IF (antecedent_1) THEN
    IF (antecedent_2) THEN
        (consequent_1)
    ELSE
        (consequent_2)
    END
ELSE
    IF (antecedent_3) THEN
        (consequent_3)
    ELSE
        (consequent_4)
    END
END</code></pre><p>where the antecedents are formulas to be, and the consequents are the feasible local outcomes of the block.</p><p>In practice, a <code>DecisionTree</code> simply wraps a constrained sub-tree of <code>Branch</code> and <code>LeafModel</code>:</p><pre><code class="nohighlight hljs">struct DecisionTree{O} &lt;: AbstractModel{O}
    root::M where {M&lt;:AbstractModel}
    info::NamedTuple
end</code></pre><p>Note that this structure also includes an <code>info::NamedTuple</code> for storing additional information.</p><p>See also <a href="../autodocs/#SoleModels.MixedModel"><code>MixedModel</code></a>, <a href="../autodocs/#SoleModels.DecisionList"><code>DecisionList</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L849-L882">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.DecisionForest-models-2" href="#SoleModels.DecisionForest-models-2"><code>SoleModels.DecisionForest</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A <code>Decision Forest</code> is a symbolic model that wraps an ensemble of models</p><pre><code class="nohighlight hljs">struct DecisionForest{O} &lt;: AbstractModel{O}
    trees::Vector{&lt;:DecisionTree}
    info::NamedTuple
end</code></pre><p>See also <a href="../autodocs/#SoleModels.MixedModel"><code>MixedModel</code></a>, <a href="../autodocs/#SoleModels.DecisionList"><code>DecisionList</code></a>, <a href="../autodocs/#SoleModels.DecisionTree"><code>DecisionTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/base.jl#L967-L978">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.printmodel-models" href="#SoleModels.printmodel-models"><code>SoleModels.printmodel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">printmodel(io::IO, m::AbstractModel; kwargs...)
displaymodel(m::AbstractModel; kwargs...)</code></pre><p>print or returnPa string representation of model <code>m</code>.</p><p><strong>Arguments</strong></p><ul><li><code>header::Bool = true</code>: when set to <code>true</code>, a header is printed, displaying the <code>info</code> structure for <code>m</code>;</li><li><code>show_subtree_info::Bool = false</code>: when set to <code>true</code>, the header is printed for models in the sub-tree of <code>m</code>;</li><li><code>show_metrics::Bool = false</code>: when set to <code>true</code>, performance metrics at each point of the subtree are shown, whenever they are available in the <code>info</code> structure;</li><li><code>max_depth::Union{Nothing,Int} = nothing</code>: when it is an <code>Int</code>, models in the sub-tree with a depth higher than <code>max_depth</code> are ellipsed with &quot;...&quot;;</li><li><code>syntaxstring_kwargs::NamedTuple = (;)</code>: kwargs to be passed to <code>syntaxstring</code> for formatting logical formulas.</li></ul><p>See also <a href="../logic/#SoleLogics.syntaxstring-logic"><code>syntaxstring</code></a>, <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/print.jl#L65-L79">source</a></section></article><h2 id="Evaluating-symbolic-models"><a class="docs-heading-anchor" href="#Evaluating-symbolic-models">Evaluating symbolic models</a><a id="Evaluating-symbolic-models-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluating-symbolic-models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.evaluaterule-Tuple{Rule, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, AbstractString, Integer, CategoricalArrays.CategoricalValue}}}-models-2" href="#SoleModels.evaluaterule-Tuple{Rule, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, AbstractString, Integer, CategoricalArrays.CategoricalValue}}}-models-2"><code>SoleModels.evaluaterule</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluaterule(
    r::Rule{O},
    X::AbstractInterpretationSet,
    Y::AbstractVector{L}
) where {O,L&lt;:Label}</code></pre><p>Evaluate the rule on a labeled dataset, and return a <code>NamedTuple</code> consisting of:</p><ul><li><code>antsat::Vector{Bool}</code>: satsfaction of the antecedent for each instance in the dataset;</li><li><code>ys::Vector{Union{Nothing,O}}</code>: rule prediction. For each instance in X:<ul><li><code>consequent(rule)</code> if the antecedent is satisfied,</li><li><code>nothing</code> otherwise.</li></ul></li></ul><p>See also <a href="../autodocs/#SoleModels.Rule"><code>Rule</code></a>, <a href="../logic/#SoleLogics.AbstractInterpretationSet-logic"><code>SoleLogics.AbstractInterpretationSet</code></a>, <a href="@ref"><code>Label</code></a>, <a href="../autodocs/#SoleModels.checkantecedent"><code>checkantecedent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/evaluate.jl#L186-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.readmetrics-Union{Tuple{SoleModels.LeafModel{L}}, Tuple{L}} where L&lt;:Union{AbstractFloat, AbstractString, Integer, CategoricalArrays.CategoricalValue}-models-2" href="#SoleModels.readmetrics-Union{Tuple{SoleModels.LeafModel{L}}, Tuple{L}} where L&lt;:Union{AbstractFloat, AbstractString, Integer, CategoricalArrays.CategoricalValue}-models-2"><code>SoleModels.readmetrics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readmetrics(m::AbstractModel; round_digits = nothing)</code></pre><p>Return a <code>NamedTuple</code> with some performance metrics for the given symbolic model. Performance metrics can be computed when the <code>info</code> structure of the model has the     following keys:     - :supporting<em>labels     - :supporting</em>predictions</p><p>The <code>round_digits</code> keyword argument, if provided, is used to <code>round</code> accuracy/confidence metrics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/evaluate.jl#L57-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.rulemetrics-Tuple{Rule, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, AbstractString, Integer, CategoricalArrays.CategoricalValue}}}-models-2" href="#SoleModels.rulemetrics-Tuple{Rule, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, AbstractString, Integer, CategoricalArrays.CategoricalValue}}}-models-2"><code>SoleModels.rulemetrics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rulemetrics(
    r::Rule,
    X::AbstractInterpretationSet,
    Y::AbstractVector{&lt;:Label}
)</code></pre><p>Compute metrics for a rule with respect to a labeled dataset and returns a <code>NamedTuple</code> consisting of:</p><ul><li><code>support</code>: number of instances satisfying the antecedent of the rule divided by   the total number of instances;</li><li><code>error</code>:<ul><li>For classification problems: number of instances that were not classified</li></ul>correctly divided by the total number of instances;<ul><li>For regression problems: mean squared error;</li></ul></li><li><code>length</code>: number of atoms in the rule&#39;s antecedent.</li></ul><p>See also <a href="../autodocs/#SoleModels.Rule"><code>Rule</code></a>, <a href="../logic/#SoleLogics.AbstractInterpretationSet-logic"><code>SoleLogics.AbstractInterpretationSet</code></a>, <a href="@ref"><code>Label</code></a>, <a href="../autodocs/#SoleModels.evaluaterule-Tuple{Rule, SoleLogics.AbstractInterpretationSet, AbstractVector{&lt;:Union{AbstractFloat, AbstractString, Integer, CategoricalArrays.CategoricalValue}}}"><code>evaluaterule</code></a>, <a href="../autodocs/#SoleModels.outcometype-Union{Tuple{Type{&lt;:SoleModels.AbstractModel{O}}}, Tuple{O}} where O"><code>outcometype</code></a>, <a href="../autodocs/#SoleModels.consequent-Tuple{Rule}"><code>consequent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/evaluate.jl#L258-L281">source</a></section></article><h2 id="Manipulating-symbolic-knowledge"><a class="docs-heading-anchor" href="#Manipulating-symbolic-knowledge">Manipulating symbolic knowledge</a><a id="Manipulating-symbolic-knowledge-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulating-symbolic-knowledge" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.immediatesubmodels-Union{Tuple{SoleModels.AbstractModel{O}}, Tuple{O}} where O-models-3" href="#SoleModels.immediatesubmodels-Union{Tuple{SoleModels.AbstractModel{O}}, Tuple{O}} where O-models-3"><code>SoleModels.immediatesubmodels</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">immediatesubmodels(m::AbstractModel)</code></pre><p>Return the list of immediate child models. Note: if the model is a leaf model, then the returned list will be empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SoleLogics

julia&gt; branch = Branch(SoleLogics.parseformula(&quot;p∧q∨r&quot;), &quot;YES&quot;, &quot;NO&quot;);

julia&gt; immediatesubmodels(branch)
2-element Vector{SoleModels.ConstantModel{String}}:
 SoleModels.ConstantModel{String}
YES

 SoleModels.ConstantModel{String}
NO

julia&gt; branch2 = Branch(SoleLogics.parseformula(&quot;s→p&quot;), branch, 42);


julia&gt; printmodel.(immediatesubmodels(branch2));
Branch
┐ p ∧ (q ∨ r)
├ ✔ YES
└ ✘ NO

ConstantModel
42</code></pre><p>See also <a href="../autodocs/#SoleModels.submodels-Tuple{SoleModels.AbstractModel}"><code>submodels</code></a>, <a href="../autodocs/#SoleModels.LeafModel"><code>LeafModel</code></a>, <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/symbolic-utils.jl#L6-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.joinrules-models-3" href="#SoleModels.joinrules-models-3"><code>SoleModels.joinrules</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">joinrules(rules::AbstractVector{&lt;:Rule})::Vector{&lt;:Rule}</code></pre><p>Return a set of rules, with exactly one rule per different outcome from the input set of rules. For each outcome, the output rule is computed as the logical disjunction of the antecedents of the input rules for that outcome.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SoleLogics

julia&gt; branch = Branch(SoleLogics.parseformula(&quot;p&quot;), Branch(SoleLogics.parseformula(&quot;q&quot;), &quot;YES&quot;, &quot;NO&quot;), &quot;NO&quot;)
 p
├✔ q
│├✔ YES
│└✘ NO
└✘ NO


julia&gt; printmodel.(listrules(branch); tree_mode = true);
▣ p ∧ q
└✔ YES

▣ p ∧ ¬q
└✔ NO

▣ ¬p
└✔ NO

julia&gt; printmodel.(joinrules(listrules(branch)); tree_mode = true);
▣ (p ∧ q)
└✔ YES

▣ (p ∧ ¬q) ∨ ¬p
└✔ NO
</code></pre><p>See also <a href="../autodocs/#SoleModels.listrules-Tuple{SoleModels.AbstractModel}"><code>listrules</code></a>, <a href="../logic/#SoleLogics.DISJUNCTION-logic"><code>SoleLogics.DISJUNCTION</code></a>, <a href="../autodocs/#SoleModels.LeafModel"><code>LeafModel</code></a>, <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/symbolic-utils.jl#L585-L626">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.listimmediaterules-Tuple{SoleModels.AbstractModel}-models-3" href="#SoleModels.listimmediaterules-Tuple{SoleModels.AbstractModel}-models-3"><code>SoleModels.listimmediaterules</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">listimmediaterules(m::AbstractModel{O} where {O})::Rule{&lt;:O}</code></pre><p>List the immediate rules equivalent to a symbolic model.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SoleLogics

julia&gt; branch = Branch(SoleLogics.parseformula(&quot;p&quot;), Branch(SoleLogics.parseformula(&quot;q&quot;), &quot;YES&quot;, &quot;NO&quot;), &quot;NO&quot;)
 p
├✔ q
│├✔ YES
│└✘ NO
└✘ NO


julia&gt; printmodel.(listimmediaterules(branch); tree_mode = true);
▣ p
└✔ q
 ├✔ YES
 └✘ NO

▣ ¬(p)
└✔ NO

</code></pre><p>See also <a href="../autodocs/#SoleModels.listrules-Tuple{SoleModels.AbstractModel}"><code>listrules</code></a>, <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/symbolic-utils.jl#L216-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.listrules-Tuple{SoleModels.AbstractModel}-models-3" href="#SoleModels.listrules-Tuple{SoleModels.AbstractModel}-models-3"><code>SoleModels.listrules</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">listrules(
    m::AbstractModel;
    use_shortforms::Bool = true,
    use_leftmostlinearform::Union{Nothing,Bool} = nothing,
    normalize::Bool = false,
    force_syntaxtree::Bool = false,
)::Vector{&lt;:Rule}</code></pre><p>Return a list of rules capturing the knowledge enclosed in symbolic model. The behavior of any symbolic model can be synthesised and represented as a set of mutually exclusive (and jointly exaustive, if the model is closed) rules, which can be useful for many purposes.</p><p>The keyword argument <code>force_syntaxtree</code>, when set to true, causes the logical antecedents in the returned rules to be represented as <code>SyntaxTree</code>s, as opposed to other syntax structure (e.g., <code>LeftmostConjunctiveForm</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SoleLogics

julia&gt; branch = Branch(SoleLogics.parseformula(&quot;p&quot;), Branch(SoleLogics.parseformula(&quot;q&quot;), &quot;YES&quot;, &quot;NO&quot;), &quot;NO&quot;)
 p
├✔ q
│├✔ YES
│└✘ NO
└✘ NO


julia&gt; printmodel.(listrules(branch); tree_mode = true);
▣ p ∧ q
└✔ YES

▣ p ∧ ¬q
└✔ NO

▣ ¬p
└✔ NO
</code></pre><p>See also <a href="../autodocs/#SoleModels.listimmediaterules-Tuple{SoleModels.AbstractModel}"><code>listimmediaterules</code></a>, <a href="../logic/#SoleLogics.CONJUNCTION-logic"><code>SoleLogics.CONJUNCTION</code></a>, <a href="../autodocs/#SoleModels.joinrules"><code>joinrules</code></a>, <a href="../autodocs/#SoleModels.LeafModel"><code>LeafModel</code></a>, <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/symbolic-utils.jl#L315-L361">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleModels.submodels-Tuple{SoleModels.AbstractModel}-models-3" href="#SoleModels.submodels-Tuple{SoleModels.AbstractModel}-models-3"><code>SoleModels.submodels</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">submodels(m::AbstractModel)</code></pre><p>Enumerate all submodels in the sub-tree. This function is the transitive closure of <code>immediatesubmodels</code>; in fact, the returned list includes the immediate submodels (<code>immediatesubmodels(m)</code>), but also their immediate submodels, and so on.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using SoleLogics

julia&gt; branch = Branch(SoleLogics.parseformula(&quot;p∧q∨r&quot;), &quot;YES&quot;, &quot;NO&quot;);

julia&gt; submodels(branch)
2-element Vector{SoleModels.ConstantModel{String}}:
 ConstantModel
YES

 ConstantModel
NO


julia&gt; branch2 = Branch(SoleLogics.parseformula(&quot;s→p&quot;), branch, 42);

julia&gt; printmodel.(submodels(branch2));
Branch
┐ p ∧ (q ∨ r)
├ ✔ YES
└ ✘ NO

ConstantModel
YES

ConstantModel
NO

ConstantModel
42

julia&gt; submodels(branch) == immediatesubmodels(branch)
true

julia&gt; submodels(branch2) == immediatesubmodels(branch2)
false</code></pre><p>See also <a href="../autodocs/#SoleModels.immediatesubmodels-Union{Tuple{SoleModels.AbstractModel{O}}, Tuple{O}} where O"><code>immediatesubmodels</code></a>, <a href="../autodocs/#SoleModels.LeafModel"><code>LeafModel</code></a>, <a href="../autodocs/#SoleModels.AbstractModel"><code>AbstractModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleModels.jl/blob/fdc5b058fffd23694dfd6d08c8a14f649b860085/src/symbolic-utils.jl#L66-L117">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../logic/">« Logical foundations</a><a class="docs-footer-nextpage" href="../parse/">Parsing models from other frameworks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 24 October 2024 13:47">Thursday 24 October 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
