<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Logical foundations · SoleModels.jl</title><meta name="title" content="Logical foundations · SoleModels.jl"/><meta property="og:title" content="Logical foundations · SoleModels.jl"/><meta property="twitter:title" content="Logical foundations · SoleModels.jl"/><meta name="description" content="Documentation for SoleModels.jl."/><meta property="og:description" content="Documentation for SoleModels.jl."/><meta property="twitter:description" content="Documentation for SoleModels.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SoleModels.jl/logic/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SoleModels.jl/logic/"/><link rel="canonical" href="https://aclai-lab.github.io/SoleModels.jl/logic/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SoleModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Logical foundations</a></li><li><a class="tocitem" href="../logisets/">Logisets</a></li><li><a class="tocitem" href="../models/">Symbolic models</a></li><li><a class="tocitem" href="../autodocs/">Full reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Logical foundations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Logical foundations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleModels.jl/blob/main/docs/src/logic.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Logical-foundations"><a class="docs-heading-anchor" href="#Logical-foundations">Logical foundations</a><a id="Logical-foundations-1"></a><a class="docs-heading-anchor-permalink" href="#Logical-foundations" title="Permalink"></a></h1><p><a href="https://github.com/aclai-lab/SoleLogics.jl">SoleLogics</a> lays the logical foundations for this package. While the full reference for SoleLogics can be found <a href="https://aclai-lab.github.io/SoleLogics.jl/">here</a>, these are the basic logical concepts needed for <em>symbolic modelling</em>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Atom" href="#SoleLogics.Atom"><code>SoleLogics.Atom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Atom{V} &lt;: SyntaxLeaf
    value::V
end</code></pre><p>An atom, sometimes called an atomic proposition, propositional letter (or simply <em>letter</em>), of type <code>Atom{V}</code> wraps a <code>value::V</code> representing a fact which truth can be assessed on a logical interpretation.</p><p>Atoms are nullary tokens (i.e, they are at the leaves of a syntax tree); note that their atoms cannot be <code>Atom</code>s.</p><p>See also <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>, <a href="@ref"><code>atoms</code></a>, <a href="#SoleLogics.check"><code>check</code></a>, <a href="@ref"><code>SyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/core.jl#L488-L503">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.CONJUNCTION" href="#SoleLogics.CONJUNCTION"><code>SoleLogics.CONJUNCTION</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const CONJUNCTION = NamedConnective{:∧}()
const ∧ = CONJUNCTION
arity(::typeof(∧)) = 2</code></pre><p>Logical conjunction. It can be typed by <code>\wedge&lt;tab&gt;</code>.</p><p>See also <a href="@ref"><code>NamedConnective</code></a>, <a href="@ref"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/base-logic.jl#L125-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.DISJUNCTION" href="#SoleLogics.DISJUNCTION"><code>SoleLogics.DISJUNCTION</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const DISJUNCTION = NamedConnective{:∨}()
const ∨ = DISJUNCTION
arity(::typeof(∨)) = 2</code></pre><p>Logical disjunction. It can be typed by <code>\vee&lt;tab&gt;</code>.</p><p>See also <a href="@ref"><code>NamedConnective</code></a>, <a href="@ref"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/base-logic.jl#L141-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Formula" href="#SoleLogics.Formula"><code>SoleLogics.Formula</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Formula &lt;: Syntactical end</code></pre><p>Abstract type for logical formulas. Examples of <code>Formula</code>s are <code>SyntaxLeaf</code>s (for example, <code>Atom</code>s and <code>Truth</code> values), <code>AbstractSyntaxStructure</code>s (for example, <code>SyntaxTree</code>s and <code>LeftmostLinearForm</code>s) and <code>TruthTable</code>s ( enriched representation, which associates a syntactic structure with additional <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a> structures, which can save computational time upon <a href="https://en.wikipedia.org/wiki/Model_checking">model checking</a>).</p><p>Any formula can be converted into its <a href="@ref"><code>SyntaxTree</code></a> representation via <a href="@ref"><code>tree</code></a>; its <a href="@ref"><code>height</code></a> can be computed, and it can be queried for its syntax <a href="@ref"><code>tokens</code></a>, <a href="@ref"><code>atoms</code></a>, etc... It can be parsed from its <a href="#SoleLogics.syntaxstring"><code>syntaxstring</code></a> representation via <a href="@ref"><code>parseformula</code></a>.</p><p>See also <a href="@ref"><code>tree</code></a>, <a href="@ref"><code>AbstractSyntaxStructure</code></a>, <a href="@ref"><code>SyntaxLeaf</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/core.jl#L154-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.syntaxstring" href="#SoleLogics.syntaxstring"><code>SoleLogics.syntaxstring</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">syntaxstring(s::Syntactical; kwargs...)::String</code></pre><p>Return the string representation of any syntactic object (e.g., <code>Formula</code>, <code>SyntaxTree</code>, <code>SyntaxToken</code>, <code>Atom</code>, <code>Truth</code>, etc). Note that this representation may introduce redundant parentheses. <code>kwargs</code> can be used to specify how to display syntax tokens/trees under some specific conditions.</p><p>The following <code>kwargs</code> are currently supported:</p><ul><li><code>function_notation = false::Bool</code>: when set to <code>true</code>, it forces the use of  function notation for binary operators  (see <a href="https://en.wikipedia.org/wiki/Infix_notation">here</a>).</li><li><code>remove_redundant_parentheses = true::Bool</code>: when set to <code>false</code>, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.</li><li><code>parenthesize_atoms = !remove_redundant_parentheses::Bool</code>: when set to <code>true</code>,  it forces the atoms (which are the leaves of a formula&#39;s tree structure) to be  wrapped in parentheses.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;))
&quot;p ∧ q ∧ r ∧ s ∧ t&quot;

julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;), function_notation=true)
&quot;∧(∧(∧(∧(p, q), r), s), t)&quot;

julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;), remove_redundant_parentheses=false)
&quot;((((p) ∧ (q)) ∧ (r)) ∧ (s)) ∧ (t)&quot;

julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;), remove_redundant_parentheses=true, parenthesize_atoms=true)
&quot;(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)&quot;

julia&gt; syntaxstring(parseformula(&quot;◊((p∧s)→q)&quot;))
&quot;◊((p ∧ s) → q)&quot;

julia&gt; syntaxstring(parseformula(&quot;◊((p∧s)→q)&quot;); function_notation = true)
&quot;◊(→(∧(p, s), q))&quot;</code></pre><p>See also <a href="@ref"><code>parseformula</code></a>, <a href="@ref"><code>SyntaxBranch</code></a>, <a href="@ref"><code>SyntaxToken</code></a>.</p><p><strong>Implementation</strong></p><p>In the case of a syntax tree, <code>syntaxstring</code> is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the <code>syntaxstring</code> must be defined (including the <code>kwargs...</code> part!) for every newly defined <code>SyntaxToken</code> (e.g., <code>SyntaxLeaf</code>s, that is, <code>Atom</code>s and <code>Truth</code> values, and <code>Operator</code>s), in a way that it produces a <em>unique</em> string representation, since <code>Base.hash</code> and <code>Base.isequal</code>, at least for <code>SyntaxTree</code>s, rely on it.</p><p>In particular, for the case of <code>Atom</code>s, the function calls itself on the wrapped value:</p><pre><code class="nohighlight hljs">syntaxstring(a::Atom; kwargs...) = syntaxstring(value(a); kwargs...)</code></pre><p>The <code>syntaxstring</code> for any value defaults to its <code>string</code> representation, but it can be defined by defining the appropriate <code>syntaxstring</code> method.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>syntaxstring</code> for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon <em>parsing</em>. For similar reasons, <code>syntaxstring</code>s should not contain parentheses (<code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>), and, when parsing in function notation, commas (<code>&#39;,&#39;</code>).</p></div></div><p>See also <a href="@ref"><code>SyntaxLeaf</code></a>, <a href="@ref"><code>Operator</code></a>, <a href="@ref"><code>parseformula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/core.jl#L49-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractAlphabet" href="#SoleLogics.AbstractAlphabet"><code>SoleLogics.AbstractAlphabet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractAlphabet{V} end</code></pre><p>Abstract type for representing an alphabet of atoms with values of type <code>V</code>. An alphabet (or <em>propositional alphabet</em>) is a set of atoms (assumed to be <a href="https://en.wikipedia.org/wiki/Countable_set">countable</a>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Atom(1) in ExplicitAlphabet(Atom.(1:10))
true

julia&gt; Atom(1) in ExplicitAlphabet(1:10)
true

julia&gt; Atom(1) in AlphabetOfAny{String}()
false

julia&gt; Atom(&quot;mystring&quot;) in AlphabetOfAny{String}()
true

julia&gt; &quot;mystring&quot; in AlphabetOfAny{String}()
┌ Warning: Please, use Base.in(Atom(mystring), alphabet::AlphabetOfAny{String}) instead of Base.in(mystring, alphabet::AlphabetOfAny{String})
└ @ SoleLogics ...
true</code></pre><p><strong>Implementation</strong></p><p>When implementing a new alphabet type <code>MyAlphabet</code>, you should provide a method for establishing whether an atom belongs to it or not; while, in general, this method should be:</p><pre><code class="nohighlight hljs">function Base.in(p::Atom, a::MyAlphabet)::Bool</code></pre><p>in the case of <em>finite</em> alphabets, it suffices to define a method:</p><pre><code class="nohighlight hljs">function atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}</code></pre><p>By default, an alphabet is considered finite:</p><pre><code class="nohighlight hljs">Base.isfinite(::Type{&lt;:AbstractAlphabet}) = true
Base.isfinite(a::AbstractAlphabet) = Base.isfinite(typeof(a))
Base.in(p::Atom, a::AbstractAlphabet) = Base.isfinite(a) ? Base.in(p, atoms(a)) : error(...)</code></pre><p>See also <a href="@ref"><code>AbstractGrammar</code></a>, <a href="@ref"><code>AlphabetOfAny</code></a>, <a href="#SoleLogics.Atom"><code>Atom</code></a>, <a href="@ref"><code>ExplicitAlphabet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/logics.jl#L8-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractInterpretation" href="#SoleLogics.AbstractInterpretation"><code>SoleLogics.AbstractInterpretation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractInterpretation end</code></pre><p>Abstract type for representing a <a href="https://en.wikipedia.org/wiki/Interpretation_(logic)">logical interpretation</a>. In the case of <a href="https://simple.wikipedia.org/wiki/Propositional_logic">propositional logic</a>, is essentially a map <em>atom → truth value</em>.</p><p>Properties expressed via logical formulas can be <code>check</code>ed on logical interpretations.</p><p>See also <a href="#SoleLogics.check"><code>check</code></a>, <a href="@ref"><code>AbstractAssignment</code></a>, <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/core.jl#L898-L910">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractInterpretationSet" href="#SoleLogics.AbstractInterpretationSet"><code>SoleLogics.AbstractInterpretationSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractInterpretationSet{M&lt;:AbstractInterpretation} &lt;: AbstractDataset end</code></pre><p>Abstract type for ordered sets of interpretations. A set of interpretations, also referred to as a <em>dataset</em> in this context, is a collection of <em>instances</em>, each of which is an interpretation, and is identified by an index i<em>instance::Integer. These structures are especially useful when performing [model checking](https://en.wikipedia.org/wiki/Model</em>checking).</p><p>See also<a href="@ref"><code>truthtype</code></a>, <a href="@ref"><code>InterpretationVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/interpretation-sets.jl#L6-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.check" href="#SoleLogics.check"><code>SoleLogics.check</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check(
    φ::Formula,
    i::AbstractInterpretation,
    args...;
    kwargs...
)::Bool</code></pre><p>Check a formula on a logical interpretation (or model), returning <code>true</code> if the truth value for the formula <code>istop</code>. This process is referred to as (finite) <a href="https://en.wikipedia.org/wiki/Model_checking">model checking</a>, and there are many algorithms for it, typically depending on the complexity of the logic.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @atoms String p q
2-element Vector{Atom{String}}:
 Atom{String}(&quot;p&quot;)
 Atom{String}(&quot;q&quot;)

julia&gt; td = TruthDict([p =&gt; TOP, q =&gt; BOT])
TruthDict with values:
┌────────┬────────┐
│      q │      p │
│ String │ String │
├────────┼────────┤
│      ⊥ │      ⊤ │
└────────┴────────┘

julia&gt; check(CONJUNCTION(p,q), td)
false</code></pre><p>See also <a href="@ref"><code>interpret</code></a>, <a href="#SoleLogics.Formula"><code>Formula</code></a>, <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>, <a href="@ref"><code>TruthDict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/core.jl#L980-L1016">source</a></section><section><div><pre><code class="language-julia hljs">function check(
    φ::SyntaxTree,
    i::AbstractKripkeStructure,
    w::Union{Nothing,&lt;:AbstractWorld} = nothing;
    use_memo::Union{Nothing,AbstractDict{&lt;:Formula,&lt;:Vector{&lt;:AbstractWorld}}} = nothing,
    perform_normalization::Bool = true,
    memo_max_height::Union{Nothing,Int} = nothing,
)::Bool</code></pre><p>Check a formula on a specific word in a <a href="@ref"><code>KripkeStructure</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs, Random

julia&gt; @atoms String p q
2-element Vector{Atom{String}}:
 Atom{String}(&quot;p&quot;)
 Atom{String}(&quot;q&quot;)

julia&gt; fmodal = randformula(Random.MersenneTwister(14), 3, [p,q], SoleLogics.BASE_MODAL_CONNECTIVES)
¬□(p ∨ q)

# A special graph, called Kripke Frame, is created.
# Nodes are called worlds, and the edges are relations between worlds.
julia&gt; worlds = SoleLogics.World.(1:5) # 5 worlds are created, numerated from 1 to 5

julia&gt; edges = Edge.([(1,2), (1,3), (2,4), (3,4), (3,5)])

julia&gt; kframe = SoleLogics.ExplicitCrispUniModalFrame(worlds, Graphs.SimpleDiGraph(edges))

# A valuation function establishes which fact are true on each world
julia&gt; valuation = Dict([
    worlds[1] =&gt; TruthDict([p =&gt; true, q =&gt; false]),
    worlds[2] =&gt; TruthDict([p =&gt; true, q =&gt; true]),
    worlds[3] =&gt; TruthDict([p =&gt; true, q =&gt; false]),
    worlds[4] =&gt; TruthDict([p =&gt; false, q =&gt; false]),
    worlds[5] =&gt; TruthDict([p =&gt; false, q =&gt; true]),
 ])

# Kripke Frame and valuation function are merged in a Kripke Structure
julia&gt; kstruct = KripkeStructure(kframe, valuation)

julia&gt; [w =&gt; check(fmodal, kstruct, w) for w in worlds]
5-element Vector{Pair{SoleLogics.World{Int64}, Bool}}:
 SoleLogics.World{Int64}(1) =&gt; 0
 SoleLogics.World{Int64}(2) =&gt; 1
 SoleLogics.World{Int64}(3) =&gt; 1
 SoleLogics.World{Int64}(4) =&gt; 0
 SoleLogics.World{Int64}(5) =&gt; 0</code></pre><p>See also <a href="@ref"><code>SyntaxTree</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="@ref"><code>KripkeStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/modal-logic.jl#L547-L601">source</a></section><section><div><pre><code class="language-julia hljs">check(
    φ::Formula,
    s::AbstractInterpretationSet,
    i_instance::Integer,
    args...;
    kwargs...
)::Bool</code></pre><p>Check a formula on the <span>$i$</span>-th instance of an <a href="#SoleLogics.AbstractInterpretationSet"><code>AbstractInterpretationSet</code></a>.</p><p>See also <a href="#SoleLogics.AbstractInterpretationSet"><code>AbstractInterpretationSet</code></a>, <a href="#SoleLogics.Formula"><code>Formula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/interpretation-sets.jl#L83-L96">source</a></section><section><div><pre><code class="language-julia hljs">check(
    φ::Formula,
    s::AbstractInterpretationSet,
    args...;
    kwargs...
)::Vector{Bool}</code></pre><p>Check a formula on all instances of an <a href="#SoleLogics.AbstractInterpretationSet"><code>AbstractInterpretationSet</code></a>.</p><p>See also <a href="#SoleLogics.AbstractInterpretationSet"><code>AbstractInterpretationSet</code></a>, <a href="#SoleLogics.Formula"><code>Formula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/interpretation-sets.jl#L107-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractWorld" href="#SoleLogics.AbstractWorld"><code>SoleLogics.AbstractWorld</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractWorld end</code></pre><p>Abstract type for the nodes of an annotated accessibility graph (Kripke structure). This is used, for example, in modal logic, where the truth of formulas is relativized to <em>worlds</em>, that is, nodes of a graph.</p><p><strong>Implementing</strong></p><p>When implementing a new world type, the logical semantics should be defined via <code>accessibles</code> methods; refer to the help for <code>accessibles</code>.</p><p>See also <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/modal-logic.jl#L6-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.GeometricalWorld" href="#SoleLogics.GeometricalWorld"><code>SoleLogics.GeometricalWorld</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GeometricalWorld &lt;: AbstractWorld end</code></pre><p>Abstract type for worlds with a geometrical interpretation.</p><p>See also <a href="@ref"><code>Point</code></a>, <a href="#SoleLogics.Interval"><code>Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>Interval2D</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/algebras/worlds/geometrical-worlds.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Interval" href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Interval{T} &lt;: GeometricalWorld
    x :: T
    y :: T
end</code></pre><p>An interval in a 1-dimensional space, with coordinates of type <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval(1,2),1)
true

julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval(1,2),2)
false

julia&gt; collect(accessibles(SoleLogics.FullDimensionalFrame(5), Interval(1,2), SoleLogics.IA_L))
6-element Vector{Interval{Int64}}:
 (3−4)
 (3−5)
 (4−5)
 (3−6)
 (4−6)
 (5−6)

</code></pre><p>See also <a href="@ref"><code>goeswithdim</code></a>, <a href="#SoleLogics.accessibles"><code>accessibles</code></a>, <a href="@ref"><code>FullDimensionalFrame</code></a>, <a href="@ref"><code>Point</code></a>, <a href="#SoleLogics.Interval2D"><code>Interval2D</code></a>, <a href="#SoleLogics.GeometricalWorld"><code>GeometricalWorld</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/algebras/worlds/geometrical-worlds.jl#L69-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Interval2D" href="#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Interval2D{T} &lt;: GeometricalWorld
    x :: Interval{T}
    y :: Interval{T}
end</code></pre><p>A orthogonal rectangle in a 2-dimensional space, with coordinates of type <code>T</code>. This is the 2-dimensional <code>Interval</code> counterpart, that is, the combination of two orthogonal <code>Interval</code>s.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),1)
false

julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),2)
true

julia&gt; collect(accessibles(SoleLogics.FullDimensionalFrame(5,5), Interval2D((2,3),(2,4)), SoleLogics.IA_LL))
3-element Vector{Interval2D{Int64}}:
 ((4−5)×(5−6))
 ((4−6)×(5−6))
 ((5−6)×(5−6))
</code></pre><p>See also <a href="@ref"><code>goeswithdim</code></a>, <a href="#SoleLogics.accessibles"><code>accessibles</code></a>, <a href="@ref"><code>FullDimensionalFrame</code></a>, <a href="@ref"><code>Point</code></a>, <a href="#SoleLogics.Interval"><code>Interval</code></a>, <a href="#SoleLogics.GeometricalWorld"><code>GeometricalWorld</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/algebras/worlds/geometrical-worlds.jl#L124-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractRelation" href="#SoleLogics.AbstractRelation"><code>SoleLogics.AbstractRelation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractRelation end</code></pre><p>Abstract type for the relations of a multi-modal annotated accessibility graph (Kripke structure). Two noteworthy relations are <code>identityrel</code> and <code>globalrel</code>, which access the current world and all worlds, respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fr = SoleLogics.FullDimensionalFrame((10,),);

julia&gt; Interval(8,11) in (accessibles(fr, Interval(2,5), IA_L))
true</code></pre><p><strong>Implementation</strong></p><p>When implementing a new relation type <code>R</code>, please provide the methods:</p><pre><code class="nohighlight hljs">arity(::R)::Int = ...
syntaxstring(::R; kwargs...)::String = ...</code></pre><p>If the relation is symmetric, please specify its converse relation <code>cr</code> with:</p><pre><code class="nohighlight hljs">hasconverse(::R) = true
converse(::R) = cr</code></pre><p>If the relation is many-to-one or one-to-one, please flag it with:</p><pre><code class="nohighlight hljs">istoone(::R) = true</code></pre><p>If the relation is reflexive or transitive, flag it with:</p><pre><code class="nohighlight hljs">isreflexive(::R) = true
istransitive(::R) = true</code></pre><p>Most importantly, the logical semantics for <code>R</code> should be defined via <code>accessibles</code> methods; refer to the help for <code>accessibles</code>.</p><p>See also <a href="@ref"><code>issymmetric</code></a>, <a href="@ref"><code>isreflexive</code></a>, <a href="@ref"><code>istransitive</code></a>, <a href="@ref"><code>isgrounding</code></a>, <a href="@ref"><code>arity</code></a>, <a href="#SoleLogics.syntaxstring"><code>syntaxstring</code></a>, <a href="@ref"><code>converse</code></a>, <a href="@ref"><code>hasconverse</code></a>, <a href="@ref"><code>istoone</code></a>, <a href="@ref"><code>identityrel</code></a>, <a href="#SoleLogics.globalrel"><code>globalrel</code></a>, <a href="#SoleLogics.accessibles"><code>accessibles</code></a>, <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/modal-logic.jl#L161-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.globalrel" href="#SoleLogics.globalrel"><code>SoleLogics.globalrel</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">struct GlobalRel &lt;: AbstractRelation end;
const globalrel  = GlobalRel();</code></pre><p>Singleton type for the global relation. This is a binary relation via which a world accesses every other world within the frame. The relation is also symmetric, reflexive and transitive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(SoleLogics.globalrel)
&quot;G&quot;

julia&gt; SoleLogics.converse(globalrel)
GlobalRel()</code></pre><p>See also <a href="@ref"><code>identityrel</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>. <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/algebras/relations.jl#L99-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.IA_L" href="#SoleLogics.IA_L"><code>SoleLogics.IA_L</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>See <a href="@ref"><code>IntervalRelation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/algebras/relations/IntervalAlgebra.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractFrame" href="#SoleLogics.AbstractFrame"><code>SoleLogics.AbstractFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractFrame{W&lt;:AbstractWorld} end</code></pre><p>Abstract type for an accessibility graph (Kripke frame), that gives the topology to <a href="https://en.wikipedia.org/wiki/Kripke_structure_(model_checking)">Kripke structures</a>. A frame can be queried for its set of vertices (also called <em>worlds</em>, see <a href="@ref"><code>allworlds</code></a>), and it can be browsed via its accessibility relation(s) (see <a href="#SoleLogics.accessibles"><code>accessibles</code></a>). Refer to <a href="@ref"><code>FullDimensionalFrame</code></a> as an example.</p><p>See also <a href="@ref"><code>truthtype</code></a>, , <a href="@ref"><code>allworlds</code></a>, <a href="@ref"><code>nworlds</code></a>, <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/modal-logic.jl#L47-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractKripkeStructure" href="#SoleLogics.AbstractKripkeStructure"><code>SoleLogics.AbstractKripkeStructure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractKripkeStructure &lt;: AbstractInterpretation end</code></pre><p>Abstract type for representing <a href="https://en.wikipedia.org/wiki/Kripke_structure_(model_checking)">Kripke structures</a>&#39;s. It comprehends a directed graph structure (Kripke frame), where nodes are referred to as <em>worlds</em>, and the binary relation between them is referred to as the <em>accessibility relation</em>. Additionally, each world is associated with a mapping from <code>Atom</code>s to <code>Truth</code> values.</p><p>See also <a href="@ref"><code>frame</code></a>, <a href="@ref"><code>worldtype</code></a>, <a href="#SoleLogics.accessibles"><code>accessibles</code></a>, <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/modal-logic.jl#L492-L504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.accessibles" href="#SoleLogics.accessibles"><code>SoleLogics.accessibles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">accessibles(fr::AbstractUniModalFrame{W}, w::W)::Worlds{W} where {W&lt;:AbstractWorld}</code></pre><p>Return the worlds in frame <code>fr</code> that are accessible from world <code>w</code>.</p><p>See also <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="@ref"><code>AbstractUniModalFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/modal-logic.jl#L110-L116">source</a></section><section><div><pre><code class="language-julia hljs">accessibles(
    fr::AbstractMultiModalFrame{W},
    w::W,
    r::AbstractRelation
) where {W&lt;:AbstractWorld}</code></pre><p>Return the worlds in frame <code>fr</code> that are accessible from world <code>w</code> via relation <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fr = SoleLogics.FullDimensionalFrame((10,),);

julia&gt; typeof(accessibles(fr, Interval(2,5), IA_L))
Base.Generator{...}

julia&gt; typeof(accessibles(fr, globalrel))
Base.Generator{...}

julia&gt; @assert SoleLogics.nworlds(fr) == length(collect(accessibles(fr, globalrel)))

julia&gt; typeof(accessibles(fr, Interval(2,5), identityrel))
Vector{Interval{Int64}}

julia&gt; Interval(8,11) in collect(accessibles(fr, Interval(2,5), IA_L))
true</code></pre><p><strong>Implementation</strong></p><p>Since <code>accessibles</code> always returns an iterator of worlds of the same type <code>W</code>, the current implementation of <code>accessibles</code> for multi-modal frames delegates the enumeration to a lower level <code>_accessibles</code> function, which returns an iterator of parameter tuples that are, then, fed to the world constructor the using IterTools generators, as in:</p><pre><code class="nohighlight hljs">function accessibles(
    fr::AbstractMultiModalFrame{W},
    w::W,
    r::AbstractRelation,
) where {W&lt;:AbstractWorld}
    IterTools.imap(W, _accessibles(fr, w, r))
end</code></pre><p>As such, when defining new frames, worlds, and/or relations, one should provide new methods for <code>_accessibles</code>. For example:</p><pre><code class="nohighlight hljs">_accessibles(fr::Full1DFrame, w::Interval{Int}, ::_IA_A) = zip(Iterators.repeated(w.y), w.y+1:X(fr)+1)</code></pre><p>This pattern is generally convenient; it can, however, be bypassed, although this requires defining two additional methods in order to resolve dispatch ambiguities. When defining a new frame type <code>FR{W}</code>, one can resolve the ambiguities and define a custom <code>accessibles</code> method by providing these three methods:</p><pre><code class="nohighlight hljs"># access worlds through relation `r`
function accessibles(
    fr::FR{W},
    w::W,
    r::AbstractRelation,
) where {W&lt;:AbstractWorld}
    ...
end

# access current world
function accessibles(
    fr::FR{W},
    w::W,
    r::IdentityRel,
) where {W&lt;:AbstractWorld}
    [w]
end

# access all worlds
function accessibles(
    fr::FR{W},
    w::W,
    r::GlobalRel,
) where {W&lt;:AbstractWorld}
    allworlds(fr)
end</code></pre><p>In general, it should be true that <code>collect(accessibles(fr, w, r)) isa AbstractWorlds{W}</code>.</p><p>See also <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>, <a href="@ref"><code>AbstractMultiModalFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.6.10/src/modal-logic.jl#L331-L417">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../logisets/">Logisets »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.0 on <span class="colophon-date" title="Friday 1 December 2023 08:09">Friday 1 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
